以下是前端初级工程师高频面试题及参考答案，涵盖核心知识点：



 新增的表单输入类型
 清除浮动元素，具体场景
 ✅ history如何解决页面刷新404错误
让后端做好映射，jave


1.	CSS相关
border-radius
	◦	问题：如何设置元素的圆角？

	◦	答案：使用border-radius属性，例如border-radius: 10px;。

	◦	问题：如何将元素设置为圆形？

	◦	答案：将border-radius属性值设为50%，例如border-radius: 50%;。

	2.	JavaScript判断数组

	◦	问题：怎样判断一个变量是否为数组？

	◦	答案：两种常用方法，一是直接用Array.isArray(变量名)判断；二是结合typeof和constructor，即typeof 变量名 === 'object' && 变量名.constructor === Array。

	3.	HTML表单提交

	◦	问题：表单提交数据有哪几种方法？各有什么特点？

	◦	答案：主要有GET和POST两种方法。GET方法将数据附加在URL后，数据量小且会在地址栏显示，安全性低；POST方法将数据放在请求体中，数据量更大，且不会直接显示，安全性更高。

	4.	JavaScript获取元素文本

	◦	问题：如何获取元素的文本内容？

	◦	答案：普通场景用innerText，先通过document.getElementById('元素ID')等方式选中元素，再用元素.innerText获取；操作XML或HTML文档时，还可使用textContent属性。

	5.	JavaScript按钮弹窗

	◦	问题：如何实现点击按钮弹出提示框？

	◦	答案：先在HTML中创建按钮（如<button id="myBtn">点击弹窗</button>），再用JavaScript添加点击事件：document.getElementById('myBtn').addEventListener('click', function() { alert('提示内容'); });。




一、HTML相关
 
1. 问题：DOCTYPE的作用是什么？
答案：声明文档的类型和DTD（文档类型定义），告诉浏览器以何种HTML版本规范解析文档，避免进入怪异模式，确保页面以标准模式渲染，保证布局和样式一致性。
 
2. 问题：使用语义化标签的好处是什么？
答案：① 增强代码可读性和维护性；② 有利于搜索引擎SEO（爬虫更易理解内容结构）；③ 提升无障碍访问（屏幕阅读器可更好解析内容）。
 
3. 问题：src和href的区别？
答案： src 用于引入资源（如图片、脚本），会暂停当前文档解析，直到资源加载执行完毕（如 <script src="..."> ）； href 用于建立当前文档与目标资源的关联（如链接、样式表），不会暂停文档解析（如 <link href="..."> ）。
 
二、CSS相关
 
1. 问题：CSS盒模型的两种类型及区别？
答案：① 标准盒模型： width 和 height 仅包含内容区（content）， padding 和 border 在其外部；② IE盒模型（怪异盒模型）： width 和 height 包含content、padding和border。可通过 box-sizing: border-box 切换为IE盒模型。
 
2. 问题：如何实现元素水平居中？
答案：① 块级元素： margin: 0 auto （需设置宽度）；② flex布局：父元素 display: flex; justify-content: center ；③ 定位：子元素 position: absolute; left: 50%; transform: translateX(-50%) 。
 
3. 问题：BFC是什么？如何触发？
答案：BFC（块级格式化上下文）是一个独立的渲染区域，内部元素布局不受外部影响。触发方式：①  overflow: hidden ；②  display: flex/grid ；③  position: absolute/fixed ；④  float: left/right 。应用：清除浮动、避免margin重叠。
 
4. 问题：flex布局中 justify-content 和 align-items 的区别？
答案： justify-content 控制主轴方向的对齐方式（如 center 、 space-between ）； align-items 控制交叉轴方向的对齐方式。
 
三、JavaScript相关
 
1. 问题：typeof和instanceof的区别？
答案： typeof 返回变量的基本类型字符串（如 "number" 、 "object" ），但无法区分数组、null（均返回 "object" ）； instanceof 判断构造函数的原型是否在实例的原型链上，返回布尔值，用于区分引用类型（如 [] instanceof Array 为 true ）。
 
2. 问题：什么是闭包？用途是什么？
答案：闭包是函数嵌套中，内部函数引用外部函数变量，导致外部变量不被销毁的现象。用途：① 模块化（私有变量）；② 保存状态（如计数器）；③ 延迟执行（如定时器回调）。
 
3. 问题：this的指向规则？
答案：① 全局this：浏览器中指向 window ，Node中指向 global ；② 函数调用： obj.fn() 中 this 指向 obj ，独立调用（ fn() ）指向全局；③ 构造函数： new Fn() 中 this 指向新实例；④ 箭头函数：无自己的 this ，继承外层作用域的 this 。
 
4. 问题：Promise的三种状态及常用方法？
答案：状态： pending （初始）、 fulfilled （成功）、 rejected （失败），状态一旦改变不可逆转。方法： then() （处理成功/失败）、 catch() （处理失败）、 finally() （无论状态如何都执行）、 Promise.all() （等待所有成功）。
 
5. 问题：防抖和节流的区别及应用？
答案：① 防抖：触发后延迟n秒执行，若n秒内再次触发则重新计时（如搜索输入联想）；② 节流：n秒内只执行一次（如滚动加载）。
 
四、Vue相关
 
1. 问题：Vue双向数据绑定原理？
答案：通过 Object.defineProperty 劫持数据（getter/setter），结合发布-订阅模式：数据变化时，setter通知订阅者（视图）更新；视图变化时，通过事件监听（如 input ）更新数据。 v-model 是语法糖（绑定 value 和 input 事件）。
 
2. 问题：computed和watch的区别？
答案： computed 是计算属性，依赖数据变化自动更新，有缓存（依赖不变则不重新计算），适合复杂计算； watch 监听数据变化，可执行异步操作，适合数据变化后的副作用（如请求接口）。
 
3. 问题：Vue组件间通信方式？
答案：① 父子： props  +  $emit ；② 兄弟：事件总线（ new Vue() ）、Vuex；③ 跨级： provide/inject 、Vuex；④ 任意组件：Vuex/Pinia。
 
4. 问题：Vue的生命周期钩子（常用）？
答案：①  created ：实例创建完成，可访问数据，未挂载DOM；②  mounted ：DOM挂载完成，可操作DOM；③  updated ：数据更新导致DOM重新渲染后；④  beforeDestroy ：实例销毁前，可清理定时器等。
 
五、浏览器相关
 
1. 问题：浏览器缓存机制（强缓存和协商缓存）？
答案：① 强缓存：通过 Cache-Control （如 max-age=3600 ）或 Expires 控制，直接从缓存读取，不发请求；② 协商缓存：通过 Etag/If-None-Match 或 Last-Modified/If-Modified-Since ，请求服务器判断是否需更新，返回304则用缓存。
 
2. 问题：如何解决跨域？
答案：① CORS：服务器设置 Access-Control-Allow-Origin ；② JSONP：利用 <script> 标签跨域，仅支持GET；③ 代理：开发环境用webpack-dev-server代理，生产环境用Nginx反向代理。
 
3. 问题：localStorage、sessionStorage、cookie的区别？
答案：① 存储大小：cookie约4KB，前两者约5MB；② 有效期：localStorage永久，sessionStorage关闭页面失效，cookie可设置过期时间；③ 发送请求：cookie随请求发送，前两者不发送。
 
六、性能优化相关
 
1. 问题：减少重绘和重排的方法？
答案：① 合并DOM操作（如用 DocumentFragment ）；② 样式集中修改（避免逐条设置 style ）；③ 使用 transform 和 opacity （仅触发合成层，不重排重绘）；④ 脱离文档流（ position: absolute/fixed ）。
 
2. 问题：图片优化方法？
答案：① 懒加载（ loading="lazy" 或JS监听滚动）；② 选择合适格式（webp比jpg小30%，小图标用SVG）；③ 压缩图片（工具如TinyPNG）；④ 精灵图（合并小图减少请求）。
 
3. 问题：CDN的作用？
答案：CDN（内容分发网络）通过多节点缓存资源，用户从最近节点获取资源，减少网络延迟，提高加载速度，分担源服务器压力。
 
## History模式解决页面刷新404错误

### 问题原因
History模式使用HTML5 History API，URL不带#号，看起来更美观（如 `/user/profile`）。但当用户直接访问或刷新页面时，浏览器会向服务器请求对应路径的资源，而服务器上并不存在这些路径的实际文件，导致404错误。

### 解决方案

#### 1. 服务器配置（核心解决方案）

**Nginx配置：**
```nginx
location / {
    try_files $uri $uri/ /index.html;
}
```

**Apache配置：**
```apache
<IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteBase /
    RewriteRule ^index\.html$ - [L]
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule . /index.html [L]
</IfModule>
```

**Node.js Express配置：**
```javascript
// 所有路由都返回index.html
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'dist/index.html'));
});
```

#### 2. 前端路由配置
```javascript
// Vue Router
const router = createRouter({
    history: createWebHistory(),
    routes: [
        // 添加404页面处理
        {
            path: '/:pathMatch(.*)*',
            name: 'NotFound',
            component: NotFound
        }
    ]
});

// React Router
import { BrowserRouter } from 'react-router-dom';
<BrowserRouter basename="/app">
    <Routes>
        <Route path="*" element={<NotFound />} />
    </Routes>
</BrowserRouter>
```

#### 3. 开发环境配置
```javascript
// webpack-dev-server
module.exports = {
    devServer: {
        historyApiFallback: true, // 开启history模式支持
        // 或者更详细的配置
        historyApiFallback: {
            rewrites: [
                { from: /^\/admin/, to: '/admin.html' },
                { from: /./, to: '/index.html' }
            ]
        }
    }
};

// Vite配置
export default {
    server: {
        historyApiFallback: true
    }
};
```

### 工作原理
1. **服务器配置**：当请求不存在的路径时，服务器返回 `index.html`
2. **前端接管**：浏览器加载 `index.html` 后，前端路由根据URL路径渲染对应组件
3. **404处理**：前端路由可以处理无效路径，显示404页面

### 注意事项
- 服务器配置是必需的，否则刷新页面仍会404
- 需要在前端添加404路由处理无效路径
- SEO考虑：搜索引擎可能无法正确索引动态路由
- 服务器日志会显示大量404请求（实际被重定向到index.html）

以上内容覆盖初级前端核心考点，建议结合代码实例理解，注重实际应用场景~

