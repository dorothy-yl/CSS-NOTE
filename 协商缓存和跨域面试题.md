# HTTP缓存和跨域经典面试题

## 一、强缓存

### 1. 什么是强缓存？强缓存的实现原理？

**答案：**
强缓存是指浏览器直接从本地缓存中获取资源，不需要向服务器发送请求。当强缓存生效时，浏览器直接返回200状态码（from cache）。

**两种实现方式：**

**1. Expires（HTTP/1.0）**
```http
# 服务器响应头
HTTP/1.1 200 OK
Expires: Wed, 21 Oct 2025 07:28:00 GMT
Content-Type: text/html

# 缺点：
# 1. 使用绝对时间，依赖客户端时间
# 2. 客户端时间被修改会导致缓存失效
# 3. 写法复杂，容易出错
```

**2. Cache-Control（HTTP/1.1）**
```http
# 服务器响应头
HTTP/1.1 200 OK
Cache-Control: max-age=31536000  # 缓存一年
Content-Type: text/css

# 常用指令：
# max-age=秒数：缓存最大有效时间
# no-cache：需要协商缓存验证
# no-store：不缓存
# private：只能被浏览器缓存
# public：可以被任何缓存（包括CDN）
# must-revalidate：缓存过期后必须验证
```

### 2. 强缓存的常见配置场景

**场景1：静态资源长期缓存**
```javascript
// 带hash的静态资源，可以设置长期缓存
app.use('/static', express.static('public', {
  setHeaders: (res, path) => {
    if (path.includes('.') && path.match(/\.[0-9a-f]{8}\./)) {
      // app.12345678.js 这种带hash的文件
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    }
  }
}));
```

**场景2：HTML文件不缓存**
```javascript
// HTML文件需要每次检查更新
app.get('/*.html', (req, res) => {
  res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
  res.setHeader('Pragma', 'no-cache'); // HTTP/1.0兼容
  res.setHeader('Expires', '0');
  res.sendFile(path.join(__dirname, 'index.html'));
});
```

**场景3：API接口缓存策略**
```javascript
// API数据缓存5分钟
app.get('/api/data', (req, res) => {
  res.setHeader('Cache-Control', 'private, max-age=300');
  res.json(data);
});

// 用户相关接口不缓存
app.get('/api/user', (req, res) => {
  res.setHeader('Cache-Control', 'no-store');
  res.json(userData);
});
```

### 3. 强缓存失效的判断流程

```javascript
// 浏览器缓存判断流程
function shouldUseCache(request, cachedResponse) {
  // 1. 检查Cache-Control
  const cacheControl = cachedResponse.headers['cache-control'];
  if (cacheControl) {
    const maxAge = parseMaxAge(cacheControl);
    const age = Date.now() - cachedResponse.timestamp;
    if (age < maxAge * 1000) {
      return true; // 使用强缓存
    }
  }

  // 2. 检查Expires（Cache-Control优先级更高）
  const expires = cachedResponse.headers['expires'];
  if (expires && new Date(expires) > new Date()) {
    return true; // 使用强缓存
  }

  return false; // 强缓存失效，走协商缓存
}
```

### 4. 强缓存的常见面试题

**Q1：Expires和Cache-Control的区别？**
```javascript
// Expires：HTTP/1.0，绝对时间
Expires: Wed, 21 Oct 2025 07:28:00 GMT

// Cache-Control：HTTP/1.1，相对时间
Cache-Control: max-age=86400

// 两者同时存在时，Cache-Control优先级更高
```

**Q2：如何处理缓存更新问题？**
```javascript
// 1. 文件名加hash
// webpack配置
output: {
  filename: '[name].[contenthash:8].js'
}

// 2. 版本号查询参数
<link rel="stylesheet" href="/style.css?v=1.0.1">

// 3. HTML meta标签（不推荐，只对HTML有效）
<meta http-equiv="Cache-Control" content="no-cache">
```

**Q3：private和public的区别？**
```javascript
// private：只能被浏览器缓存
Cache-Control: private, max-age=300
// 适用场景：用户个人数据

// public：可以被任何中间代理缓存
Cache-Control: public, max-age=3600
// 适用场景：静态资源、公共数据
```

**Q4：no-cache和no-store的区别？**
```javascript
// no-cache：可以缓存，但使用前必须验证
Cache-Control: no-cache
// 效果：强制走协商缓存

// no-store：完全不缓存
Cache-Control: no-store
// 效果：每次都请求最新资源
```

## 二、协商缓存

**答案：**
协商缓存是HTTP缓存机制的一种，当强缓存失效时，浏览器会向服务器发送请求，服务器根据请求头中的缓存标识来决定是否使用缓存。

**实现原理：**
1. 浏览器发送请求时携带缓存标识（If-Modified-Since 或 If-None-Match）
2. 服务器比较缓存标识与资源当前状态
3. 如果资源未变化，返回304状态码，浏览器使用本地缓存
4. 如果资源已变化，返回200状态码和新的资源内容

**两种协商缓存方式：**

1. **Last-Modified / If-Modified-Since**
```http
# 首次请求响应头
HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
Cache-Control: no-cache

# 再次请求请求头
GET /api/data HTTP/1.1
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT

# 服务器响应
HTTP/1.1 304 Not Modified
```

2. **ETag / If-None-Match**
```http
# 首次请求响应头
HTTP/1.1 200 OK
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Cache-Control: no-cache

# 再次请求请求头
GET /api/data HTTP/1.1
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"

# 服务器响应
HTTP/1.1 304 Not Modified
```

### 2. Last-Modified和ETag的区别？

**答案：**

| 特性 | Last-Modified | ETag |
|------|---------------|------|
| **精度** | 秒级精度 | 任意精度 |
| **性能** | 性能更好 | 需要计算哈希值 |
| **分布式** | 不适合分布式系统 | 适合分布式系统 |
| **文件变化** | 只检测内容变化 | 检测内容和元数据变化 |
| **实现复杂度** | 简单 | 相对复杂 |

**ETag的优势：**
1. 可以检测文件内容变化，即使修改时间相同
2. 支持分布式系统，避免时间同步问题
3. 可以检测文件元数据变化（如权限）

**Last-Modified的优势：**
1. 实现简单，性能开销小
2. 人类可读，便于调试

### 3. 强缓存 vs 协商缓存对比

**答案：**

| 对比项 | 强缓存 | 协商缓存 |
|--------|--------|----------|
| **是否发送请求** | 不发送请求 | 发送请求 |
| **状态码** | 200 (from cache) | 304 (Not Modified) |
| **实现方式** | Expires、Cache-Control | Last-Modified/If-Modified-Since、ETag/If-None-Match |
| **优先级** | 优先级高 | 强缓存失效后才使用 |
| **网络开销** | 无 | 有请求但无响应体 |
| **适用场景** | 静态资源、不常变化的文件 | 需要实时性的资源 |

**缓存决策流程：**
```javascript
// 浏览器缓存决策过程
function getCachedResource(url) {
  const cache = getCache(url);

  // 1. 先判断强缓存
  if (cache && isStrongCacheValid(cache)) {
    return cache.data; // 200 from cache
  }

  // 2. 强缓存失效，判断协商缓存
  if (cache && cache.etag) {
    const response = fetch(url, {
      headers: {
        'If-None-Match': cache.etag,
        'If-Modified-Since': cache.lastModified
      }
    });

    if (response.status === 304) {
      return cache.data; // 使用缓存
    }
  }

  // 3. 缓存都失效，获取新资源
  return fetchNewResource(url);
}
```

**最佳实践组合：**
```javascript
// 静态资源：强缓存 + 文件hash
app.use('/static', (req, res) => {
  // app.a3b4c5d6.js
  res.setHeader('Cache-Control', 'public, max-age=31536000');
});

// HTML文件：协商缓存
app.get('/*.html', (req, res) => {
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('ETag', generateETag(content));
  res.setHeader('Last-Modified', lastModified);
});

// API接口：短时间强缓存 + 协商缓存
app.get('/api/data', (req, res) => {
  res.setHeader('Cache-Control', 'private, max-age=60');
  res.setHeader('ETag', generateETag(data));
});
```

### 4. 协商缓存的经典面试题场景？

**答案：**

**场景1：文件内容未变化，但修改时间变化**
```javascript
// 问题：文件内容相同，但touch命令修改了时间
// Last-Modified会认为文件已变化，导致不必要的下载
// ETag可以正确识别内容未变化

// 解决方案：优先使用ETag，Last-Modified作为备选
if (request.headers['if-none-match'] === currentETag) {
  return 304; // 使用缓存
} else if (request.headers['if-modified-since'] === lastModified) {
  return 304; // 使用缓存
} else {
  return 200; // 返回新内容
}
```

**场景2：分布式系统中的缓存一致性问题**
```javascript
// 问题：多台服务器时间不同步
// 解决方案：使用ETag而不是Last-Modified

// 服务器A
const etagA = generateETag(content); // "abc123"

// 服务器B  
const etagB = generateETag(content); // "abc123" (相同内容)

// 即使时间不同步，ETag也能正确判断
```

**场景3：CDN边缘节点的缓存策略**
```javascript
// CDN节点缓存策略
app.get('/api/data', (req, res) => {
  const etag = generateETag(data);
  const lastModified = new Date(fileStats.mtime).toUTCString();
  
  // 设置缓存头
  res.set({
    'ETag': etag,
    'Last-Modified': lastModified,
    'Cache-Control': 'no-cache' // 强制协商缓存
  });
  
  // 检查协商缓存
  if (req.headers['if-none-match'] === etag) {
    return res.status(304).end();
  }
  
  if (req.headers['if-modified-since'] === lastModified) {
    return res.status(304).end();
  }
  
  res.json(data);
});
```

## 二、跨域问题

### 1. 什么是跨域？为什么会出现跨域问题？

**答案：**
跨域是指浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的。

**同源策略限制：**
- 协议相同（http/https）
- 域名相同
- 端口相同

**跨域场景示例：**
```javascript
// 同源：http://localhost:3000
// 跨域：https://localhost:3000 (协议不同)
// 跨域：http://localhost:8080 (端口不同)  
// 跨域：http://api.example.com (域名不同)
```

**为什么需要同源策略：**
1. **防止CSRF攻击**：恶意网站无法获取用户在其他网站的数据
2. **保护用户隐私**：防止恶意网站读取用户敏感信息
3. **维护数据安全**：防止恶意网站篡改其他网站的数据

### 2. 跨域的解决方案有哪些？

**答案：**

**1. CORS（跨域资源共享）**

📝 **面试背诵要点：**
- **定义**：CORS是W3C标准，通过服务器设置响应头来告诉浏览器允许哪些跨域请求
- **核心原理**：服务端在响应头中添加Access-Control-*字段，浏览器据此判断是否允许跨域
- **主要响应头**：
  - `Access-Control-Allow-Origin`：允许的源
  - `Access-Control-Allow-Methods`：允许的HTTP方法
  - `Access-Control-Allow-Headers`：允许的请求头
  - `Access-Control-Allow-Credentials`：是否允许携带Cookie
  - `Access-Control-Max-Age`：预检请求缓存时间
- **优点**：
  - 支持所有HTTP方法
  - 安全可控，可精确配置
  - 是现代浏览器推荐的跨域解决方案
- **缺点**：
  - 需要服务端配合设置
  - 老版本浏览器不支持（IE10以下）

```javascript
// 服务端设置CORS头
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*'); // 允许所有域名
  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization');
  res.header('Access-Control-Allow-Credentials', 'true'); // 允许携带cookie

  // 预检请求处理
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

// 客户端请求
fetch('http://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  },
  credentials: 'include', // 携带cookie
  body: JSON.stringify(data)
});
```

**2. JSONP（JSON with Padding）**

📝 **面试背诵要点：**
- **原理**：利用`<script>`标签不受同源策略限制的特点，动态创建script标签请求跨域资源
- **实现步骤**：
  1. 客户端定义回调函数
  2. 创建script标签，src指向跨域API并传递回调函数名
  3. 服务端返回函数调用形式的数据
  4. 浏览器自动执行返回的JavaScript代码
- **优点**：
  - 兼容性好，支持老版本浏览器
  - 实现简单，不需要额外配置
- **缺点**：
  - 只支持GET请求
  - 存在安全隐患（XSS攻击）
  - 错误处理困难
  - 需要服务端配合

```javascript
// 客户端
function jsonp(url, callback) {
  const script = document.createElement('script');
  const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());

  window[callbackName] = function(data) {
    callback(data);
    document.body.removeChild(script);
    delete window[callbackName];
  };

  script.src = url + '?callback=' + callbackName;
  document.body.appendChild(script);
}

// 使用
jsonp('http://api.example.com/data?callback=handleData', function(data) {
  console.log(data);
});

// 服务端
app.get('/data', (req, res) => {
  const data = { message: 'Hello World' };
  const callback = req.query.callback;
  res.send(`${callback}(${JSON.stringify(data)});`);
});
```

**3. 代理服务器**

📝 **面试背诵要点：**
- **原理**：同源策略是浏览器的限制，服务器之间没有跨域限制。通过同域的代理服务器转发请求
- **实现方式**：
  1. 开发环境：webpack-dev-server、vite等开发服务器的proxy配置
  2. 生产环境：Nginx反向代理
  3. Node.js中间层代理
- **工作流程**：
  1. 前端请求同域的代理接口
  2. 代理服务器转发请求到目标服务器
  3. 目标服务器返回数据给代理服务器
  4. 代理服务器返回数据给前端
- **优点**：
  - 前端无需任何修改
  - 可以灵活处理请求和响应
  - 可以隐藏真实的服务器地址
- **缺点**：
  - 需要额外的代理服务器
  - 增加了请求的延迟

```javascript
// webpack devServer代理
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};

// nginx代理
server {
  listen 80;
  server_name localhost;

  location /api/ {
    proxy_pass http://api.example.com/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
  }
}
```

**4. postMessage**

📝 **面试背诵要点：**
- **作用**：HTML5新增API，用于不同源的窗口间安全通信
- **适用场景**：
  - 页面与iframe之间的通信
  - 页面与弹出窗口的通信
  - 多个标签页之间的通信
- **API使用**：
  - 发送：`targetWindow.postMessage(data, targetOrigin)`
  - 接收：`window.addEventListener('message', handler)`
- **安全性**：
  - 必须验证`event.origin`确保消息来源可信
  - 指定明确的`targetOrigin`而非使用'*'
- **优点**：
  - 安全可靠，浏览器原生支持
  - 可以传递结构化数据
- **缺点**：
  - 只能用于窗口间通信
  - IE8/9只支持字符串数据

```javascript
// 父页面
window.addEventListener('message', function(event) {
  if (event.origin !== 'http://trusted-domain.com') return;
  console.log('收到消息:', event.data);
});

// 子页面（iframe）
parent.postMessage('Hello Parent', 'http://parent-domain.com');
```

**5. document.domain**

📝 **面试背诵要点：**
- **作用**：通过设置相同的document.domain实现不同子域之间的跨域
- **限制条件**：
  - 只能用于二级域名相同的情况
  - 如：a.example.com 和 b.example.com
  - 不能跨协议（http和https不行）
- **原理**：将document.domain设置为相同的主域，浏览器就认为它们同源
- **使用步骤**：
  1. 两个页面都设置`document.domain = 'example.com'`
  2. 之后可以互相访问DOM和JavaScript对象
- **优点**：
  - 实现简单
  - 适合公司内部不同子域的项目
- **缺点**：
  - 只适用于子域名场景
  - 设置后端口号会重置为null
  - 安全性降低

```javascript
// 适用于子域名跨域
// 主页面：http://www.example.com
document.domain = 'example.com';

// 子页面：http://api.example.com
document.domain = 'example.com';
// 现在可以互相访问
```

### 3. CORS的预检请求是什么？

📝 **面试背诵要点：**

**定义与作用：**
- 预检请求（Preflight Request）是浏览器在发送非简单跨域请求前，自动发送的OPTIONS请求
- 目的是询问服务器是否允许该跨域请求，避免发送实际请求后被拒绝

**简单请求 vs 非简单请求：**

**简单请求（不触发预检）需同时满足：**
1. 方法只能是：GET、HEAD、POST
2. 请求头只能包含：
   - Accept
   - Accept-Language
   - Content-Language
   - Content-Type（仅限下面三种）
3. Content-Type只能是：
   - application/x-www-form-urlencoded
   - multipart/form-data
   - text/plain

**非简单请求（触发预检）的情况：**
1. 使用了PUT、DELETE、PATCH等方法
2. Content-Type为application/json
3. 设置了自定义请求头（如Authorization）

**预检请求的特点：**
- 使用OPTIONS方法
- 包含`Access-Control-Request-Method`头（实际请求方法）
- 包含`Access-Control-Request-Headers`头（实际请求头）
- 不包含请求体

**优化预检请求：**
- 设置`Access-Control-Max-Age`缓存预检结果
- 尽可能使用简单请求避免预检
- 合理设计API减少预检次数

**预检请求流程：**
```javascript
// 1. 浏览器发送预检请求
OPTIONS /api/data HTTP/1.1
Origin: http://localhost:3000
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Content-Type,Authorization

// 2. 服务器响应
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: GET,POST,PUT,DELETE
Access-Control-Allow-Headers: Content-Type,Authorization
Access-Control-Max-Age: 86400  // 缓存24小时

// 3. 浏览器发送实际请求
PUT /api/data HTTP/1.1
Origin: http://localhost:3000
Content-Type: application/json
Authorization: Bearer token
```

### 4. 跨域携带Cookie的问题？

📝 **面试背诵要点：**

**默认行为：**
- 跨域请求默认不携带Cookie和HTTP认证信息
- 这是出于安全考虑，防止CSRF攻击

**携带Cookie的条件（必须同时满足）：**

**1. 客户端配置：**
- fetch：设置`credentials: 'include'`
- XMLHttpRequest：设置`withCredentials = true`
- axios：设置`withCredentials: true`

**2. 服务端配置：**
- 必须设置`Access-Control-Allow-Credentials: true`
- `Access-Control-Allow-Origin`不能是通配符`*`，必须是具体域名
- 响应头必须包含`Set-Cookie`时的`SameSite`属性考虑

**重要限制：**
1. Origin不能使用`*`：当`Allow-Credentials`为true时，`Allow-Origin`必须是明确的域名
2. 安全性考虑：只允许信任的域名携带Cookie
3. Cookie的SameSite属性：
   - `SameSite=Strict`：完全禁止跨域携带
   - `SameSite=Lax`：部分允许（导航请求）
   - `SameSite=None`：允许跨域（需要Secure）

**常见错误：**
- 错误：同时设置`Allow-Origin: *`和`Allow-Credentials: true`
- 错误：忘记在客户端设置credentials
- 错误：Cookie设置了`SameSite=Strict`

```javascript
// 客户端配置
// fetch请求
fetch('http://api.example.com/data', {
  credentials: 'include' // 携带cookie
});

// XMLHttpRequest
const xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open('GET', 'http://api.example.com/data');
xhr.send();

// 服务端配置
// 不能使用通配符 *
res.header('Access-Control-Allow-Origin', 'http://localhost:3000');
res.header('Access-Control-Allow-Credentials', 'true');

// 动态设置允许的域名
const allowedOrigins = ['http://localhost:3000', 'http://localhost:8080'];
const origin = req.headers.origin;
if (allowedOrigins.includes(origin)) {
  res.header('Access-Control-Allow-Origin', origin);
}
res.header('Access-Control-Allow-Credentials', 'true');
```

### 5. 跨域问题的经典面试场景？

**答案：**

**场景1：开发环境跨域问题**
```javascript
// 问题：本地开发时前端localhost:3000访问后端localhost:8080
// 解决方案：开发服务器代理

// package.json
{
  "scripts": {
    "dev": "webpack serve --config webpack.dev.js"
  }
}

// webpack.dev.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};
```

**场景2：生产环境跨域问题**
```javascript
// 问题：前端域名和后端域名不同
// 解决方案：CORS配置

// 后端CORS中间件
const cors = require('cors');
app.use(cors({
  origin: ['https://www.example.com', 'https://admin.example.com'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
```

**场景3：第三方API跨域问题**
```javascript
// 问题：调用第三方API遇到跨域限制
// 解决方案：后端代理

// 后端代理接口
app.get('/api/weather', async (req, res) => {
  try {
    const response = await fetch('https://api.weather.com/data', {
      headers: {
        'Authorization': `Bearer ${process.env.WEATHER_API_KEY}`
      }
    });
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch weather data' });
  }
});
```

**场景4：WebSocket跨域问题**
```javascript
// 问题：WebSocket连接跨域
// 解决方案：服务端设置CORS

const WebSocket = require('ws');
const wss = new WebSocket.Server({
  port: 8080,
  verifyClient: (info) => {
    const origin = info.origin;
    const allowedOrigins = ['http://localhost:3000', 'https://example.com'];
    return allowedOrigins.includes(origin);
  }
});
```

## 三、面试重点总结

### HTTP缓存重点
1. **强缓存机制**：
   - Expires vs Cache-Control的区别
   - max-age、no-cache、no-store的使用场景
   - 缓存更新策略（hash、版本号）

2. **协商缓存机制**：
   - Last-Modified vs ETag的区别和适用场景
   - 304状态码的触发条件
   - 分布式系统中的缓存策略

3. **缓存策略选择**：
   - 静态资源：强缓存 + hash指纹
   - HTML文件：协商缓存或不缓存
   - API接口：根据业务需求选择

### 跨域问题重点
1. **安全理解**：同源策略的作用和必要性
2. **解决方案**：CORS、JSONP、代理等方案的优缺点
3. **实践应用**：开发和生产环境的不同处理方式
4. **深入理解**：预检请求、Cookie处理等细节

### 常见面试问题

**缓存相关：**
1. 强缓存和协商缓存的区别是什么？
2. Cache-Control的no-cache和no-store有什么区别？
3. 为什么需要协商缓存？强缓存不够吗？
4. ETag和Last-Modified可以同时使用吗？优先级如何？
5. 如何解决缓存更新问题？
6. 分布式系统中如何保证缓存一致性？
7. from memory cache和from disk cache的区别？

**跨域相关：**
1. 为什么会有跨域限制？同源策略的作用？
2. CORS和JSONP的区别和适用场景？
3. 简单请求和非简单请求的区别？
4. CORS预检请求什么时候触发？如何避免？
5. 跨域请求如何携带Cookie？
6. 开发环境和生产环境的跨域处理有什么不同？
7. 如何处理跨域的图片、字体等静态资源？

这些知识点都是前端面试中的高频考点，掌握这些内容能够帮助您在面试中更好地回答相关问题！
