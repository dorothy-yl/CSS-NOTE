# 前端面试题 - 答案版（60分钟，100分）

## 一、HTML部分（10分钟，15分）

### 1. 标签语义化（7分）
1. **什么是HTML语义化？为什么要使用语义化标签？（4分）**

**答案：**
HTML语义化是指使用合适的HTML标签来描述内容的结构和含义，让标签本身就能表达内容的语义。

使用语义化标签的原因：
- **可读性更好**：代码结构清晰，便于开发者理解和维护
- **SEO优化**：搜索引擎能更好地理解页面内容，提高搜索排名
- **无障碍性**：屏幕阅读器等辅助设备能更好地解析内容
- **跨设备兼容**：在不同设备上能更好地展示内容结构

2. **请列举5个HTML5语义化标签并说明其用途（3分）**

**答案：**
- `<header>`：定义文档或节的页眉，通常包含导航、logo等
- `<nav>`：定义导航链接的容器
- `<article>`：定义独立的内容区块，如博客文章、新闻等
- `<section>`：定义文档中的节或区域
- `<footer>`：定义文档或节的页脚，通常包含版权信息、联系方式等

### 2. H5新特性（8分）
1. **HTML5新增了哪些API？请列举3个并简述其功能（4分）**

**答案：**
- **Canvas API**：提供了通过JavaScript绘制2D图形的能力，可用于图表、游戏、图像处理等
- **Geolocation API**：获取用户的地理位置信息，用于地图应用、位置服务等
- **Web Storage API**：包括localStorage和sessionStorage，提供客户端数据存储能力

2. **Canvas和SVG的区别是什么？各适用于什么场景？（4分）**

**答案：**

**区别：**
- Canvas是基于像素的位图，通过JavaScript绘制；SVG是基于XML的矢量图
- Canvas不支持事件处理器；SVG支持事件处理器
- Canvas适合图像密集型的游戏；SVG适合带有大型渲染区域的应用
- Canvas依赖分辨率；SVG不依赖分辨率

**适用场景：**
- **Canvas**：游戏开发、图像编辑、实时数据可视化、复杂动画
- **SVG**：图标、Logo、简单动画、可缩放的图表、地图

## 二、CSS部分（15分钟，25分）

### 3. 元素居中（10分）
1. **实现水平垂直居中的方法有哪些？请写出至少3种方案（6分）**

**答案：**

```css
/* 方法1：Flexbox */
.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}

/* 方法2：Grid */
.parent {
    display: grid;
    place-items: center;
}

/* 方法3：绝对定位 + transform */
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

/* 方法4：绝对定位 + margin auto（需要固定宽高） */
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    margin: auto;
    width: 200px;
    height: 100px;
}
```

2. **如何实现一个固定宽高比的响应式容器？（4分）**

**答案：**

```css
/* 方法1：padding-top/bottom 百分比 */
.aspect-ratio-box {
    width: 100%;
    padding-top: 56.25%; /* 16:9 比例 */
    position: relative;
}
.aspect-ratio-content {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}

/* 方法2：使用 aspect-ratio 属性（现代浏览器） */
.aspect-ratio-box {
    width: 100%;
    aspect-ratio: 16 / 9;
}
```

### 4. BFC（块级格式化上下文）（8分）
1. **什么是BFC？触发BFC的条件有哪些？（4分）**

**答案：**

BFC（Block Formatting Context）是一个独立的渲染区域，内部元素的渲染不会影响外部元素。

**触发BFC的条件：**
- 根元素（`<html>`）
- 浮动元素（float不为none）
- 绝对定位元素（position为absolute或fixed）
- display为inline-block、table-cell、flex、grid等
- overflow不为visible

2. **BFC有什么作用？请举例说明（4分）**

**答案：**

- **清除浮动**：BFC可以包含浮动元素，解决高度塌陷问题
- **防止margin重叠**：两个BFC之间的margin不会重叠
- **防止元素被浮动元素覆盖**：BFC区域不会与浮动元素重叠

```css
/* 清除浮动示例 */
.container {
    overflow: hidden; /* 触发BFC */
}
.float-child {
    float: left;
}
```

### 5. CSS3动画（7分）
1. **CSS3中transform有哪些常用属性？（3分）**

**答案：**
- `translate(x, y)`：平移
- `rotate(angle)`：旋转
- `scale(x, y)`：缩放
- `skew(x-angle, y-angle)`：倾斜
- `matrix()`：矩阵变换

2. **如何实现一个元素的淡入淡出效果？请写出关键代码（4分）**

**答案：**

```css
/* 使用CSS动画 */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
}

.fade-in {
    animation: fadeIn 0.5s ease-in forwards;
}

.fade-out {
    animation: fadeOut 0.5s ease-out forwards;
}

/* 或使用transition */
.fade-element {
    transition: opacity 0.5s ease;
    opacity: 1;
}

.fade-element.hidden {
    opacity: 0;
}
```

## 三、JavaScript部分（25分钟，40分）

### 6. this指向问题（10分）

```javascript
const obj = {
    name: '张三',
    getName: function() {
        return this.name;
    },
    getNameArrow: () => {
        return this.name;
    }
};

const getName = obj.getName;
console.log(obj.getName());      // 输出：'张三'
console.log(getName());           // 输出：undefined（严格模式）或 window.name（非严格模式）
console.log(obj.getNameArrow()); // 输出：undefined（箭头函数this指向外层作用域）
```

**解释：**
- 第一个：通过对象调用方法，this指向obj
- 第二个：函数赋值后单独调用，this指向全局对象或undefined
- 第三个：箭头函数没有自己的this，继承外层作用域的this

### 7. 事件处理中的this（8分）

```javascript
class Button {
    constructor(name) {
        this.name = name;
    }
    
    handleClick() {
        console.log(this.name);
    }
    
    handleClickArrow = () => {
        console.log(this.name);
    }
}

const btn = new Button('提交按钮');
const button = document.getElementById('myButton');

button.addEventListener('click', btn.handleClick);      // 输出：undefined
button.addEventListener('click', btn.handleClickArrow); // 输出：'提交按钮'
```

**解释：**
- 普通方法作为事件处理器时，this指向触发事件的DOM元素
- 箭头函数作为类属性时，this始终指向类实例

### 8. call、apply、bind的使用（8分）

```javascript
const person1 = { name: '小明' };
const person2 = { name: '小红' };

function introduce(age, city) {
    return `我叫${this.name}，今年${age}岁，来自${city}`;
}

// 使用call
console.log(introduce.call(person1, 25, '北京'));

// 使用apply
console.log(introduce.apply(person1, [25, '北京']));

// 使用bind
const boundFunc = introduce.bind(person1);
console.log(boundFunc(25, '北京'));
```

### 9. 原型链中的this（7分）

```javascript
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

const dog = new Animal('旺财');
const speak = dog.speak;

dog.speak();    // 输出：'旺财 makes a sound'
speak();        // 输出：'undefined makes a sound'（this指向全局）
speak.call(dog); // 输出：'旺财 makes a sound'
```

**解释：**
- 通过实例调用，this指向实例
- 函数单独调用，this指向全局对象
- 使用call显式绑定this到dog实例

### 10. 定时器中的this（7分）

```javascript
const timer = {
    seconds: 0,
    start: function() {
        setInterval(function() {
            this.seconds++;
            console.log(this.seconds);
        }, 1000);
    },
    startArrow: function() {
        setInterval(() => {
            this.seconds++;
            console.log(this.seconds);
        }, 1000);
    }
};

timer.start();      // 不会正常计数，输出NaN
timer.startArrow(); // 会正常计数，输出1, 2, 3...
```

**解释：**
- `start`方法：普通函数在setInterval中this指向全局对象，全局对象没有seconds属性
- `startArrow`方法：箭头函数继承外层函数的this，指向timer对象

## 四、综合应用题（15分钟，20分）

### 11. LeetCode算法题（20分）

**选项1：删除有序数组中的重复项**
```javascript
function removeDuplicates(nums) {
    if (nums.length === 0) return 0;
    
    let slow = 0;
    for (let fast = 1; fast < nums.length; fast++) {
        if (nums[fast] !== nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }
    return slow + 1;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

**选项2：移动零**
```javascript
function moveZeroes(nums) {
    let nonZeroIndex = 0;
    
    // 将所有非零元素移到前面
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            nums[nonZeroIndex] = nums[i];
            nonZeroIndex++;
        }
    }
    
    // 将剩余位置填充为0
    for (let i = nonZeroIndex; i < nums.length; i++) {
        nums[i] = 0;
    }
    
    return nums;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

**选项3：移除元素**
```javascript
function removeElement(nums, val) {
    let k = 0;
    
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== val) {
            nums[k] = nums[i];
            k++;
        }
    }
    
    return k;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

---

## 答题要求

1. **时间分配**：
   - HTML：10分钟
   - CSS：15分钟
   - JavaScript：25分钟
   - 综合题：10分钟

2. **评分标准**：
   - HTML：15分
   - CSS：25分
   - JavaScript：40分
   - 综合应用：20分
   - 总分：100分

3. **注意事项**：
   - 先做会做的题目，确保基础分
   - JavaScript部分着重考察this指向理解
   - 算法题选择一道即可，不需要全部完成
   - 注意代码格式规范

**考试时间：60分钟 | 满分：100分**