# 前端开发知识点总结

根据个人优势整理的核心技术知识点文档

---

## 1. HTML5/CSS3 及核心概念

### 1.1 语义化标签
- **HTML5语义化标签**
  - `<header>` - 页面头部
  - `<nav>` - 导航栏
  - `<main>` - 主要内容区域
  - `<article>` - 文章内容
  - `<section>` - 文档中的节
  - `<aside>` - 侧边栏
  - `<footer>` - 页脚
  - `<figure>` / `<figcaption>` - 图片和标题
  - `<time>` - 时间日期
  - `<mark>` - 标记文本
- **语义化的优势**
  - 提升SEO效果
  - 提高代码可读性
  - 便于维护和协作
  - 提升无障碍访问体验

### 1.2 盒模型
- **标准盒模型 (content-box)**
  - width/height = content 宽度/高度
  - 总宽度 = width + padding + border
- **IE盒模型 (border-box)**
  - width/height = content + padding + border
  - 总宽度 = width
- **box-sizing 属性**
  ```css
  box-sizing: content-box; /* 默认值 */
  box-sizing: border-box;  /* IE盒模型 */
  ```
- **外边距合并 (margin collapsing)**
  - 垂直方向相邻元素的外边距会合并
  - 父子元素的外边距也会合并

### 1.3 Flex 布局
- **容器属性 (flex container)**
  - `display: flex` / `display: inline-flex`
  - `flex-direction` - 主轴方向 (row, column, row-reverse, column-reverse)
  - `flex-wrap` - 换行方式 (nowrap, wrap, wrap-reverse)
  - `justify-content` - 主轴对齐 (flex-start, flex-end, center, space-between, space-around, space-evenly)
  - `align-items` - 交叉轴对齐 (stretch, flex-start, flex-end, center, baseline)
  - `align-content` - 多行对齐方式
  - `gap` - 项目间距
- **项目属性 (flex item)**
  - `flex-grow` - 放大比例
  - `flex-shrink` - 缩小比例
  - `flex-basis` - 初始主轴尺寸
  - `flex` - 简写属性 (grow shrink basis)
  - `align-self` - 单个项目对齐方式
  - `order` - 排序顺序

### 1.4 Grid 布局
- **容器属性**
  - `display: grid` / `display: inline-grid`
  - `grid-template-columns` - 列轨道大小
  - `grid-template-rows` - 行轨道大小
  - `grid-template-areas` - 命名网格区域
  - `grid-gap` / `gap` - 网格间距
  - `justify-items` - 水平对齐
  - `align-items` - 垂直对齐
  - `place-items` - 简写
  - `justify-content` - 网格容器水平对齐
  - `align-content` - 网格容器垂直对齐
- **项目属性**
  - `grid-column-start` / `grid-column-end` - 列起始/结束位置
  - `grid-row-start` / `grid-row-end` - 行起始/结束位置
  - `grid-column` / `grid-row` - 简写
  - `grid-area` - 指定网格区域
  - `justify-self` / `align-self` - 单个项目对齐

### 1.5 BFC (Block Formatting Context)
- **BFC 的触发条件**
  - 根元素 (`<html>`)
  - `float` 不为 `none`
  - `position` 为 `absolute` 或 `fixed`
  - `display` 为 `inline-block`、`table-cell`、`table-caption`、`flex`、`inline-flex`、`grid`、`inline-grid`
  - `overflow` 不为 `visible`
- **BFC 的特性**
  - 内部元素垂直排列
  - 同一个BFC内，垂直方向margin会合并
  - BFC区域不会与float元素重叠
  - BFC是独立容器，内外互不影响
  - 计算BFC高度时，浮动元素也参与计算
- **BFC 的应用场景**
  - 清除浮动
  - 防止margin合并
  - 自适应两栏布局
  - 防止元素被浮动元素覆盖

### 1.6 响应式布局
- **媒体查询 (Media Queries)**
  ```css
  @media screen and (max-width: 768px) {
    /* 移动端样式 */
  }
  @media screen and (min-width: 769px) and (max-width: 1024px) {
    /* 平板样式 */
  }
  ```
- **响应式单位**
  - `rem` - 相对于根元素字体大小
  - `em` - 相对于父元素字体大小
  - `vw` / `vh` - 视口宽度/高度的百分比
  - `vmin` / `vmax` - 视口较小/较大尺寸的百分比
- **响应式图片**
  - `<img srcset>` - 多分辨率图片
  - `<picture>` - 响应式图片元素
- **移动端适配方案**
  - viewport 设置
  - rem 适配 (flexible.js)
  - vw/vh 适配
  - 百分比布局

---

## 2. JavaScript 基础及核心机制

### 2.1 数据类型
- **基本数据类型 (Primitive Types)**
  - `Number` - 数字
  - `String` - 字符串
  - `Boolean` - 布尔值
  - `Undefined` - 未定义
  - `Null` - 空值
  - `Symbol` - 唯一标识符 (ES6)
  - `BigInt` - 大整数 (ES2020)
- **引用数据类型 (Reference Types)**
  - `Object` - 对象
  - `Array` - 数组
  - `Function` - 函数
  - `Date` - 日期
  - `RegExp` - 正则表达式
- **类型判断**
  - `typeof` - 基本类型判断
  - `instanceof` - 实例判断
  - `Object.prototype.toString.call()` - 精确类型判断
  - `Array.isArray()` - 数组判断
- **类型转换**
  - 显式转换: `Number()`, `String()`, `Boolean()`
  - 隐式转换: `==`, `+`, `-`, `*`, `/`
  - 字符串转数字: `parseInt()`, `parseFloat()`

### 2.2 闭包 (Closure)
- **闭包的定义**
  - 函数内部定义的函数
  - 内部函数可以访问外部函数的变量
  - 即使外部函数执行完毕，内部函数仍可访问外部变量
- **闭包的形成条件**
  - 函数嵌套
  - 内部函数引用外部函数的变量
  - 内部函数被外部调用
- **闭包的应用场景**
  - 数据私有化 (模块化)
  - 函数工厂
  - 防抖和节流
  - 回调函数
  - 单例模式
- **闭包的优缺点**
  - 优点: 数据私有、延长变量生命周期
  - 缺点: 内存泄漏风险、性能影响

### 2.3 this 指向
- **this 的绑定规则**
  - **默认绑定**: 全局作用域中，`this` 指向 `window` (严格模式下为 `undefined`)
  - **隐式绑定**: 对象方法调用，`this` 指向调用对象
  - **显式绑定**: `call()`, `apply()`, `bind()` 改变 `this` 指向
  - **new 绑定**: 构造函数中，`this` 指向新创建的实例
  - **箭头函数**: `this` 继承外层作用域的 `this`，无法被改变
- **this 优先级**
  - new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定
- **常见问题**
  - 回调函数中的 `this` 丢失
  - 箭头函数与普通函数的 `this` 区别

### 2.4 原型链 (Prototype Chain)
- **原型对象 (prototype)**
  - 每个函数都有一个 `prototype` 属性
  - 实例通过 `__proto__` 访问构造函数的 `prototype`
  - `Object.prototype` 是原型链的顶端
- **原型链查找机制**
  - 对象属性查找: 先在自身查找，再沿原型链向上查找
  - 直到找到或到达 `Object.prototype` (值为 `null`)
- **相关方法**
  - `Object.create()` - 创建对象并指定原型
  - `Object.getPrototypeOf()` - 获取原型对象
  - `Object.setPrototypeOf()` - 设置原型对象
  - `instanceof` - 检查对象是否是某个构造函数的实例
  - `Object.prototype.isPrototypeOf()` - 检查对象是否在原型链上
- **继承方式**
  - 原型链继承
  - 构造函数继承
  - 组合继承
  - 原型式继承
  - 寄生式继承
  - 寄生组合式继承
  - ES6 Class 继承

### 2.5 事件循环 (Event Loop)
- **JavaScript 执行机制**
  - 单线程执行
  - 同步任务在主线程执行
  - 异步任务通过事件循环处理
- **任务队列**
  - **宏任务 (MacroTask)**
    - `setTimeout` / `setInterval`
    - I/O 操作
    - UI 渲染
    - `setImmediate` (Node.js)
  - **微任务 (MicroTask)**
    - `Promise.then()` / `Promise.catch()` / `Promise.finally()`
    - `queueMicrotask()`
    - `MutationObserver`
    - `process.nextTick()` (Node.js)
- **执行顺序**
  1. 执行同步代码
  2. 执行所有微任务
  3. 执行一个宏任务
  4. 再次执行所有微任务
  5. 重复步骤 3-4
- **async/await**
  - `async` 函数返回 Promise
  - `await` 会暂停函数执行，等待 Promise 解决
  - `await` 后的代码作为微任务执行

### 2.6 事件委托 (Event Delegation)
- **事件委托原理**
  - 将事件监听器绑定到父元素
  - 利用事件冒泡机制
  - 通过 `event.target` 判断实际触发元素
- **事件委托的优势**
  - 减少事件监听器数量
  - 动态元素无需重新绑定事件
  - 性能更好，内存占用更少
- **事件流**
  - **捕获阶段**: 从 `window` 到目标元素
  - **目标阶段**: 事件到达目标元素
  - **冒泡阶段**: 从目标元素到 `window`
- **事件方法**
  - `addEventListener()` - 添加事件监听
  - `removeEventListener()` - 移除事件监听
  - `event.stopPropagation()` - 阻止事件传播
  - `event.preventDefault()` - 阻止默认行为
  - `event.stopImmediatePropagation()` - 阻止同一元素的其他监听器

---

## 3. Vue 3 核心知识

### 3.1 Composition API
- **setup() 函数**
  - 组件的入口函数
  - 在 `beforeCreate` 之前执行
  - 返回对象或渲染函数
  - 接收 `props` 和 `context` 参数
- **响应式 API**
  - `ref()` - 创建基本类型的响应式引用
  - `reactive()` - 创建对象的响应式代理
  - `readonly()` - 创建只读响应式对象
  - `computed()` - 计算属性
  - `watch()` / `watchEffect()` - 监听器
- **生命周期钩子**
  - `onBeforeMount` / `onMounted`
  - `onBeforeUpdate` / `onUpdated`
  - `onBeforeUnmount` / `onUnmounted`
  - `onActivated` / `onDeactivated` (keep-alive)
  - `onErrorCaptured` - 错误捕获
- **组合式函数 (Composables)**
  - 逻辑复用
  - 自定义 Hook
  - 状态管理

### 3.2 响应式原理
- **Proxy 代理**
  - Vue 3 使用 Proxy 替代 Object.defineProperty
  - 支持数组和对象的所有操作
  - 性能更好，功能更强
- **响应式系统**
  - **依赖收集**: 访问响应式数据时收集依赖
  - **触发更新**: 修改响应式数据时触发更新
  - **调度器**: 批量更新，优化性能
- **ref vs reactive**
  - `ref`: 基本类型，通过 `.value` 访问
  - `reactive`: 对象类型，直接访问属性
  - `ref` 可以包装对象，`reactive` 不能包装基本类型
- **响应式转换**
  - `toRef()` / `toRefs()` - 将 reactive 对象转换为 ref
  - `unref()` - 获取 ref 的值
  - `isRef()` / `isReactive()` - 类型检查

### 3.3 Diff 算法
- **虚拟 DOM**
  - 用 JavaScript 对象描述 DOM 结构
  - 减少直接操作 DOM 的性能开销
- **Diff 算法优化**
  - **静态提升**: 静态节点提升到渲染函数外
  - **补丁标志**: 标记动态节点类型
  - **Block Tree**: 只对比动态节点
  - **最长递增子序列**: 优化列表更新
- **更新策略**
  - 同层比较，不跨层移动
  - 使用 key 优化列表渲染
  - 双端比较算法
- **性能优化**
  - 减少不必要的重新渲染
  - 合理使用 `v-memo`
  - 避免在模板中使用复杂计算

### 3.4 组件通信
- **父子组件通信**
  - **Props**: 父组件向子组件传递数据
  - **Events**: 子组件向父组件发送事件 (`$emit`)
  - **v-model**: 双向绑定语法糖
  - **插槽 (Slots)**: 内容分发
- **跨级组件通信**
  - **provide / inject**: 依赖注入
  - **事件总线**: 全局事件系统
  - **状态管理**: Vuex / Pinia
- **兄弟组件通信**
  - 通过共同的父组件
  - 事件总线
  - 状态管理
- **插槽类型**
  - 默认插槽
  - 具名插槽
  - 作用域插槽

### 3.5 性能优化
- **编译时优化**
  - 静态提升
  - 预字符串化
  - 补丁标志
  - Block Tree
- **运行时优化**
  - 使用 `v-memo` 缓存组件
  - 合理使用 `v-show` vs `v-if`
  - 列表渲染使用 key
  - 避免在模板中使用复杂表达式
- **组件优化**
  - 异步组件 (`defineAsyncComponent`)
  - 组件懒加载
  - 使用 `keep-alive` 缓存组件
- **代码分割**
  - 路由懒加载
  - 组件按需加载
  - Tree-shaking

---

## 4. React 生态 (React 18, Next.js 14)

### 4.1 Hooks
- **基础 Hooks**
  - `useState` - 状态管理
  - `useEffect` - 副作用处理
  - `useContext` - 上下文使用
- **额外 Hooks**
  - `useReducer` - 复杂状态管理
  - `useCallback` - 函数缓存
  - `useMemo` - 值缓存
  - `useRef` - 引用对象
  - `useImperativeHandle` - 暴露实例方法
  - `useLayoutEffect` - 同步副作用
  - `useDebugValue` - 调试标签
- **自定义 Hooks**
  - 逻辑复用
  - 命名以 `use` 开头
  - 可以调用其他 Hooks
- **Hooks 规则**
  - 只在顶层调用
  - 只在 React 函数中调用
  - 条件调用会导致问题

### 4.2 Server Components
- **React Server Components (RSC)**
  - 在服务器端渲染的组件
  - 减少客户端 JavaScript 体积
  - 直接访问服务器资源
- **特点**
  - 默认异步
  - 不能使用浏览器 API
  - 不能使用状态和副作用
  - 可以访问服务器资源
- **使用场景**
  - 数据获取
  - 访问后端服务
  - 减少客户端代码
- **与 Client Components 的区别**
  - Server Components: 服务器渲染，无交互
  - Client Components: 客户端渲染，有交互 (`'use client'`)

### 4.3 App Router
- **Next.js 14 App Router**
  - 基于文件系统的路由
  - 使用 `app` 目录
  - 支持嵌套路由和布局
- **路由结构**
  - `page.js` - 页面组件
  - `layout.js` - 布局组件
  - `loading.js` - 加载状态
  - `error.js` - 错误处理
  - `not-found.js` - 404 页面
  - `route.js` - API 路由
- **特殊文件**
  - `layout.tsx` - 共享布局
  - `template.tsx` - 模板 (每次导航重新挂载)
  - `loading.tsx` - 加载 UI
  - `error.tsx` - 错误边界
  - `global-error.tsx` - 全局错误处理
- **路由组和并行路由**
  - 路由组 `(folder)` - 组织路由，不影响 URL
  - 并行路由 `@folder` - 同时渲染多个页面

### 4.4 SSR/SSG 渲染模式
- **服务端渲染 (SSR)**
  - `getServerSideProps` - 每次请求时获取数据
  - 动态内容，SEO 友好
  - 服务器压力较大
- **静态站点生成 (SSG)**
  - `getStaticProps` - 构建时获取数据
  - `getStaticPaths` - 动态路由的静态路径
  - 性能最好，适合静态内容
- **增量静态再生 (ISR)**
  - 结合 SSG 和 SSR 的优势
  - 按需重新生成页面
  - `revalidate` 选项
- **Next.js 14 数据获取**
  - Server Components 中直接 `async/await`
  - `fetch` 自动缓存和去重
  - 支持 `cache: 'no-store'` 禁用缓存

### 4.5 性能优化
- **代码分割**
  - 自动代码分割
  - 动态导入 (`dynamic import`)
  - 路由级别的代码分割
- **图片优化**
  - `next/image` 组件
  - 自动优化和懒加载
  - 响应式图片
- **字体优化**
  - `next/font` 自动优化字体
  - 减少布局偏移
- **缓存策略**
  - 数据缓存
  - 全路由缓存
  - 请求记忆
- **React 18 特性**
  - **并发渲染**: 可中断的渲染
  - **Suspense**: 异步组件加载
  - **Transitions**: 标记非紧急更新
  - **Automatic Batching**: 自动批处理

---

## 5. 微信小程序/Uni-app 跨平台开发

### 5.1 小程序生命周期
- **应用生命周期 (App)**
  - `onLaunch` - 小程序初始化
  - `onShow` - 小程序显示
  - `onHide` - 小程序隐藏
  - `onError` - 错误监听
  - `onPageNotFound` - 页面不存在
  - `onUnhandledRejection` - 未处理的 Promise 拒绝
- **页面生命周期 (Page)**
  - `onLoad` - 页面加载
  - `onShow` - 页面显示
  - `onReady` - 页面初次渲染完成
  - `onHide` - 页面隐藏
  - `onUnload` - 页面卸载
  - `onPullDownRefresh` - 下拉刷新
  - `onReachBottom` - 上拉触底
  - `onShareAppMessage` - 分享
  - `onPageScroll` - 页面滚动
- **组件生命周期 (Component)**
  - `created` - 组件实例创建
  - `attached` - 组件进入页面节点树
  - `ready` - 组件渲染完成
  - `moved` - 组件实例被移动到节点树另一个位置
  - `detached` - 组件离开页面节点树
  - `error` - 组件错误

### 5.2 组件化
- **自定义组件**
  - 组件结构: `.js`, `.wxml`, `.wxss`, `.json`
  - 组件注册: `Component()` 构造器
  - 组件通信: properties, data, methods
- **组件通信方式**
  - **父传子**: properties
  - **子传父**: triggerEvent
  - **兄弟组件**: 事件总线或父组件中转
  - **跨级组件**: 事件通道 (getOpenerEventChannel)
- **组件样式隔离**
  - `styleIsolation` 选项
  - `isolated` - 完全隔离
  - `apply-shared` - 页面样式可影响组件
  - `shared` - 页面和组件样式互相影响
- **behaviors**
  - 组件间代码复用
  - 类似 mixins

### 5.3 状态管理
- **本地状态管理**
  - `data` - 组件内部状态
  - `setData` - 更新状态 (同步更新，异步渲染)
- **全局状态管理**
  - **getApp()** - 获取应用实例
  - **全局数据**: `app.globalData`
  - **第三方库**: MobX, Redux, Vuex (uni-app)
- **状态管理最佳实践**
  - 合理使用 `setData`，避免频繁调用
  - 使用 `setData` 的路径更新
  - 避免在 `setData` 中设置过大数据
  - 使用状态管理库处理复杂状态

### 5.4 多端适配方案
- **条件编译**
  ```javascript
  // #ifdef MP-WEIXIN
  // 微信小程序代码
  // #endif
  
  // #ifdef H5
  // H5 代码
  // #endif
  
  // #ifdef APP-PLUS
  // App 代码
  // #endif
  ```
- **平台差异处理**
  - API 差异: 使用条件编译或封装统一接口
  - 样式差异: 使用 rpx / upx 单位
  - 组件差异: 使用条件编译或封装组件
- **Uni-app 跨平台**
  - 一套代码，多端运行
  - 支持 H5、小程序、App
  - 使用 Vue 语法
  - 丰富的 API 和组件库
- **适配方案**
  - **rpx / upx**: 响应式单位
  - **uni.getSystemInfo()**: 获取系统信息
  - **媒体查询**: 不同屏幕适配
  - **flex 布局**: 弹性布局适配

---

## 6. HTTP 协议及浏览器机制

### 6.1 浏览器缓存机制
- **强缓存**
  - **Expires**: HTTP/1.0，绝对时间
  - **Cache-Control**: HTTP/1.1，相对时间
    - `max-age`: 最大缓存时间
    - `no-cache`: 需要验证
    - `no-store`: 不缓存
    - `private`: 私有缓存
    - `public`: 公共缓存
- **协商缓存**
  - **Last-Modified / If-Modified-Since**: 基于修改时间
  - **ETag / If-None-Match**: 基于内容哈希
  - 304 Not Modified 响应
- **缓存策略**
  - HTML: 不缓存或短时间缓存
  - CSS/JS: 长时间缓存，使用版本号
  - 图片: 长时间缓存
  - API: 根据数据特性决定

### 6.2 跨域解决方案
- **同源策略**
  - 协议、域名、端口相同
  - 限制: Cookie、LocalStorage、DOM、AJAX
- **CORS (跨域资源共享)**
  - 服务器设置响应头
  - `Access-Control-Allow-Origin`
  - `Access-Control-Allow-Methods`
  - `Access-Control-Allow-Headers`
  - 预检请求 (OPTIONS)
- **JSONP**
  - 利用 `<script>` 标签不受同源限制
  - 只能 GET 请求
  - 需要服务器支持
- **代理**
  - 开发环境: webpack devServer proxy
  - 生产环境: Nginx 反向代理
- **其他方案**
  - `document.domain` (子域名)
  - `postMessage` (iframe 通信)
  - WebSocket

### 6.3 性能优化策略

#### 6.3.1 防抖 (Debounce)
- **原理**: 在事件触发后等待一段时间，如果期间再次触发则重新计时
- **应用场景**
  - 搜索框输入
  - 窗口 resize
  - 滚动事件
- **实现**
  ```javascript
  function debounce(func, delay) {
    let timer;
    return function(...args) {
      clearTimeout(timer);
      timer = setTimeout(() => func.apply(this, args), delay);
    };
  }
  ```

#### 6.3.2 节流 (Throttle)
- **原理**: 在指定时间间隔内只执行一次
- **应用场景**
  - 滚动加载
  - 鼠标移动
  - 按钮点击
- **实现**
  ```javascript
  function throttle(func, delay) {
    let lastTime = 0;
    return function(...args) {
      const now = Date.now();
      if (now - lastTime >= delay) {
        func.apply(this, args);
        lastTime = now;
      }
    };
  }
  ```

#### 6.3.3 懒加载 (Lazy Loading)
- **图片懒加载**
  - `IntersectionObserver` API
  - 滚动监听 + 计算位置
  - `loading="lazy"` 属性
- **路由懒加载**
  - 动态导入组件
  - 按需加载代码
- **数据懒加载**
  - 虚拟滚动
  - 分页加载
  - 无限滚动

#### 6.3.4 回流/重绘优化
- **回流 (Reflow)**
  - 布局改变触发
  - 影响性能较大
  - 触发条件:
    - 修改 DOM 结构
    - 修改样式 (width, height, margin, padding, border)
    - 修改内容
    - 窗口 resize
- **重绘 (Repaint)**
  - 外观改变触发
  - 性能影响较小
  - 触发条件:
    - 修改颜色
    - 修改背景
    - 修改 visibility
- **优化策略**
  - 使用 `transform` 和 `opacity` (触发合成层)
  - 批量修改 DOM (DocumentFragment)
  - 使用 `will-change` 提示浏览器
  - 避免频繁读取布局属性 (offsetWidth, scrollTop)
  - 使用 `requestAnimationFrame` 优化动画
  - 使用虚拟 DOM 减少直接操作

---

## 7. AI 辅助开发工具

### 7.1 Cursor
- **核心功能**
  - AI 代码补全
  - 代码生成
  - 代码重构
  - 错误修复
  - 代码解释
- **使用技巧**
  - 清晰的注释和上下文
  - 使用 `@` 符号引用文件
  - 利用聊天功能进行代码审查
  - 使用快捷键提高效率
- **最佳实践**
  - 提供清晰的上下文
  - 分步骤实现复杂功能
  - 审查 AI 生成的代码
  - 结合自己的专业知识判断

### 7.2 GitHub Copilot
- **核心功能**
  - 代码自动补全
  - 函数实现建议
  - 注释生成代码
  - 多语言支持
- **使用场景**
  - 快速生成样板代码
  - 实现常见算法
  - 编写测试代码
  - 代码重构
- **注意事项**
  - 审查生成的代码
  - 注意代码质量和安全性
  - 理解代码逻辑
  - 遵守代码规范

### 7.3 利用 AI 提升编码效率
- **代码生成**
  - 快速创建组件
  - 生成 API 调用代码
  - 创建测试用例
- **代码审查**
  - 检查潜在 bug
  - 优化性能
  - 改进代码结构
  - 检查安全性问题
- **问题排查**
  - 解释错误信息
  - 提供解决方案
  - 调试建议
  - 性能分析
- **学习辅助**
  - 解释复杂概念
  - 提供最佳实践
  - 代码示例
  - 技术文档

### 7.4 AI 工具使用原则
- **保持批判性思维**
  - 不盲目接受 AI 建议
  - 理解代码逻辑
  - 验证代码正确性
- **结合专业知识**
  - 利用 AI 提高效率
  - 但保持技术判断力
  - 遵循最佳实践
- **持续学习**
  - AI 是工具，不是替代
  - 理解底层原理
  - 保持技术更新

---

## 总结

本文档涵盖了前端开发的核心知识点，包括:

1. **HTML5/CSS3**: 语义化、盒模型、布局、BFC、响应式
2. **JavaScript**: 数据类型、闭包、this、原型链、事件循环、事件委托
3. **Vue 3**: Composition API、响应式原理、Diff 算法、组件通信、性能优化
4. **React 生态**: Hooks、Server Components、App Router、SSR/SSG、性能优化
5. **小程序/跨平台**: 生命周期、组件化、状态管理、多端适配
6. **浏览器机制**: 缓存、跨域、性能优化 (防抖/节流、懒加载、回流/重绘)
7. **AI 工具**: Cursor、GitHub Copilot 的使用和最佳实践

这些知识点构成了现代前端开发的核心技能栈，需要不断学习和实践来掌握和深化。

---

*最后更新: 2024年*
