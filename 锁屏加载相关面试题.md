# 锁屏加载相关面试题汇总

## 一、概念理解（10分）

### 1. 什么是锁屏加载？为什么需要锁屏加载？（5分）

**答案：**

**锁屏加载的定义：**
锁屏加载是指在数据加载或异步操作进行时，通过UI界面阻止用户进行其他操作的一种用户体验设计模式。通常表现为显示loading遮罩层、禁用按钮、显示加载动画等。

**为什么需要锁屏加载：**
1. **防止重复操作**：避免用户重复点击提交按钮导致重复请求
2. **数据一致性**：确保异步操作完成前不会有其他操作干扰
3. **用户体验**：给用户明确的反馈，告知系统正在处理
4. **系统稳定性**：防止并发操作导致的系统异常
5. **业务逻辑保护**：确保关键业务流程的完整性

### 2. 锁屏加载的常见实现方式有哪些？（5分）

**答案：**

1. **遮罩层（Overlay/Mask）**：在页面上覆盖半透明遮罩
2. **按钮禁用（Button Disabled）**：禁用操作按钮，防止重复点击
3. **全屏Loading**：显示全屏加载动画
4. **局部Loading**：在特定区域显示加载状态
5. **进度条**：显示操作进度
6. **骨架屏**：显示内容结构的占位符

## 二、技术实现（30分）

### 3. 手写实现一个防抖函数，用于防止重复提交（8分）

**答案：**
```javascript
function debounce(fn, delay) {
    let timer = null;
    
    return function(...args) {
        // 清除之前的定时器
        if (timer) {
            clearTimeout(timer);
        }
        
        // 设置新的定时器
        timer = setTimeout(() => {
            fn.apply(this, args);
            timer = null;
        }, delay);
    };
}

// 使用示例：防止重复提交
const handleSubmit = debounce(function(formData) {
    // 提交逻辑
    submitForm(formData);
}, 1000);

// 绑定到提交按钮
document.getElementById('submitBtn').addEventListener('click', handleSubmit);
```

### 4. 实现一个Loading组件的状态管理（10分）

**答案：**

**Vue实现：**
```javascript
// LoadingMixin.js
export const LoadingMixin = {
    data() {
        return {
            loading: false,
            loadingText: '加载中...'
        };
    },
    methods: {
        async withLoading(asyncFn, loadingText = '处理中...') {
            this.loading = true;
            this.loadingText = loadingText;
            
            try {
                const result = await asyncFn();
                return result;
            } catch (error) {
                console.error('操作失败:', error);
                throw error;
            } finally {
                this.loading = false;
            }
        }
    }
};

// 使用示例
export default {
    mixins: [LoadingMixin],
    methods: {
        async submitForm() {
            await this.withLoading(async () => {
                const response = await this.$http.post('/api/submit', this.formData);
                this.$message.success('提交成功');
                return response;
            }, '提交中...');
        }
    }
};
```

**React实现：**
```javascript
// useLoading Hook
import { useState, useCallback } from 'react';

export const useLoading = (initialState = false) => {
    const [loading, setLoading] = useState(initialState);
    const [loadingText, setLoadingText] = useState('加载中...');
    
    const withLoading = useCallback(async (asyncFn, text = '处理中...') => {
        setLoading(true);
        setLoadingText(text);
        
        try {
            const result = await asyncFn();
            return result;
        } catch (error) {
            console.error('操作失败:', error);
            throw error;
        } finally {
            setLoading(false);
        }
    }, []);
    
    return { loading, loadingText, withLoading };
};

// 使用示例
function SubmitForm() {
    const { loading, loadingText, withLoading } = useLoading();
    
    const handleSubmit = async () => {
        await withLoading(async () => {
            const response = await fetch('/api/submit', {
                method: 'POST',
                body: JSON.stringify(formData)
            });
            return response.json();
        }, '提交中...');
    };
    
    return (
        <div>
            <button 
                onClick={handleSubmit} 
                disabled={loading}
            >
                {loading ? loadingText : '提交'}
            </button>
            {loading && <div className="loading-overlay">加载中...</div>}
        </div>
    );
}
```

### 5. 实现一个通用的Loading遮罩组件（12分）

**答案：**

**HTML/CSS实现：**
```html
<!-- Loading组件 -->
<div id="loadingMask" class="loading-mask" style="display: none;">
    <div class="loading-content">
        <div class="spinner"></div>
        <p class="loading-text">加载中...</p>
    </div>
</div>
```

```css
.loading-mask {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.loading-content {
    background: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 10px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loading-text {
    margin: 0;
    color: #666;
    font-size: 14px;
}
```

**JavaScript控制：**
```javascript
class LoadingManager {
    constructor() {
        this.loadingCount = 0;
        this.loadingMask = document.getElementById('loadingMask');
        this.loadingText = this.loadingMask.querySelector('.loading-text');
    }
    
    show(text = '加载中...') {
        this.loadingCount++;
        this.loadingText.textContent = text;
        this.loadingMask.style.display = 'flex';
        
        // 防止页面滚动
        document.body.style.overflow = 'hidden';
    }
    
    hide() {
        this.loadingCount = Math.max(0, this.loadingCount - 1);
        
        if (this.loadingCount === 0) {
            this.loadingMask.style.display = 'none';
            document.body.style.overflow = '';
        }
    }
    
    async withLoading(asyncFn, text = '处理中...') {
        this.show(text);
        try {
            const result = await asyncFn();
            return result;
        } finally {
            this.hide();
        }
    }
}

// 全局实例
const loading = new LoadingManager();

// 使用示例
async function submitForm() {
    await loading.withLoading(async () => {
        const response = await fetch('/api/submit', {
            method: 'POST',
            body: JSON.stringify(formData)
        });
        return response.json();
    }, '提交中...');
}
```

## 三、进阶应用（25分）

### 6. 如何实现防止重复提交的多种方案？（10分）

**答案：**

**方案1：按钮禁用 + Loading状态**
```javascript
class SubmitController {
    constructor(buttonId) {
        this.button = document.getElementById(buttonId);
        this.isSubmitting = false;
        this.originalText = this.button.textContent;
    }
    
    async submit(submitFn) {
        if (this.isSubmitting) return;
        
        this.isSubmitting = true;
        this.button.disabled = true;
        this.button.textContent = '提交中...';
        
        try {
            await submitFn();
        } finally {
            this.isSubmitting = false;
            this.button.disabled = false;
            this.button.textContent = this.originalText;
        }
    }
}
```

**方案2：请求去重（基于请求内容）**
```javascript
class RequestDeduplicator {
    constructor() {
        this.pendingRequests = new Map();
    }
    
    async request(url, options = {}) {
        const key = this.generateKey(url, options);
        
        // 如果已有相同请求在进行中，返回该请求的Promise
        if (this.pendingRequests.has(key)) {
            return this.pendingRequests.get(key);
        }
        
        // 创建新请求
        const promise = this.makeRequest(url, options)
            .finally(() => {
                this.pendingRequests.delete(key);
            });
        
        this.pendingRequests.set(key, promise);
        return promise;
    }
    
    generateKey(url, options) {
        return `${url}_${JSON.stringify(options)}`;
    }
    
    async makeRequest(url, options) {
        const response = await fetch(url, options);
        return response.json();
    }
}
```

**方案3：时间间隔控制（节流）**
```javascript
function throttle(fn, delay) {
    let lastTime = 0;
    
    return function(...args) {
        const nowTime = Date.now();
        
        if (nowTime - lastTime >= delay) {
            fn.apply(this, args);
            lastTime = nowTime;
        }
    };
}

// 使用节流防止频繁提交
const throttledSubmit = throttle(submitForm, 2000);
```

### 7. 实现一个支持取消的异步Loading（8分）

**答案：**
```javascript
class CancellableLoading {
    constructor() {
        this.currentController = null;
        this.loading = false;
    }
    
    async execute(asyncFn, options = {}) {
        // 取消之前的请求
        this.cancel();
        
        // 创建新的AbortController
        this.currentController = new AbortController();
        this.loading = true;
        
        try {
            const result = await asyncFn(this.currentController.signal);
            return result;
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('请求已取消');
                return null;
            }
            throw error;
        } finally {
            this.loading = false;
            this.currentController = null;
        }
    }
    
    cancel() {
        if (this.currentController) {
            this.currentController.abort();
            this.currentController = null;
        }
    }
    
    isLoading() {
        return this.loading;
    }
}

// 使用示例
const loadingManager = new CancellableLoading();

async function searchData(keyword) {
    return loadingManager.execute(async (signal) => {
        const response = await fetch(`/api/search?q=${keyword}`, {
            signal // 传递abort信号
        });
        
        if (!response.ok) {
            throw new Error('搜索失败');
        }
        
        return response.json();
    });
}

// 搜索输入框的处理
const searchInput = document.getElementById('searchInput');
searchInput.addEventListener('input', debounce(async (e) => {
    const keyword = e.target.value.trim();
    if (keyword) {
        const results = await searchData(keyword);
        if (results) {
            displayResults(results);
        }
    }
}, 500));
```

### 8. 如何处理多个并发Loading状态？（7分）

**答案：**
```javascript
class MultiLoadingManager {
    constructor() {
        this.loadingStates = new Map();
        this.globalLoading = false;
    }
    
    startLoading(key, text = '加载中...') {
        this.loadingStates.set(key, { text, startTime: Date.now() });
        this.updateGlobalState();
    }
    
    stopLoading(key) {
        this.loadingStates.delete(key);
        this.updateGlobalState();
    }
    
    updateGlobalState() {
        const wasLoading = this.globalLoading;
        this.globalLoading = this.loadingStates.size > 0;
        
        if (this.globalLoading !== wasLoading) {
            this.onLoadingStateChange(this.globalLoading);
        }
        
        // 更新显示文本（显示最新的loading文本）
        if (this.globalLoading) {
            const latestLoading = Array.from(this.loadingStates.entries())
                .sort(([,a], [,b]) => b.startTime - a.startTime)[0];
            this.onTextChange(latestLoading[1].text);
        }
    }
    
    onLoadingStateChange(isLoading) {
        const mask = document.getElementById('loadingMask');
        mask.style.display = isLoading ? 'flex' : 'none';
        document.body.style.overflow = isLoading ? 'hidden' : '';
    }
    
    onTextChange(text) {
        const textElement = document.querySelector('.loading-text');
        if (textElement) {
            textElement.textContent = text;
        }
    }
    
    async withLoading(key, asyncFn, text = '处理中...') {
        this.startLoading(key, text);
        try {
            return await asyncFn();
        } finally {
            this.stopLoading(key);
        }
    }
    
    isLoading(key = null) {
        if (key) {
            return this.loadingStates.has(key);
        }
        return this.globalLoading;
    }
    
    getLoadingCount() {
        return this.loadingStates.size;
    }
}

// 使用示例
const multiLoading = new MultiLoadingManager();

// 同时进行多个异步操作
async function handleMultipleOperations() {
    const promises = [
        multiLoading.withLoading('user', fetchUserData, '获取用户信息...'),
        multiLoading.withLoading('orders', fetchOrders, '获取订单数据...'),
        multiLoading.withLoading('products', fetchProducts, '获取商品列表...')
    ];
    
    try {
        const results = await Promise.all(promises);
        console.log('所有数据加载完成:', results);
    } catch (error) {
        console.error('数据加载失败:', error);
    }
}
```

## 四、性能优化与最佳实践（20分）

### 9. Loading状态的性能优化策略（10分）

**答案：**

**1. 避免频繁的DOM操作**
```javascript
class OptimizedLoading {
    constructor() {
        this.loadingElement = null;
        this.isVisible = false;
        this.pendingShow = false;
        this.showTimer = null;
    }
    
    // 延迟显示，避免闪烁
    show(delay = 200) {
        this.pendingShow = true;
        
        this.showTimer = setTimeout(() => {
            if (this.pendingShow && !this.isVisible) {
                this.doShow();
            }
        }, delay);
    }
    
    hide() {
        this.pendingShow = false;
        
        if (this.showTimer) {
            clearTimeout(this.showTimer);
            this.showTimer = null;
        }
        
        if (this.isVisible) {
            this.doHide();
        }
    }
    
    doShow() {
        if (!this.loadingElement) {
            this.loadingElement = this.createElement();
        }
        
        document.body.appendChild(this.loadingElement);
        this.isVisible = true;
        
        // 使用requestAnimationFrame优化动画
        requestAnimationFrame(() => {
            this.loadingElement.classList.add('show');
        });
    }
    
    doHide() {
        if (this.loadingElement) {
            this.loadingElement.classList.remove('show');
            
            // 动画结束后移除元素
            setTimeout(() => {
                if (this.loadingElement && this.loadingElement.parentNode) {
                    this.loadingElement.parentNode.removeChild(this.loadingElement);
                }
                this.isVisible = false;
            }, 300);
        }
    }
    
    createElement() {
        const element = document.createElement('div');
        element.className = 'loading-mask';
        element.innerHTML = `
            <div class="loading-content">
                <div class="spinner"></div>
                <p>加载中...</p>
            </div>
        `;
        return element;
    }
}
```

**2. 使用CSS3动画替代JavaScript动画**
```css
.loading-mask {
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
}

.loading-mask.show {
    opacity: 1;
    pointer-events: auto;
}

.spinner {
    animation: spin 1s linear infinite;
    /* 使用will-change提示浏览器优化 */
    will-change: transform;
}
```

**3. 内存管理和清理**
```javascript
class LoadingManager {
    constructor() {
        this.instances = new WeakMap();
        this.observers = new Set();
    }
    
    // 添加观察者模式，便于统一管理
    addObserver(observer) {
        this.observers.add(observer);
    }
    
    removeObserver(observer) {
        this.observers.delete(observer);
    }
    
    notifyObservers(state) {
        this.observers.forEach(observer => {
            if (typeof observer.onLoadingStateChange === 'function') {
                observer.onLoadingStateChange(state);
            }
        });
    }
    
    destroy() {
        // 清理定时器
        if (this.showTimer) {
            clearTimeout(this.showTimer);
        }
        
        // 清理DOM
        if (this.loadingElement && this.loadingElement.parentNode) {
            this.loadingElement.parentNode.removeChild(this.loadingElement);
        }
        
        // 清理观察者
        this.observers.clear();
    }
}
```

### 10. 用户体验优化的最佳实践（10分）

**答案：**

**1. 智能Loading时机控制**
```javascript
class SmartLoading {
    constructor(options = {}) {
        this.options = {
            minShowTime: 500,    // 最小显示时间，避免闪烁
            delayTime: 200,      // 延迟显示时间
            ...options
        };
        this.startTime = null;
        this.isShowing = false;
    }
    
    async show() {
        this.startTime = Date.now();
        
        // 延迟显示，避免短时间请求的闪烁
        setTimeout(() => {
            if (this.startTime) {  // 确保还在loading状态
                this.doShow();
            }
        }, this.options.delayTime);
    }
    
    async hide() {
        if (!this.startTime) return;
        
        const elapsed = Date.now() - this.startTime;
        const remainingTime = Math.max(0, this.options.minShowTime - elapsed);
        
        // 确保最小显示时间，避免一闪而过
        setTimeout(() => {
            this.doHide();
            this.startTime = null;
        }, remainingTime);
    }
    
    doShow() {
        // 实际显示逻辑
        this.isShowing = true;
    }
    
    doHide() {
        // 实际隐藏逻辑
        this.isShowing = false;
    }
}
```

**2. 进度反馈和错误处理**
```javascript
class ProgressLoading {
    constructor() {
        this.progress = 0;
        this.status = 'idle'; // idle, loading, success, error
    }
    
    async executeWithProgress(asyncFn, onProgress) {
        this.status = 'loading';
        this.progress = 0;
        
        try {
            const result = await asyncFn((progress) => {
                this.progress = progress;
                if (onProgress) onProgress(progress);
                this.updateUI();
            });
            
            this.status = 'success';
            this.progress = 100;
            return result;
        } catch (error) {
            this.status = 'error';
            throw error;
        } finally {
            this.updateUI();
        }
    }
    
    updateUI() {
        const progressBar = document.querySelector('.progress-bar');
        const statusText = document.querySelector('.status-text');
        
        if (progressBar) {
            progressBar.style.width = `${this.progress}%`;
        }
        
        if (statusText) {
            const messages = {
                loading: `加载中... ${this.progress}%`,
                success: '加载完成',
                error: '加载失败',
                idle: '准备就绪'
            };
            statusText.textContent = messages[this.status];
        }
    }
}
```

**3. 响应式和可访问性**
```javascript
class AccessibleLoading {
    constructor() {
        this.loadingElement = null;
    }
    
    show(text = '加载中...') {
        if (!this.loadingElement) {
            this.loadingElement = this.createAccessibleElement(text);
        }
        
        // 设置ARIA属性
        this.loadingElement.setAttribute('aria-label', text);
        this.loadingElement.setAttribute('role', 'status');
        this.loadingElement.setAttribute('aria-live', 'polite');
        
        document.body.appendChild(this.loadingElement);
        
        // 焦点管理
        this.loadingElement.focus();
    }
    
    hide() {
        if (this.loadingElement) {
            // 恢复之前的焦点
            const previousFocus = document.querySelector('[data-previous-focus]');
            if (previousFocus) {
                previousFocus.focus();
                previousFocus.removeAttribute('data-previous-focus');
            }
            
            this.loadingElement.remove();
        }
    }
    
    createAccessibleElement(text) {
        const element = document.createElement('div');
        element.className = 'loading-mask';
        element.tabIndex = -1;
        element.innerHTML = `
            <div class="loading-content">
                <div class="spinner" aria-hidden="true"></div>
                <p class="loading-text">${text}</p>
                <button type="button" class="sr-only" onclick="this.parentElement.parentElement.remove()">
                    取消加载
                </button>
            </div>
        `;
        
        // 保存当前焦点
        const activeElement = document.activeElement;
        if (activeElement) {
            activeElement.setAttribute('data-previous-focus', 'true');
        }
        
        return element;
    }
}
```

## 五、总结与扩展（15分）

### 11. 锁屏加载的常见问题和解决方案（8分）

**答案：**

**常见问题：**

1. **Loading闪烁问题**
   - 原因：短时间请求导致Loading快速显示隐藏
   - 解决：设置最小显示时间和延迟显示

2. **重复请求问题**
   - 原因：用户快速多次点击
   - 解决：防抖、节流、按钮禁用、请求去重

3. **内存泄漏问题**
   - 原因：定时器未清理、事件监听器未移除
   - 解决：组件销毁时清理资源

4. **用户体验问题**
   - 原因：长时间无反馈、无法取消操作
   - 解决：进度提示、取消功能、超时处理

**解决方案总结：**
```javascript
// 综合解决方案
class RobustLoading {
    constructor(options = {}) {
        this.options = {
            minShowTime: 500,
            delayTime: 200,
            timeout: 30000,
            ...options
        };
        
        this.cleanup = new Set();
        this.abortController = null;
    }
    
    async execute(asyncFn, options = {}) {
        const mergedOptions = { ...this.options, ...options };
        
        // 创建取消控制器
        this.abortController = new AbortController();
        
        // 设置超时
        const timeoutId = setTimeout(() => {
            this.abortController.abort();
        }, mergedOptions.timeout);
        
        this.cleanup.add(() => clearTimeout(timeoutId));
        
        try {
            const result = await asyncFn(this.abortController.signal);
            return result;
        } finally {
            this.destroy();
        }
    }
    
    destroy() {
        // 执行所有清理函数
        this.cleanup.forEach(cleanupFn => cleanupFn());
        this.cleanup.clear();
        
        if (this.abortController) {
            this.abortController.abort();
            this.abortController = null;
        }
    }
}
```

### 12. 现代前端框架中的Loading最佳实践（7分）

**答案：**

**React最佳实践：**
```javascript
// 1. 使用Suspense和Error Boundary
function App() {
    return (
        <ErrorBoundary>
            <Suspense fallback={<Loading />}>
                <LazyComponent />
            </Suspense>
        </ErrorBoundary>
    );
}

// 2. 自定义Hook封装
function useAsyncOperation() {
    const [state, setState] = useState({
        loading: false,
        data: null,
        error: null
    });
    
    const execute = useCallback(async (asyncFn) => {
        setState(prev => ({ ...prev, loading: true, error: null }));
        
        try {
            const data = await asyncFn();
            setState({ loading: false, data, error: null });
            return data;
        } catch (error) {
            setState({ loading: false, data: null, error });
            throw error;
        }
    }, []);
    
    return { ...state, execute };
}
```

**Vue最佳实践：**
```javascript
// 1. 使用Composition API
export function useLoading() {
    const loading = ref(false);
    const error = ref(null);
    
    const withLoading = async (asyncFn) => {
        loading.value = true;
        error.value = null;
        
        try {
            return await asyncFn();
        } catch (err) {
            error.value = err;
            throw err;
        } finally {
            loading.value = false;
        }
    };
    
    return { loading, error, withLoading };
}

// 2. 全局Loading插件
const LoadingPlugin = {
    install(app) {
        const loading = reactive({
            count: 0,
            show: false
        });
        
        app.config.globalProperties.$loading = {
            show() {
                loading.count++;
                loading.show = true;
            },
            hide() {
                loading.count = Math.max(0, loading.count - 1);
                loading.show = loading.count > 0;
            }
        };
        
        app.provide('loading', loading);
    }
};
```

---

**总分：100分**

**评分标准：**
- 概念理解：能准确说明锁屏加载的定义和必要性
- 技术实现：能手写相关代码，逻辑正确，考虑边界情况
- 进阶应用：能处理复杂场景，如并发、取消、错误处理
- 性能优化：了解性能优化策略和最佳实践
- 实际应用：能结合现代框架给出实用解决方案

**面试重点：**
1. 防抖节流的实现和应用场景
2. Loading状态的管理和优化
3. 用户体验和可访问性考虑
4. 现代框架中的最佳实践
5. 性能优化和内存管理

