# 前端面试题 - 答题版（60分钟，100分）

## 一、HTML部分（10分钟，15分）

### 1. HTML语义化与SEO优化（5分）
1. 以下HTML结构存在哪些语义化问题？请指出并说明如何改进（3分）
```html
<div>
  <b>重要公告：系统维护通知</b>
  <br><br>
  <span onclick="showDetails()">点击查看详情</span>
  <div>
    <img src="banner.jpg">
    <div>最新产品发布</div>
  </div>
  <table>
    <tr>
      <td>姓名</td>
      <td>年龄</td>
      <td>职位</td>
    </tr>
    <tr>
      <td>张三</td>
      <td>28</td>
      <td>前端工程师</td>
    </tr>
  </table>
</div>
```

**答案：**
语义化问题及改进：
- 标题使用`<b>`标签：应改为`<h1>`或`<h2>`等标题标签
- 交互元素使用`<span>`：应改为`<button>`或`<a>`标签
- 图片缺少alt属性：添加`alt`属性描述图片内容
- 表格缺少表头标签：第一行应使用`<thead>`和`<th>`标签
- 整体结构缺少语义化容器：使用`<article>`、`<section>`等

改进后的代码：
```html
<article>
  <h2>重要公告：系统维护通知</h2>
  <button onclick="showDetails()">点击查看详情</button>
  <section>
    <img src="banner.jpg" alt="最新产品发布横幅">
    <h3>最新产品发布</h3>
  </section>
  <table>
    <thead>
      <tr>
        <th>姓名</th>
        <th>年龄</th>
        <th>职位</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>张三</td>
        <td>28</td>
        <td>前端工程师</td>
      </tr>
    </tbody>
  </table>
</article>
```

2. 块级元素和内联元素的区别是什么？（2分）

**答案：**
- **块级元素**：
  - 独占一行，从新行开始
  - 可设置宽高、内外边距
  - 默认宽度为父容器的100%
  - 常见：`div`、`p`、`h1-h6`、`ul`、`ol`、`table`

- **内联元素**：
  - 不独占一行，与其他元素在同一行
  - 宽高由内容决定，设置width/height无效
  - 垂直方向padding/margin无效
  - 常见：`span`、`a`、`img`、`strong`、`em`、`input`

### 2. HTML5特性与存储（6分）
1. localStorage、sessionStorage和Cookie的区别是什么？请从存储大小、生命周期、作用域等方面对比（3分）

**答案：**

| 特性 | localStorage | sessionStorage | Cookie |
|------|-------------|----------------|--------|
| 存储大小 | 5-10MB | 5-10MB | 4KB |
| 生命周期 | 永久存储，除非手动删除 | 会话结束时清除 | 可设置过期时间 |
| 作用域 | 同源（协议+域名+端口） | 同源且同一窗口/标签页 | 同源，可设置domain和path |
| 与服务器通信 | 仅在客户端 | 仅在客户端 | 每次请求都会携带 |
| API易用性 | 简单易用 | 简单易用 | 需要自己封装方法 |

2. HTML5新增了哪些表单输入类型和表单属性？请列举至少5个并说明用途（3分）

**答案：**
**新增输入类型：**
- `email`：邮箱输入，自动验证邮箱格式
- `url`：URL地址输入，自动验证URL格式
- `number`：数字输入，可设置min/max/step
- `date`：日期选择器
- `time`：时间选择器
- `search`：搜索框，部分浏览器有清除按钮
- `color`：颜色选择器
- `range`：滑块范围选择

**新增表单属性：**
- `placeholder`：输入提示文本
- `required`：必填验证
- `pattern`：正则表达式验证
- `autofocus`：自动获取焦点
- `multiple`：允许多选（用于file、email）
- `min/max`：设置数值或日期的范围
- `step`：设置数值的步进值

### 3. 表单属性与验证（4分）
1. 请解释以下表单相关属性的作用和区别（2分）

**答案：**
- **`readonly` vs `disabled`**：
  - `readonly`：只读，不可编辑但可以选中和复制，**会被提交**
  - `disabled`：禁用，不可编辑、选中、获取焦点，**不会被提交**

- **`required` vs `pattern`**：
  - `required`：必填验证，检查是否有值
  - `pattern`：格式验证，使用正则表达式验证输入格式

- **`placeholder` vs `value`**：
  - `placeholder`：占位提示文本，不是真实值，不会被提交
  - `value`：输入框的实际值，会被提交

- **`autocomplete`**：
  - 控制浏览器自动填充功能
  - `on`：启用自动填充
  - `off`：禁用自动填充
  - 可指定具体类型如`autocomplete="email"`

2. 以下代码中，哪些input在表单提交时会被包含在数据中？为什么？（2分）

**答案：**
会被提交的input：
- **a**: ✅ 会提交，`readonly`只是只读，值仍会提交
- **b**: ❌ 不会提交，`disabled`的表单元素不会被提交
- **c**: ✅ 会提交，`hidden`类型正常提交
- **d**: ❌ 不会提交，只有`placeholder`没有实际值
- **e**: ✅ 会提交，空字符串也是有效值

## 二、CSS部分（15分钟，25分）

### 3. 盒模型与布局（10分）
1. 请详细说明CSS盒模型的组成部分，并解释标准盒模型和IE盒模型的区别（4分）

**答案：**
**盒模型组成部分：**
- Content（内容区）：实际内容
- Padding（内边距）：内容与边框之间的距离
- Border（边框）：围绕内边距的边框
- Margin（外边距）：元素与其他元素之间的距离

**标准盒模型 vs IE盒模型：**
- **标准盒模型（content-box）**：
  - width/height = content
  - 实际占用宽度 = width + padding + border
  
- **IE盒模型（border-box）**：
  - width/height = content + padding + border
  - 实际占用宽度 = width

通过`box-sizing`属性切换：
```css
box-sizing: content-box; /* 标准盒模型 */
box-sizing: border-box;  /* IE盒模型 */
```

2. 请用至少4种不同的方法实现一个div元素的水平垂直居中，并简要说明各方法的适用场景（6分）

**答案：**

**方法1：Flexbox（推荐）**
```css
.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
```
适用场景：现代浏览器，最简单通用

**方法2：Grid**
```css
.parent {
  display: grid;
  place-items: center;
}
```
适用场景：需要网格布局的场景

**方法3：绝对定位 + transform**
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```
适用场景：不知道元素宽高时

**方法4：绝对定位 + margin auto**
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  margin: auto;
  width: 200px;
  height: 100px;
}
```
适用场景：已知元素宽高时

**方法5：table-cell**
```css
.parent {
  display: table-cell;
  vertical-align: middle;
  text-align: center;
}
.child {
  display: inline-block;
}
```
适用场景：需要兼容旧版浏览器

### 4. CSS选择器与优先级（8分）
1. 计算以下选择器的优先级权重，并按优先级从高到低排序（4分）

**答案：**
优先级计算规则：(内联样式, ID选择器, 类/属性/伪类, 元素/伪元素)

a) `#header .nav li.active a:hover` = (0, 1, 2, 2) = 0122
b) `body header nav ul li a` = (0, 0, 0, 6) = 0006
c) `[data-role="navigation"] > ul > li` = (0, 0, 1, 2) = 0012
d) `.main-nav .menu-item.selected` = (0, 0, 3, 0) = 0030
e) `nav ul li:first-child::before` = (0, 0, 1, 4) = 0014
f) `html body div.container #content` = (0, 1, 1, 3) = 0113

**优先级从高到低排序：**
1. a) 0122
2. f) 0113
3. d) 0030
4. e) 0014
5. c) 0012
6. b) 0006

2. 哪些CSS属性可以继承？哪些不能继承？各列举5个（4分）

**答案：**
**可继承的属性：**
- `color` - 文字颜色
- `font-family` - 字体
- `font-size` - 字号
- `line-height` - 行高
- `text-align` - 文本对齐
- `visibility` - 可见性
- `cursor` - 鼠标样式

**不可继承的属性：**
- `width/height` - 宽高
- `margin/padding` - 外边距/内边距
- `border` - 边框
- `position` - 定位
- `display` - 显示类型
- `background` - 背景
- `float` - 浮动

### 5. CSS3新特性与响应式（7分）
1. 请说明rem、em、vw、vh单位的区别和使用场景（3分）

**答案：**
- **rem**：相对于根元素（html）的字体大小
  - 使用场景：移动端适配、统一缩放

- **em**：相对于父元素的字体大小
  - 使用场景：组件内部相对尺寸

- **vw**：视口宽度的1%
  - 使用场景：响应式布局、全屏元素

- **vh**：视口高度的1%
  - 使用场景：全屏高度元素、移动端适配

2. 请解释BFC（块级格式化上下文）的触发条件和作用，并举例说明如何利用BFC解决实际布局问题（4分）

**答案：**
**触发BFC的条件：**
- 根元素（html）
- 浮动元素（float不为none）
- 绝对定位元素（position为absolute或fixed）
- display为inline-block、table-cell、flex、grid等
- overflow不为visible

**BFC的作用：**
- 内部的盒子垂直排列
- 垂直方向的margin会重叠
- BFC区域不会与float元素重叠
- BFC内部浮动元素也参与高度计算
- 隔离独立容器，内外元素互不影响

**实际应用示例：**
1. **清除浮动**：
```css
.container {
  overflow: hidden; /* 触发BFC，包含浮动子元素 */
}
```

2. **防止margin重叠**：
```css
.wrapper {
  overflow: hidden; /* 创建BFC */
}
.box {
  margin: 20px; /* margin不会与外部重叠 */
}
```

3. **自适应两栏布局**：
```css
.sidebar {
  float: left;
  width: 200px;
}
.main {
  overflow: hidden; /* 触发BFC，不与浮动元素重叠 */
}
```

## 三、JavaScript部分（25分钟，40分）

### 6. 数据类型与检测（8分）
1. JavaScript有哪些数据类型？如何准确地检测一个变量的类型？（4分）

**答案：**
**基本数据类型（7种）：**
- `undefined`
- `null`
- `boolean`
- `number`
- `string`
- `symbol`（ES6）
- `bigint`（ES2020）

**引用数据类型：**
- `object`（包括普通对象、数组、函数、日期等）

**类型检测方法：**
```javascript
// 1. typeof - 适用于基本类型（注意null返回object）
typeof undefined // 'undefined'
typeof null // 'object' (历史遗留bug)

// 2. instanceof - 检测原型链
[] instanceof Array // true

// 3. Object.prototype.toString.call() - 最准确
Object.prototype.toString.call([]) // '[object Array]'
Object.prototype.toString.call(null) // '[object Null]'

// 4. Array.isArray() - 专门检测数组
Array.isArray([]) // true

// 通用检测函数
function getType(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
}
```

2. 以下代码的输出是什么？请解释原因（4分）

**答案：**
```javascript
console.log(typeof null);           // 'object' - 历史遗留bug
console.log(typeof undefined);      // 'undefined'
console.log(typeof []);             // 'object' - 数组是对象
console.log(typeof {});             // 'object'
console.log(null == undefined);     // true - 宽松相等，都表示"无"
console.log(null === undefined);    // false - 严格相等，类型不同
console.log(NaN == NaN);           // false - NaN不等于任何值，包括自己
console.log(0.1 + 0.2 == 0.3);    // false - 浮点数精度问题，实际结果是0.30000000000000004
```

### 7. this指向与call/apply/bind（10分）
1. 请分析以下代码中this的指向，并说明输出结果（5分）

**答案：**
```javascript
var name = '全局';

const obj = {
    name: '对象',
    regular: function() {
        console.log('regular:', this.name);        // '对象' - this指向obj
        
        const inner = function() {
            console.log('inner:', this.name);      // '全局' - 普通函数this指向window
        };
        inner();
        
        const arrow = () => {
            console.log('arrow:', this.name);      // '对象' - 箭头函数继承外层this
        };
        arrow();
    },
    arrow: () => {
        console.log('obj.arrow:', this.name);      // '全局' - 箭头函数定义时this指向window
    }
};

obj.regular();
// 输出：
// regular: 对象
// inner: 全局
// arrow: 对象

obj.arrow();
// 输出：
// obj.arrow: 全局

const extracted = obj.regular;
extracted();
// 输出：
// regular: 全局（this指向window）
// inner: 全局
// arrow: 全局

obj.regular.call({ name: '自定义' });
// 输出：
// regular: 自定义
// inner: 全局
// arrow: 自定义
```

2. 手写实现call和bind方法（5分）

**答案：**
```javascript
// 实现call
Function.prototype.myCall = function(context, ...args) {
    // 如果context为null或undefined，则指向全局对象
    context = context || globalThis;
    
    // 确保context是对象类型
    if (typeof context !== 'object') {
        context = Object(context);
    }
    
    // 用Symbol确保属性唯一
    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;
    
    // 调用函数并获取结果
    const result = context[fnSymbol](...args);
    
    // 删除临时属性
    delete context[fnSymbol];
    
    return result;
};

// 实现bind
Function.prototype.myBind = function(context, ...args) {
    const fn = this;
    
    return function(...newArgs) {
        // 判断是否使用new调用
        if (new.target) {
            return new fn(...args, ...newArgs);
        }
        return fn.myCall(context, ...args, ...newArgs);
    };
};

// 测试用例
function greet(greeting, punctuation) {
    return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: 'Alice' };
console.log(greet.myCall(person, 'Hello', '!')); // "Hello, Alice!"

const boundGreet = greet.myBind(person, 'Hi');
console.log(boundGreet('?')); // "Hi, Alice?"
```

### 8. 作用域与闭包（8分）
1. 请解释以下代码的输出，并说明涉及的概念（4分）

**答案：**
```javascript
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log('var:', i);  // 输出：3, 3, 3
    }, 100);
}
// var声明的变量是函数作用域，循环结束后i=3，所有setTimeout共享同一个i

for (let j = 0; j < 3; j++) {
    setTimeout(function() {
        console.log('let:', j);  // 输出：0, 1, 2
    }, 100);
}
// let声明的变量是块级作用域，每次循环都创建新的j

// 修改第一个循环使其输出0,1,2的方法：

// 方法1：使用闭包
for (var i = 0; i < 3; i++) {
    (function(index) {
        setTimeout(function() {
            console.log('var:', index);
        }, 100);
    })(i);
}

// 方法2：使用setTimeout的第三个参数
for (var i = 0; i < 3; i++) {
    setTimeout(function(index) {
        console.log('var:', index);
    }, 100, i);
}

// 方法3：使用bind
for (var i = 0; i < 3; i++) {
    setTimeout(function(index) {
        console.log('var:', index);
    }.bind(null, i), 100);
}
```

2. 使用闭包实现一个私有计数器，要求：可以增加、减少、获取当前值、重置（4分）

**答案：**
```javascript
function createCounter(initialValue = 0) {
    let count = initialValue;
    
    return {
        increment() {
            return ++count;
        },
        decrement() {
            return --count;
        },
        getValue() {
            return count;
        },
        reset(value = initialValue) {
            count = value;
            return count;
        }
    };
}

// 使用示例
const counter = createCounter(10);
console.log(counter.increment());  // 11
console.log(counter.increment());  // 12
console.log(counter.decrement());  // 11
console.log(counter.getValue());   // 11
console.log(counter.reset());      // 10
console.log(counter.reset(0));     // 0
```

### 9. 原型与继承（7分）

**答案：**
```javascript
function Animal(name) {
    this.name = name;
    this.colors = ['white', 'black'];
}

Animal.prototype.sayName = function() {
    console.log('My name is ' + this.name);
};

function Dog(name, breed) {
    // 调用父构造函数，继承实例属性
    Animal.call(this, name);
    this.breed = breed;
}

// 继承原型方法
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// 添加Dog特有方法
Dog.prototype.bark = function() {
    console.log('Woof!');
};

const dog1 = new Dog('Max', 'Golden Retriever');
const dog2 = new Dog('Buddy', 'Labrador');

dog1.colors.push('brown');
console.log(dog1.colors); // ['white', 'black', 'brown']
console.log(dog2.colors); // ['white', 'black'] - 各自独立的colors数组
dog1.sayName(); // "My name is Max"
```

### 10. 变量提升与执行上下文（7分）
1. 请解释以下代码的输出，说明变量提升和函数提升的规则（4分）

**答案：**
```javascript
console.log(a);     // undefined - var声明提升，但赋值不提升
console.log(b);     // ReferenceError - let存在暂时性死区
console.log(c);     // ReferenceError - const存在暂时性死区
console.log(foo);   // [Function: foo] - 函数声明完全提升
console.log(bar);   // undefined - var声明提升

var a = 1;
let b = 2;
const c = 3;

function foo() {
    return 'foo';
}

var bar = function() {
    return 'bar';
};

// 函数和变量同名时的优先级
console.log(test);  // [Function: test] - 函数声明优先
var test = 1;
function test() {}
console.log(test);  // 1 - 赋值后覆盖函数
```

**提升规则：**
- 函数声明完全提升（声明和定义）
- var变量声明提升，赋值不提升
- let/const不提升（暂时性死区）
- 同名时函数声明优先级高于变量声明

2. 手写实现new操作符，说明new的执行过程（3分）

**答案：**
```javascript
function myNew(Constructor, ...args) {
    // 1. 创建一个新对象，原型指向构造函数的prototype
    const obj = Object.create(Constructor.prototype);
    
    // 2. 执行构造函数，this指向新对象
    const result = Constructor.apply(obj, args);
    
    // 3. 如果构造函数返回对象，则返回该对象；否则返回新创建的对象
    return result instanceof Object ? result : obj;
}

// 测试用例
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.sayHello = function() {
    console.log(`Hello, I'm ${this.name}`);
};

const person = myNew(Person, 'Alice', 20);
console.log(person.name); // 'Alice'
person.sayHello(); // "Hello, I'm Alice"
```

**new操作符的执行过程：**
1. 创建一个新的空对象
2. 将新对象的`__proto__`指向构造函数的`prototype`
3. 将构造函数的`this`指向新对象并执行
4. 如果构造函数返回对象类型，则返回该对象；否则返回新创建的对象

## 四、综合应用题（15分钟，20分）

### 11. 算法实现题（20分）

**第一部分：LeetCode算法题（10分，三选一）**

**选项A：长度最小的子数组**
```javascript
function minSubArrayLen(target, nums) {
    let left = 0;
    let sum = 0;
    let minLen = Infinity;
    
    // 滑动窗口
    for (let right = 0; right < nums.length; right++) {
        sum += nums[right];
        
        // 当和大于等于target时，尝试缩小窗口
        while (sum >= target) {
            minLen = Math.min(minLen, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }
    
    return minLen === Infinity ? 0 : minLen;
}

// 测试
console.log(minSubArrayLen(7, [2,3,1,2,4,3])); // 2
```

**选项B：螺旋矩阵 II**
```javascript
function generateMatrix(n) {
    const matrix = Array(n).fill().map(() => Array(n).fill(0));
    
    let left = 0, right = n - 1;
    let top = 0, bottom = n - 1;
    let num = 1;
    
    while (left <= right && top <= bottom) {
        // 从左到右
        for (let i = left; i <= right; i++) {
            matrix[top][i] = num++;
        }
        top++;
        
        // 从上到下
        for (let i = top; i <= bottom; i++) {
            matrix[i][right] = num++;
        }
        right--;
        
        // 从右到左
        for (let i = right; i >= left; i--) {
            matrix[bottom][i] = num++;
        }
        bottom--;
        
        // 从下到上
        for (let i = bottom; i >= top; i--) {
            matrix[i][left] = num++;
        }
        left++;
    }
    
    return matrix;
}

// 测试
console.log(generateMatrix(3)); // [[1,2,3],[8,9,4],[7,6,5]]
```

**选项C：区间和**
```javascript
function rangeSum(nums, queries) {
    // 构建前缀和数组，优化查询性能
    const prefixSum = [0];
    for (let i = 0; i < nums.length; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }
    
    // 处理查询
    return queries.map(([start, end]) => {
        return prefixSum[end + 1] - prefixSum[start];
    });
}

// 测试
console.log(rangeSum([1, 2, 3, 4, 5], [[0, 2], [1, 3], [2, 4]])); 
// [6, 9, 12]
```

**第二部分：实用函数实现（10分，三选一）**

**选项1：防抖函数**
```javascript
function debounce(fn, delay, immediate = false) {
    let timer = null;
    let result;
    
    const debounced = function(...args) {
        const context = this;
        
        if (timer) clearTimeout(timer);
        
        if (immediate) {
            const callNow = !timer;
            timer = setTimeout(() => {
                timer = null;
            }, delay);
            if (callNow) {
                result = fn.apply(context, args);
            }
        } else {
            timer = setTimeout(() => {
                result = fn.apply(context, args);
            }, delay);
        }
        
        return result;
    };
    
    // 添加取消方法
    debounced.cancel = function() {
        clearTimeout(timer);
        timer = null;
    };
    
    return debounced;
}
```

**选项2：深拷贝**
```javascript
function deepClone(obj, map = new WeakMap()) {
    // 处理基本类型和null
    if (obj === null || typeof obj !== 'object') return obj;
    
    // 处理循环引用
    if (map.has(obj)) return map.get(obj);
    
    // 处理特殊对象
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof RegExp) return new RegExp(obj);
    if (obj instanceof Map) {
        const cloned = new Map();
        map.set(obj, cloned);
        obj.forEach((value, key) => {
            cloned.set(deepClone(key, map), deepClone(value, map));
        });
        return cloned;
    }
    if (obj instanceof Set) {
        const cloned = new Set();
        map.set(obj, cloned);
        obj.forEach(value => {
            cloned.add(deepClone(value, map));
        });
        return cloned;
    }
    
    // 处理数组
    if (Array.isArray(obj)) {
        const cloned = [];
        map.set(obj, cloned);
        obj.forEach((item, index) => {
            cloned[index] = deepClone(item, map);
        });
        return cloned;
    }
    
    // 处理普通对象
    const cloned = Object.create(Object.getPrototypeOf(obj));
    map.set(obj, cloned);
    
    for (let key of Reflect.ownKeys(obj)) {
        cloned[key] = deepClone(obj[key], map);
    }
    
    return cloned;
}
```

**选项3：数组扁平化**
```javascript
function flatten(arr, depth = 1) {
    // 边界条件
    if (depth <= 0) return arr.slice();
    
    // 递归实现
    return arr.reduce((result, item) => {
        if (Array.isArray(item) && depth > 0) {
            result.push(...flatten(item, depth - 1));
        } else {
            result.push(item);
        }
        return result;
    }, []);
}

// 或使用迭代实现
function flattenIterative(arr, depth = 1) {
    let result = [...arr];
    let currentDepth = 0;
    
    while (currentDepth < depth) {
        let hasArray = false;
        const newResult = [];
        
        for (let item of result) {
            if (Array.isArray(item)) {
                newResult.push(...item);
                hasArray = true;
            } else {
                newResult.push(item);
            }
        }
        
        result = newResult;
        if (!hasArray) break;
        currentDepth++;
    }
    
    return result;
}

// 测试
console.log(flatten([1, [2, [3, [4]]]], 2)); // [1, 2, 3, [4]]
console.log(flatten([1, [2, [3, [4]]]], Infinity)); // [1, 2, 3, 4]
```

---

## 答题要求

1. **时间分配**：
   - HTML：10分钟
   - CSS：15分钟
   - JavaScript：25分钟
   - 综合题：10分钟

2. **评分标准**：
   - HTML：15分
   - CSS：25分
   - JavaScript：40分
   - 综合应用：20分
   - 总分：100分

3. **注意事项**：
   - 优先完成熟悉的题目，确保基础分
   - JavaScript部分重点考察基础概念理解
   - 算法题选择两道完成即可
   - 注意代码的规范性和可读性
   - 时间控制很重要，避免在单题停留过久

**考试时间：60分钟 | 满分：100分**