# 面试常见代码题实现

## 1. 防抖和节流

### 防抖 (Debounce)
防抖是指在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

```javascript
/**
 * 防抖函数
 * @param {Function} func 需要防抖的函数
 * @param {number} delay 延迟时间
 * @param {boolean} immediate 是否立即执行
 * @returns {Function} 防抖后的函数
 */
function debounce(func, delay, immediate = false) {
  let timer = null;
  
  return function(...args) {
    const context = this;
    
    // 如果定时器存在，清除定时器
    if (timer) {
      clearTimeout(timer);
    }
    
    if (immediate) {
      // 立即执行模式
      const callNow = !timer;
      timer = setTimeout(() => {
        timer = null;
      }, delay);
      
      if (callNow) {
        func.apply(context, args);
      }
    } else {
      // 延迟执行模式
      timer = setTimeout(() => {
        func.apply(context, args);
      }, delay);
    }
  };
}

// 使用示例
const handleInput = debounce(function(e) {
  console.log('搜索:', e.target.value);
}, 300);

// HTML: <input oninput="handleInput(event)" placeholder="输入搜索内容">
```

### 节流 (Throttle)
节流是指规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

```javascript
/**
 * 节流函数
 * @param {Function} func 需要节流的函数
 * @param {number} delay 节流时间间隔
 * @returns {Function} 节流后的函数
 */
function throttle(func, delay) {
  let timer = null;
  let lastExecTime = 0;
  
  return function(...args) {
    const context = this;
    const currentTime = Date.now();
    
    if (currentTime - lastExecTime > delay) {
      // 如果距离上次执行时间超过delay，立即执行
      func.apply(context, args);
      lastExecTime = currentTime;
    } else if (!timer) {
      // 否则设置定时器，在剩余时间后执行
      timer = setTimeout(() => {
        func.apply(context, args);
        lastExecTime = Date.now();
        timer = null;
      }, delay - (currentTime - lastExecTime));
    }
  };
}

// 使用示例
const handleScroll = throttle(function() {
  console.log('滚动事件触发', window.scrollY);
}, 100);

// window.addEventListener('scroll', handleScroll);
```

## 2. 响应式系统实现

### 简单的响应式系统 (类似Vue 2.x)

```javascript
/**
 * 简单的响应式系统实现
 * 基于Object.defineProperty实现数据劫持
 */
class SimpleReactive {
  constructor(data) {
    this.data = data;
    this.deps = new Map(); // 存储依赖关系
    this.currentEffect = null; // 当前正在执行的effect
    
    this.observe(data);
  }
  
  /**
   * 观察对象，为每个属性添加getter/setter
   */
  observe(obj) {
    if (typeof obj !== 'object' || obj === null) {
      return;
    }
    
    Object.keys(obj).forEach(key => {
      this.defineReactive(obj, key, obj[key]);
    });
  }
  
  /**
   * 定义响应式属性
   */
  defineReactive(obj, key, val) {
    const deps = new Set(); // 存储该属性的依赖
    this.deps.set(key, deps);
    
    // 递归观察嵌套对象
    this.observe(val);
    
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: () => {
        // 依赖收集
        if (this.currentEffect) {
          deps.add(this.currentEffect);
        }
        return val;
      },
      set: (newVal) => {
        if (newVal === val) return;
        
        val = newVal;
        this.observe(newVal); // 观察新值
        
        // 触发更新
        deps.forEach(effect => effect());
      }
    });
  }
  
  /**
   * 创建响应式effect
   */
  effect(fn) {
    const effectFn = () => {
      this.currentEffect = effectFn;
      fn();
      this.currentEffect = null;
    };
    
    effectFn(); // 立即执行一次
    return effectFn;
  }
}

// 使用示例
const reactive = new SimpleReactive({
  name: 'Vue',
  version: '3.0',
  nested: {
    count: 0
  }
});

// 创建响应式effect
reactive.effect(() => {
  console.log(`当前应用: ${reactive.data.name} v${reactive.data.version}`);
  console.log(`计数: ${reactive.data.nested.count}`);
});

// 测试响应式
// reactive.data.name = 'React'; // 会触发effect重新执行
// reactive.data.nested.count++; // 会触发effect重新执行
```

### 基于Proxy的响应式系统 (类似Vue 3.x)

```javascript
/**
 * 基于Proxy的响应式系统
 */
class ProxyReactive {
  constructor() {
    this.targetMap = new WeakMap(); // 存储依赖关系
    this.activeEffect = null;
  }
  
  /**
   * 创建响应式对象
   */
  reactive(target) {
    if (typeof target !== 'object' || target === null) {
      return target;
    }
    
    return new Proxy(target, {
      get: (obj, key) => {
        const result = obj[key];
        
        // 依赖收集
        this.track(obj, key);
        
        // 如果属性值是对象，递归创建响应式
        return typeof result === 'object' && result !== null 
          ? this.reactive(result) 
          : result;
      },
      
      set: (obj, key, value) => {
        const oldValue = obj[key];
        obj[key] = value;
        
        // 如果值发生变化，触发更新
        if (oldValue !== value) {
          this.trigger(obj, key);
        }
        
        return true;
      }
    });
  }
  
  /**
   * 依赖收集
   */
  track(target, key) {
    if (!this.activeEffect) return;
    
    let depsMap = this.targetMap.get(target);
    if (!depsMap) {
      this.targetMap.set(target, (depsMap = new Map()));
    }
    
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, (dep = new Set()));
    }
    
    dep.add(this.activeEffect);
  }
  
  /**
   * 触发更新
   */
  trigger(target, key) {
    const depsMap = this.targetMap.get(target);
    if (!depsMap) return;
    
    const dep = depsMap.get(key);
    if (dep) {
      dep.forEach(effect => effect());
    }
  }
  
  /**
   * 创建effect
   */
  effect(fn) {
    const effectFn = () => {
      this.activeEffect = effectFn;
      fn();
      this.activeEffect = null;
    };
    
    effectFn();
    return effectFn;
  }
}

// 使用示例
const proxyReactive = new ProxyReactive();
const state = proxyReactive.reactive({
  count: 0,
  user: {
    name: 'John',
    age: 25
  }
});

proxyReactive.effect(() => {
  console.log(`Count: ${state.count}`);
  console.log(`User: ${state.user.name}, Age: ${state.user.age}`);
});

// 测试
// state.count++; // 会触发effect
// state.user.name = 'Jane'; // 会触发effect
```

## 3. 深拷贝和浅拷贝

### 浅拷贝实现

```javascript
/**
 * 浅拷贝实现
 * 只复制对象的第一层属性
 */
function shallowCopy(obj) {
  // 处理基本类型
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  
  // 处理数组
  if (Array.isArray(obj)) {
    return [...obj];
  }
  
  // 处理对象
  return { ...obj };
}

// 其他浅拷贝方法
const shallowCopyMethods = {
  // 方法1: Object.assign
  method1: (obj) => Object.assign({}, obj),
  
  // 方法2: 扩展运算符
  method2: (obj) => ({ ...obj }),
  
  // 方法3: 手动实现
  method3: (obj) => {
    if (typeof obj !== 'object' || obj === null) return obj;
    
    const result = Array.isArray(obj) ? [] : {};
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = obj[key];
      }
    }
    return result;
  }
};

// 使用示例
const original = {
  name: 'John',
  age: 25,
  hobbies: ['reading', 'coding'],
  address: {
    city: 'Beijing',
    street: 'Main St'
  }
};

const shallow = shallowCopy(original);
console.log(shallow.hobbies === original.hobbies); // true (浅拷贝)
```

### 深拷贝实现

```javascript
/**
 * 深拷贝实现 - 完整版
 * 处理各种数据类型和循环引用
 */
function deepCopy(obj, hash = new WeakMap()) {
  // 处理null和undefined
  if (obj === null || obj === undefined) {
    return obj;
  }
  
  // 处理基本类型
  if (typeof obj !== 'object') {
    return obj;
  }
  
  // 处理Date对象
  if (obj instanceof Date) {
    return new Date(obj);
  }
  
  // 处理RegExp对象
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  
  // 处理循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  // 创建新对象
  const cloneObj = Array.isArray(obj) ? [] : {};
  hash.set(obj, cloneObj);
  
  // 递归拷贝属性
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepCopy(obj[key], hash);
    }
  }
  
  return cloneObj;
}

/**
 * 深拷贝实现 - 简化版
 */
function simpleDeepCopy(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  
  if (Array.isArray(obj)) {
    return obj.map(item => simpleDeepCopy(item));
  }
  
  const result = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = simpleDeepCopy(obj[key]);
    }
  }
  
  return result;
}

/**
 * 使用JSON方法的深拷贝（有局限性）
 */
function jsonDeepCopy(obj) {
  // 注意：这种方法无法处理函数、undefined、Symbol、Date等
  return JSON.parse(JSON.stringify(obj));
}

// 使用示例和测试
const testObj = {
  name: 'John',
  age: 25,
  hobbies: ['reading', 'coding'],
  address: {
    city: 'Beijing',
    street: 'Main St',
    coordinates: {
      lat: 39.9042,
      lng: 116.4074
    }
  },
  birthDate: new Date('1998-01-01'),
  pattern: /test/gi,
  sayHello: function() {
    console.log('Hello!');
  }
};

// 创建循环引用用于测试
testObj.self = testObj;

console.log('=== 深拷贝测试 ===');
const deepCopied = deepCopy(testObj);

console.log('原对象和深拷贝对象是否相等:', testObj === deepCopied); // false
console.log('嵌套对象是否相等:', testObj.address === deepCopied.address); // false
console.log('数组是否相等:', testObj.hobbies === deepCopied.hobbies); // false
console.log('循环引用处理:', deepCopied.self === deepCopied); // true

// 修改深拷贝对象不会影响原对象
deepCopied.name = 'Jane';
deepCopied.address.city = 'Shanghai';
deepCopied.hobbies.push('swimming');

console.log('修改后原对象name:', testObj.name); // 'John'
console.log('修改后原对象city:', testObj.address.city); // 'Beijing'
console.log('修改后原对象hobbies长度:', testObj.hobbies.length); // 2
```

## 4. 性能对比和使用场景

### 防抖 vs 节流使用场景

```javascript
// 防抖使用场景示例
const debouncedSearch = debounce(function(query) {
  // 搜索API调用
  console.log('搜索:', query);
}, 300);

const debouncedSave = debounce(function(data) {
  // 自动保存
  console.log('保存数据:', data);
}, 1000);

// 节流使用场景示例
const throttledScroll = throttle(function() {
  // 滚动事件处理
  console.log('处理滚动事件');
}, 100);

const throttledResize = throttle(function() {
  // 窗口大小改变处理
  console.log('处理窗口大小改变');
}, 200);
```

### 拷贝方法性能测试

```javascript
function performanceTest() {
  const testData = {
    // 创建一个复杂的测试对象
    users: Array.from({ length: 1000 }, (_, i) => ({
      id: i,
      name: `User${i}`,
      profile: {
        age: Math.floor(Math.random() * 50) + 20,
        hobbies: ['reading', 'coding', 'gaming']
      }
    }))
  };
  
  console.time('深拷贝性能测试');
  const deepCopied = deepCopy(testData);
  console.timeEnd('深拷贝性能测试');
  
  console.time('JSON深拷贝性能测试');
  const jsonCopied = jsonDeepCopy(testData);
  console.timeEnd('JSON深拷贝性能测试');
  
  console.time('浅拷贝性能测试');
  const shallowCopied = shallowCopy(testData);
  console.timeEnd('浅拷贝性能测试');
}

// performanceTest();
```

## 5. 面试要点总结

### 防抖节流面试要点
1. **概念区别**: 防抖是延迟执行，节流是间隔执行
2. **使用场景**: 防抖适用于搜索、保存等，节流适用于滚动、拖拽等
3. **实现细节**: 注意this绑定、参数传递、立即执行模式
4. **性能优化**: 合理选择延迟时间，避免过度优化

### 响应式面试要点
1. **实现原理**: Object.defineProperty vs Proxy的区别
2. **依赖收集**: 如何收集和管理依赖关系
3. **更新触发**: 如何高效地触发更新
4. **性能考虑**: 避免不必要的更新，批量更新策略

### 深浅拷贝面试要点
1. **概念区别**: 浅拷贝只复制第一层，深拷贝递归复制所有层
2. **实现方式**: 多种实现方法的优缺点
3. **特殊情况**: 循环引用、特殊对象类型的处理
4. **性能权衡**: 根据实际需求选择合适的拷贝方式

---

*这些都是前端面试中的高频代码题，建议多练习实现和理解原理。*
