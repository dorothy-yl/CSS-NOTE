# 前端面试题 - 答案版（90分钟，120分）

## 一、HTML & 浏览器部分（15分钟，20分）

### 1. 浏览器存储（10分）
**题目：** `encodeURI` 和 `encodeURIComponent` 有什么区别？请举例说明使用场景（10分）

**答案：**
- **encodeURI**：用于编码完整的URI，不会编码URI中的保留字符（如 `:/?#[]@!$&'()*+,;=`）
- **encodeURIComponent**：用于编码URI中的组件部分，会编码所有非字母数字字符（除了 `-_.!~*'()`）

**使用场景举例：**
```javascript
// 1. encodeURI - 编码完整URL
const url = 'https://example.com/search?q=hello world';
console.log(encodeURI(url)); 
// 输出: https://example.com/search?q=hello%20world

// 2. encodeURIComponent - 编码查询参数
const baseUrl = 'https://api.example.com/search';
const query = 'hello world & you';
const fullUrl = baseUrl + '?q=' + encodeURIComponent(query);
console.log(fullUrl);
// 输出: https://api.example.com/search?q=hello%20world%20%26%20you
```

### 2. 浏览器渲染（10分）
**题目1：** 重绘和回流的理解，什么情况下会触发重绘和回流？（6分）

**答案：**
- **重绘（Repaint）**：元素样式改变不影响布局时，浏览器重新绘制元素外观
- **回流（Reflow）**：元素尺寸、位置改变时，浏览器重新计算布局

**触发重绘的情况：**
- 改变颜色、背景色
- 改变边框样式
- 改变visibility

**触发回流的情况：**
- 改变尺寸（width、height）
- 改变位置（top、left）
- 改变内容（文本内容、图片替换）
- 添加/删除DOM元素
- 改变字体大小

**题目2：** 如何优化减少重绘和回流？（4分）

**答案：**
1. **批量操作DOM**：使用DocumentFragment或一次性修改样式
2. **使用CSS3变换**：用transform代替改变位置
3. **避免频繁访问布局属性**：缓存offsetWidth等值
4. **使用absolute/fixed定位**：减少对其他元素的影响

## 二、CSS部分（15分钟，20分）

### 1. Display属性（7分）
**题目1：** `display` 有哪些常用属性值？（3分）

**答案：**
- block、inline、inline-block
- flex、grid
- none、table、table-cell

**题目2：** `block`, `inline`, `inline-block` 有什么区别？（4分）

**答案：**
| 属性 | 独占一行 | 可设置宽高 | 默认宽度 | 可设置margin/padding |
|------|----------|------------|----------|---------------------|
| block | 是 | 是 | 100% | 是 |
| inline | 否 | 否 | 内容宽度 | 水平方向可以，垂直方向不可以 |
| inline-block | 否 | 是 | 内容宽度 | 是 |

### 2. 盒模型（7分）
**题目1：** CSS盒模型是什么？标准盒模型和IE盒模型有什么区别？（4分）

**答案：**
- **CSS盒模型**：由content、padding、border、margin组成的矩形盒子
- **标准盒模型**：width = content
- **IE盒模型**：width = content + padding + border

**题目2：** 如何设置盒模型类型？box-sizing属性的作用（3分）

**答案：**
```css
/* 标准盒模型 */
box-sizing: content-box;

/* IE盒模型 */
box-sizing: border-box;
```

### 3. 布局实现（6分）
**题目1：** 怎么让子元素宽度撑满父元素？列举至少3种方法（3分）

**答案：**
1. `width: 100%`
2. `display: block`（块级元素默认）
3. `display: flex; flex: 1`

**题目2：** 响应式大屏适配方案有哪些，优缺点分别是什么？（3分）

**答案：**
1. **rem + 媒体查询**
   - 优点：兼容性好，可控性强
   - 缺点：需要设置多个断点
   
2. **vw/vh**
   - 优点：真正的响应式
   - 缺点：兼容性相对较差

3. **flex布局**
   - 优点：灵活，适应性强
   - 缺点：复杂布局可能需要嵌套

## 三、JavaScript部分（20分钟，35分）

### 3. 浏览器事件循环（5分）
**答案：**
输出顺序：
```
start
promise2
end
then2
timeout1
promise1
timeout2
```

**解释原因：**
1. 同步代码先执行：`start` → `promise2` → `end`
2. 微任务队列：`then2`
3. 宏任务队列：`timeout1` → 执行时产生微任务 `promise1`
4. 微任务优先执行：`promise1`
5. 继续宏任务：`timeout2`

### 4. 深浅拷贝（8分）
**题目1：** 为什么`JSON.parse(JSON.stringify())`不能处理循环引用？它还有哪些限制？（2分）

**答案：**
- **循环引用问题**：JSON.stringify遇到循环引用会抛出错误
- **其他限制**：
  - 函数会被忽略
  - undefined会被忽略
  - Symbol会被忽略
  - Date对象会变成字符串
  - RegExp对象会变成空对象

**题目2：** 代码中的`WeakMap`起什么作用？为什么不用普通的`Map`？（2分）

**答案：**
- **作用**：存储已拷贝的对象，用于检测循环引用
- **为什么用WeakMap**：
  - 弱引用，不会阻止对象被垃圾回收
  - 防止内存泄漏

**题目3：** `map.has(obj)`这个检查是如何防止无限递归的？（2分）

**答案：**
- 首次遇到对象时，`map.has(obj)`返回false，继续拷贝
- 再次遇到相同对象时，`map.has(obj)`返回true，直接返回已拷贝的引用
- 避免了无限递归调用

**题目4：** 浅拷贝`{...obj}`为什么修改`shallowCopy.b.c`会影响原对象？（2分）

**答案：**
- 浅拷贝只复制第一层属性
- `obj.b`是引用类型，拷贝的是引用地址
- `shallowCopy.b`和`obj.b`指向同一个对象
- 修改`shallowCopy.b.c`实际修改的是共享对象

### 5. XSS安全（7分）
**题目1：** XSS的原理是什么？有哪几种类型的XSS攻击？（3分）

**答案：**
- **原理**：将恶意脚本注入到网页中，在用户浏览器中执行

**三种类型：**
1. **存储型XSS**：恶意脚本存储在服务器，用户访问时执行
2. **反射型XSS**：恶意脚本通过URL参数等方式传入，立即执行
3. **DOM型XSS**：通过修改页面DOM结构来执行恶意脚本

**题目2：** XSS的防范措施有哪些？请详细说明（4分）

**答案：**
1. **输入验证**：对用户输入进行白名单验证
2. **输出编码**：对输出内容进行HTML编码
3. **CSP**：设置内容安全策略，限制脚本来源
4. **HttpOnly Cookie**：防止通过脚本访问Cookie

### 6. HTTP协议（7分）
**题目1：** 什么是HTTP？HTTP和HTTPS的区别是什么？（4分）

**答案：**
- **HTTP**：超文本传输协议，用于客户端和服务器间的数据传输

**区别：**
| 协议 | 安全性 | 端口 | 证书 | 性能 |
|------|--------|------|------|------|
| HTTP | 明文传输 | 80 | 不需要 | 较快 |
| HTTPS | 加密传输 | 443 | 需要SSL证书 | 较慢 |

**题目2：** HTTP常用的请求方法有哪些？请说明各自的作用和特点（3分）

**答案：**
- **GET**：获取资源，幂等、安全、可缓存
- **POST**：提交数据，非幂等、非安全、不可缓存
- **PUT**：更新资源，幂等、非安全
- **DELETE**：删除资源，幂等、非安全
- **PATCH**：部分更新，非幂等、非安全

### 7. 构造函数与闭包（8分）
**题目1：** 代码中的 `instanceCount` 变量为什么能在多次调用后保持累加？（2分）

**答案：**
- 因为`instanceCount`在IIFE的作用域中
- 形成了闭包，变量不会被销毁
- 每次调用Person构造函数时，都能访问并修改同一个`instanceCount`

**题目2：** `Object.defineProperty` 中的 `get()` 方法有什么作用？为什么要用它？（2分）

**答案：**
- **作用**：定义属性的getter，控制属性的访问
- **为什么用**：
  - 实现私有属性的只读访问
  - 保护内部变量不被直接修改

**题目3：** `this instanceof Person` 这个判断是在检查什么？如果不用 new 调用会怎样？（2分）

**答案：**
- **检查什么**：检查函数是否通过new操作符调用
- **不用new的后果**：
  - this指向全局对象（浏览器中是window）
  - 可能污染全局变量
  - 无法正确创建实例对象

**题目4：** 比较两种实现方式，闭包方式和静态属性方式各有什么优缺点？（2分）

**答案：**
| 方式 | 优点 | 缺点 |
|------|------|------|
| 闭包方式 | 真正的私有化，无法从外部访问计数器 | 代码复杂，内存占用稍高 |
| 静态属性方式 | 代码简洁，容易理解 | 计数器可被外部修改，不够安全 |

## 四、Vue部分（15分钟，25分）

### 8. TypeScript类型系统（5分）
**题目1：** `type`和`interface`的区别是什么？（3分）

**答案：**
| 特性 | interface | type |
|------|-----------|------|
| 扩展性 | 可以声明合并 | 不可以声明合并 |
| 继承 | extends关键字 | 交叉类型& |
| 联合类型 | 不支持 | 支持 |
| 原始类型 | 不支持 | 支持 |

**题目2：** 什么场景用type，什么场景用interface？（2分）

**答案：**
- **用interface**：定义对象形状，需要扩展或实现的场景
- **用type**：联合类型、原始类型别名、复杂类型组合

### 9. v-model原理（8分）
**题目1：** v-model在`<input>`元素上绑定的是什么属性和什么事件？（2分）

**答案：**
- **属性**：`value`
- **事件**：`input`

**题目2：** 为什么复选框使用的是`@change`事件而不是`@input`事件？（2分）

**答案：**
- 复选框的状态是`checked`属性（布尔值）
- `change`事件更适合处理布尔状态的切换
- `input`事件主要用于文本输入的实时监听

**题目3：** Vue 3中自定义组件的v-model使用`modelValue`，而Vue 2使用`value`，这两个prop名称可以自定义吗？（2分）

**答案：**
- **Vue 2**：prop名称固定为`value`，不可自定义
- **Vue 3**：可以自定义，通过`v-model:customName`指定

**题目4：** 看代码中的"等价于"部分，v-model做了哪两件事情？（2分）

**答案：**
1. **数据绑定**：将数据绑定到表单元素的value/checked属性
2. **事件监听**：监听相应事件，更新数据

### 10. Vue2响应式原理（7分）
**题目1：** Vue2响应式原理有哪些弊端？（3分）

**答案：**
1. 无法检测对象属性的添加和删除
2. 无法检测数组索引和长度的变化
3. 深度监听性能问题（需要递归遍历）

**题目2：** 哪些数组的方法改动不会被监听到？（2分）

**答案：**
- 通过索引设置项：`arr[0] = newValue`
- 修改数组长度：`arr.length = 0`

**题目3：** Vue2是如何做到对数组变化的检测的？（2分）

**答案：**
- 重写数组的7个变更方法（push、pop、shift、unshift、splice、sort、reverse）
- 在这些方法中手动触发更新
- 对于非变更方法，通过替换整个数组来实现

### 11. 状态管理（5分）
**题目：** Pinia vs Vuex：请从API设计、TypeScript支持、模块化等方面对比（5分）

**答案：**
| 方面 | Vuex | Pinia |
|------|------|-------|
| API设计 | mutations、actions、getters概念复杂 | 更简洁，直接修改state |
| TypeScript支持 | 需要额外配置，类型推导困难 | 原生TypeScript支持 |
| 模块化 | 命名空间模式，嵌套复杂 | 扁平化设计，每个store独立 |
| 代码分割 | 手动配置 | 自动代码分割 |
| DevTools | Vue DevTools支持 | 更好的调试体验 |

## 五、工程化与实践（10分钟，25分）

### 12. Git常用命令（15分）
**题目1：** `git add .` 和 `git commit -m` 分别的作用是什么？为什么需要分两步？（3分）

**答案：**
- **git add .**：将工作区的变更添加到暂存区
- **git commit -m**：将暂存区的变更提交到版本库
- **分两步原因**：
  - 可以选择性提交部分文件
  - 暂存区作为缓冲，可以多次修改后统一提交

**题目2：** `git pull` 实际上是哪两个命令的组合？（3分）

**答案：**
- `git fetch`：从远程仓库获取最新数据
- `git merge`：将获取的数据合并到当前分支
- `git pull = git fetch + git merge`

**题目3：** `git reset --soft` 和 `git reset --hard` 的区别是什么？（4分）

**答案：**
| 命令 | 工作区 | 暂存区 | 版本库 | 使用场景 |
|------|--------|--------|--------|----------|
| --soft | 保留 | 保留 | 重置 | 想要重新提交 |
| --hard | 重置 | 重置 | 重置 | 完全丢弃所有更改 |

**题目4：** 为什么使用 `git revert` 比 `git reset --hard` + `git push --force` 更安全？（5分）

**答案：**
1. **保留历史记录**：revert创建新提交，不破坏提交历史
2. **团队协作安全**：不会影响其他人已经拉取的代码
3. **可追溯性**：可以看到撤销的原因和过程
4. **可恢复性**：如果撤销错误，可以再次revert
5. **避免冲突**：不会导致其他开发者的强制更新

### 13. 算法题（加分题，不计入总分）
**手撕代码：** 反转字符串中的单词（+10分）

**答案：**
```javascript
function reverseWords(s) {
    // 方法1：使用split和map
    return s.split(' ').map(word => 
        word.split('').reverse().join('')
    ).join(' ');
}

// 方法2：双指针
function reverseWords2(s) {
    let result = '';
    let word = '';
    
    for (let i = 0; i < s.length; i++) {
        if (s[i] === ' ') {
            // 反转当前单词并加到结果中
            result += word.split('').reverse().join('') + ' ';
            word = '';
        } else {
            word += s[i];
        }
    }
    
    // 处理最后一个单词
    result += word.split('').reverse().join('');
    
    return result;
}

// 测试用例
console.log(reverseWords("Let's take LeetCode contest"));
// 输出: "s'teL ekat edoCteeL tsetnoc"

console.log(reverseWords("God Ding"));
// 输出: "doG gniD"
```

---

## 答题要求

1. **时间分配**：
   - HTML & 浏览器：15分钟
   - CSS：15分钟
   - JavaScript：25分钟
   - Vue：25分钟
   - 工程化与实践：10分钟

2. **评分标准**：
   - HTML & 浏览器：20分
   - CSS：20分
   - JavaScript：35分
   - Vue：25分
   - 工程化与实践：20分
   - 总分：120分
   - 加分题：+10分（不计入总分）

3. **注意事项**：
   - 手撕代码题要求代码可运行，注意边界条件
   - 概念题要求条理清晰，要点完整
   - 时间控制很重要，优先完成熟悉的题目
   - 代码题注重思路和关键实现

**考试时间：90分钟 | 满分：120分 | 加分题：+10分**