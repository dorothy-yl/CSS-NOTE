# 前端面试题 - 答题版（90分钟，120分）

## 一、HTML & 浏览器部分（15分钟，20分）

### 1. 浏览器存储（10分）
1. `encodeURI` 和 `encodeURIComponent` 有什么区别？请举例说明使用场景（10分）

**答案：**




---

### 2. 浏览器渲染（10分）
1. 重绘和回流的理解，什么情况下会触发重绘和回流？（6分）

**答案：**




2. 如何优化减少重绘和回流？（4分）

**答案：**




---

## 二、CSS部分（15分钟，20分）

### 1. Display属性（7分）
1. `display` 有哪些常用属性值？（3分）

**答案：**




2. `block`, `inline`, `inline-block` 有什么区别？请从盒模型、宽高、换行等方面说明（4分）

**答案：**




---

### 2. 盒模型（7分）
1. CSS盒模型是什么？标准盒模型和IE盒模型有什么区别？（4分）

**答案：**




2. 如何设置盒模型类型？box-sizing属性的作用（3分）

**答案：**




---

### 3. 布局实现（6分）
1. 怎么让子元素宽度撑满父元素？列举至少3种方法（3分）

**答案：**




2. 响应式大屏适配方案有哪些，优缺点分别是什么？（3分）

**答案：**




---

## 三、JavaScript部分（20分钟，35分）

### 3. 浏览器事件循环（5分）
分析以下代码的输出顺序并解释原因（5分）
```javascript
console.log('start');

setTimeout(() => {
    console.log('timeout1');
    Promise.resolve().then(() => {
        console.log('promise1');
    });
}, 0);

new Promise((resolve) => {
    console.log('promise2');
    resolve();
}).then(() => {
    console.log('then2');
    setTimeout(() => {
        console.log('timeout2');
    }, 0);
});

console.log('end');
```

**答案：**
输出顺序：


原因解释：




---

### 4. 深浅拷贝（8分）
以下是深拷贝的实现代码，包括处理循环引用的方案：

```javascript
// 1. 浅拷贝示例
const obj = { a: 1, b: { c: 2 } };
const shallowCopy = { ...obj };  // 或 Object.assign({}, obj)
shallowCopy.b.c = 3;  // 会影响原对象的 obj.b.c

// 2. 简单深拷贝（不能处理循环引用、函数、Date等）
const simpleDeepCopy = JSON.parse(JSON.stringify(obj));

// 3. 处理循环引用的深拷贝实现
function deepClone(obj, map = new WeakMap()) {
  // 基本类型直接返回
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 检查循环引用
  if (map.has(obj)) {
    return map.get(obj);  // 返回已拷贝的对象引用
  }
  
  // 处理特殊对象类型
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags);
  }
  
  // 创建新对象或数组
  const cloned = Array.isArray(obj) ? [] : {};
  
  // 存储到map中，用于检测循环引用
  map.set(obj, cloned);
  
  // 递归拷贝属性
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key], map);
    }
  }
  
  return cloned;
}

// 4. 测试循环引用
const circular = { name: 'obj' };
circular.self = circular;  // 创建循环引用

// JSON.stringify 会报错
// JSON.stringify(circular);  // TypeError: Converting circular structure to JSON

// 使用 deepClone 可以正常处理
const cloned = deepClone(circular);
console.log(cloned.self === cloned);  // true，保持了循环引用结构

// 5. 其他深拷贝方法
// - lodash的_.cloneDeep()
// - 结构化克隆：structuredClone(obj) (新API)
```

基于上述代码，请回答以下问题：
1. 为什么`JSON.parse(JSON.stringify())`不能处理循环引用？它还有哪些限制？（2分）

**答案：**




2. 代码中的`WeakMap`起什么作用？为什么不用普通的`Map`？（2分）

**答案：**




3. `map.has(obj)`这个检查是如何防止无限递归的？（2分）

**答案：**




4. 浅拷贝`{...obj}`为什么修改`shallowCopy.b.c`会影响原对象？（2分）

**答案：**




---

### 5. XSS安全（7分）
1. XSS的原理是什么？有哪几种类型的XSS攻击？（3分）

**答案：**




2. XSS的防范措施有哪些？请详细说明（4分）

**答案：**




---

### 6. HTTP协议（7分）
1. 什么是HTTP？HTTP和HTTPS的区别是什么？（4分）

**答案：**




2. HTTP常用的请求方法有哪些？请说明各自的作用和特点（3分）

**答案：**




---

### 7. 构造函数与闭包（8分）
下面是一个构造函数的实现，它的实例对象能知道自己是第几次被调用的：

```javascript
// 使用闭包实现
const Person = (function() {
  let instanceCount = 0;  // 闭包中的计数器
  
  function Person(name) {
    // 检查是否使用 new 调用
    if (!(this instanceof Person)) {
      throw new Error('Person must be called with new');
    }
    
    instanceCount++;
    
    // 私有属性（使用闭包）
    let _order = instanceCount;
    
    // 使用 getter 访问私有属性
    Object.defineProperty(this, 'order', {
      get() {
        return _order;
      }
    });
    
    this.name = name;
  }
  
  return Person;
})();

// 不用闭包的实现（使用静态属性）
function Animal(name) {
  if (!(this instanceof Animal)) {
    throw new Error('Animal must be called with new');
  }
  
  // 使用构造函数的静态属性
  Animal.instanceCount = (Animal.instanceCount || 0) + 1;
  
  this.order = Animal.instanceCount;
  this.name = name;
}
```

基于上述代码，请回答以下问题：
1. 代码中的 `instanceCount` 变量为什么能在多次调用后保持累加？（2分）

**答案：**




2. `Object.defineProperty` 中的 `get()` 方法有什么作用？为什么要用它？（2分）

**答案：**




3. `this instanceof Person` 这个判断是在检查什么？如果不用 new 调用会怎样？（2分）

**答案：**




4. 比较两种实现方式，闭包方式和静态属性方式各有什么优缺点？（2分）

**答案：**




---

## 四、Vue部分（15分钟，25分）

### 8. TypeScript类型系统（5分）
1. `type`和`interface`的区别是什么？（3分）

**答案：**




2. 什么场景用type，什么场景用interface？（2分）

**答案：**




---

### 9. v-model原理（8分）
以下是v-model在不同场景下的实现代码：

```vue
<!-- 1. v-model的本质：是语法糖 -->
<!-- 使用v-model -->
<input v-model="message" />

<!-- 等价于 -->
<input 
  :value="message" 
  @input="message = $event.target.value" 
/>

<!-- 2. 在不同表单元素上的实现 -->
<template>
  <!-- 文本输入框 -->
  <input v-model="text" />
  <!-- 等价于 -->
  <input :value="text" @input="text = $event.target.value" />
  
  <!-- 复选框 -->
  <input type="checkbox" v-model="checked" />
  <!-- 等价于 -->
  <input type="checkbox" :checked="checked" @change="checked = $event.target.checked" />
  
  <!-- 下拉选择框 -->
  <select v-model="selected">
    <option value="A">A</option>
    <option value="B">B</option>
  </select>
  <!-- 等价于 -->
  <select :value="selected" @change="selected = $event.target.value">
    <option value="A">A</option>
    <option value="B">B</option>
  </select>
</template>

<!-- 3. 自定义组件实现v-model -->
<!-- 父组件使用 -->
<MyInput v-model="parentValue" />
<!-- 等价于 -->
<MyInput :modelValue="parentValue" @update:modelValue="parentValue = $event" />

<!-- 子组件实现 (Vue 3) -->
<template>
  <input 
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>
<script>
export default {
  props: ['modelValue'],
  emits: ['update:modelValue']
}
</script>

<!-- 子组件实现 (Vue 2) -->
<template>
  <input 
    :value="value"
    @input="$emit('input', $event.target.value)"
  />
</template>
<script>
export default {
  props: ['value']
}
</script>
```

基于上述代码，请回答以下问题：
1. v-model在`<input>`元素上绑定的是什么属性和什么事件？（2分）

**答案：**




2. 为什么复选框使用的是`@change`事件而不是`@input`事件？（2分）

**答案：**




3. Vue 3中自定义组件的v-model使用`modelValue`，而Vue 2使用`value`，这两个prop名称可以自定义吗？（2分）

**答案：**




4. 看代码中的"等价于"部分，v-model做了哪两件事情？（2分）

**答案：**




---

### 10. Vue2响应式原理（7分）
1. Vue2响应式原理有哪些弊端？（3分）

**答案：**




2. 哪些数组的方法改动不会被监听到？（2分）

**答案：**




3. Vue2是如何做到对数组变化的检测的？（2分）

**答案：**




---

### 11. 状态管理（5分）
1. Pinia vs Vuex：请从API设计、TypeScript支持、模块化等方面对比（5分）

**答案：**




---

## 五、工程化与实践（10分钟，25分）

### 12. Git常用命令（15分）
以下是常用的Git命令及其用法示例：

```bash
# 1. 初始化和配置
git init                          # 初始化一个新的Git仓库
git config --global user.name "Your Name"  # 配置用户名

# 2. 基础操作
git status                        # 查看工作区状态
git add .                         # 添加所有文件到暂存区
git commit -m "message"           # 提交暂存区的更改

# 3. 分支操作
git branch                        # 查看所有分支
git checkout -b feature-branch    # 创建并切换到新分支
git merge feature-branch          # 合并分支到当前分支

# 4. 远程操作
git remote add origin url         # 添加远程仓库
git push origin main              # 推送到远程仓库
git pull origin main              # 从远程拉取并合并

# 5. 查看历史
git log --oneline                 # 查看简洁的提交历史
git diff                          # 查看未暂存的更改

# 6. 撤销操作
git reset --soft HEAD~1           # 撤销最后一次commit，保留更改
git reset --hard HEAD~1           # 撤销最后一次commit，丢弃更改
git revert commit-hash            # 创建一个新commit来撤销指定的commit

# 7. 撤销已push的commit（两种方法）
# 方法1：使用revert（推荐，更安全）
git revert HEAD
git push origin main

# 方法2：使用reset（需要强制推送，谨慎使用）
git reset --hard HEAD~1
git push --force origin main
```

基于上述命令，请回答以下问题：
1. `git add .` 和 `git commit -m` 分别的作用是什么？为什么需要分两步？（3分）

**答案：**




2. `git pull` 实际上是哪两个命令的组合？（3分）

**答案：**




3. `git reset --soft` 和 `git reset --hard` 的区别是什么？（4分）

**答案：**




4. 为什么使用 `git revert` 比 `git reset --hard` + `git push --force` 更安全？（5分）

**答案：**




---

### 13. 算法题（加分题，不计入总分）
**手撕代码：** 反转字符串中的单词（+10分）
```javascript
// 给定一个字符串，反转字符串中每个单词的字符顺序，同时保留空格和单词的初始顺序
// 示例 1：
// 输入："Let's take LeetCode contest"
// 输出："s'teL ekat edoCteeL tsetnoc" // cspell:disable-line

// 示例 2：
// 输入："God Ding"
// 输出："doG gniD"

function reverseWords(s) {
    // 请实现
    
    
    
    
}

// 测试用例
console.log(reverseWords("Let's take LeetCode contest"));
// 输出: "s'teL ekat edoCteeL tsetnoc" // cspell:disable-line

console.log(reverseWords("God Ding"));
// 输出: "doG gniD"
```

**答案：**
```javascript
function reverseWords(s) {
    // 实现代码




}
```

---

## 答题要求

1. **时间分配**：
   - HTML & 浏览器：15分钟
   - CSS：15分钟
   - JavaScript：25分钟
   - Vue：25分钟
   - 工程化与实践：10分钟

2. **评分标准**：
   - HTML & 浏览器：20分
   - CSS：20分
   - JavaScript：35分
   - Vue：25分
   - 工程化与实践：20分
   - 总分：120分
   - 加分题：+10分（不计入总分）

3. **注意事项**：
   - 手撕代码题要求代码可运行，注意边界条件
   - 概念题要求条理清晰，要点完整
   - 时间控制很重要，优先完成熟悉的题目
   - 代码题注重思路和关键实现

**考试时间：90分钟 | 满分：120分 | 加分题：+10分**

---

## 答题区域说明
- 每个题目下方都有 **答案：** 标记
- 请在标记下方填写你的答案
- 代码题请保持格式整洁
- 可以适当使用 Markdown 格式增强可读性