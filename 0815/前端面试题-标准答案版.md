# 前端面试题 - 标准答案版（60分钟，100分）

## 一、HTML部分（10分钟，15分）

### 1. HTML规范与结构（7分）
1. 请解释什么是语义化HTML，并说明使用语义化标签的好处有哪些？（4分）

**答案：**
语义化HTML是指使用合适的HTML标签来准确描述内容的含义和结构，而不仅仅是外观展示。

好处包括：
- **可读性和维护性**：代码结构清晰，便于开发者理解和维护
- **SEO优化**：搜索引擎能更好地理解页面内容，提升搜索排名
- **无障碍访问**：屏幕阅读器等辅助技术能更准确地解析内容
- **跨设备兼容**：在不同设备和浏览器上表现更一致
- **团队协作**：统一的语义化标准便于团队成员协作

2. 请举例说明6个HTML5新增的结构化标签及其适用场景（3分）

**答案：**
- `<header>`：页面或区块的头部，如网站导航栏、标题区域
- `<footer>`：页面或区块的底部，如版权信息、联系方式
- `<nav>`：导航链接区域，如主菜单、面包屑导航
- `<article>`：独立的内容区块，如博客文章、新闻报道
- `<section>`：文档中的节或区段，如章节、功能模块
- `<main>`：页面主要内容区域，每个页面只能有一个

### 2. HTML5新功能（8分）
1. HTML5提供了哪些新的JavaScript API？请描述至少3个API的作用（4分）

**答案：**
- **Canvas API**：提供2D图形绘制功能，适用于游戏、图表、图像处理
- **Geolocation API**：获取用户地理位置信息，用于地图应用、本地化服务
- **Web Storage API**：包括localStorage（持久存储）和sessionStorage（会话存储），用于客户端数据存储
- **Web Workers API**：在后台线程运行脚本，不阻塞UI，用于处理复杂计算
- **WebSocket API**：提供全双工通信通道，用于实时应用
- **File API**：处理本地文件，实现文件上传预览等功能

2. 请对比Canvas和SVG这两种图形技术的特点，它们分别适合什么应用场景？（4分）

**答案：**

**Canvas特点：**
- 基于像素的位图渲染
- 通过JavaScript绘制
- 不支持事件处理器（需要手动实现）
- 适合复杂动画、游戏、图像处理、实时数据可视化

**SVG特点：**
- 基于XML的矢量图形
- 支持CSS样式和DOM事件
- 可缩放不失真
- 适合图标、Logo、简单动画、静态图表

## 二、CSS部分（15分钟，25分）

### 3. 布局技术（10分）
1. 请列举至少3种实现元素水平垂直居中的CSS方法（6分）

**答案：**

**方法1：Flexbox**
```css
.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
```

**方法2：Grid**
```css
.parent {
    display: grid;
    place-items: center;
}
```

**方法3：绝对定位 + transform**
```css
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
```

**方法4：绝对定位 + margin auto**
```css
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
    width: 200px;
    height: 100px;
}
```

2. 如何创建一个保持特定宽高比的自适应容器？（4分）

**答案：**

**现代方法：aspect-ratio**
```css
.aspect-ratio-box {
    width: 100%;
    aspect-ratio: 16 / 9;
}
```

**传统方法：padding-top**
```css
.aspect-ratio-box {
    position: relative;
    width: 100%;
    padding-top: 56.25%; /* 16:9 = 9/16 = 0.5625 */
}
.content {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}
```

### 4. 格式化上下文（8分）
1. 请解释BFC（块级格式化上下文）的概念，以及创建BFC的方式有哪些？（4分）

**答案：**
BFC（Block Formatting Context）是一个独立的渲染区域，内部元素的布局不会影响外部元素。

**创建BFC的方式：**
- 根元素（`<html>`）
- 浮动元素（`float`不为`none`）
- 绝对定位元素（`position`为`absolute`或`fixed`）
- `display`为`inline-block`、`table-cell`、`flex`、`grid`等
- `overflow`不为`visible`

2. BFC在实际开发中有哪些应用？请举例说明（4分）

**答案：**
- **清除浮动**：父元素创建BFC可以包含浮动子元素
- **防止margin重叠**：相邻元素的垂直margin不会合并
- **防止元素被浮动元素覆盖**：BFC元素不会被浮动元素覆盖
- **自适应两栏布局**：利用BFC实现自适应宽度

示例：
```css
/* 清除浮动 */
.container {
    overflow: hidden; /* 创建BFC */
}

/* 防止margin重叠 */
.box {
    overflow: hidden; /* 创建BFC */
    margin: 20px 0;
}
```

### 5. 动画与变换（7分）
1. transform属性支持哪些变换函数？（3分）

**答案：**
- **平移**：`translate(x, y)`、`translateX()`、`translateY()`、`translateZ()`
- **旋转**：`rotate(angle)`、`rotateX()`、`rotateY()`、`rotateZ()`
- **缩放**：`scale(x, y)`、`scaleX()`、`scaleY()`
- **倾斜**：`skew(x, y)`、`skewX()`、`skewY()`
- **矩阵**：`matrix()`、`matrix3d()`

2. 请编写CSS代码实现元素的渐隐渐现动画效果（4分）

**答案：**
```css
@keyframes fadeInOut {
    0% {
        opacity: 0;
    }
    50% {
        opacity: 1;
    }
    100% {
        opacity: 0;
    }
}

.fade-element {
    animation: fadeInOut 2s ease-in-out infinite;
}

/* 或使用transition实现hover效果 */
.fade-hover {
    opacity: 1;
    transition: opacity 0.3s ease;
}
.fade-hover:hover {
    opacity: 0.5;
}
```

## 三、JavaScript部分（25分钟，40分）

### 6. 上下文绑定（10分）

```javascript
const user = {
    username: '李四',
    getUserName: function() {
        return this.username;
    },
    getUserNameArrow: () => {
        return this.username;
    }
};

const getUser = user.getUserName;
console.log(user.getUserName());      // 输出：李四
console.log(getUser());                // 输出：undefined（严格模式下报错）
console.log(user.getUserNameArrow());  // 输出：undefined（箭头函数的this指向定义时的上下文）
```

### 7. DOM事件中的上下文（8分）

```javascript
class Component {
    constructor(title) {
        this.title = title;
    }
    
    onClick() {
        console.log(this.title);
    }
    
    onClickArrow = () => {
        console.log(this.title);
    }
}

const comp = new Component('按钮组件');
const element = document.getElementById('btn');

element.addEventListener('click', comp.onClick);      // 点击输出：undefined（this指向element）
element.addEventListener('click', comp.onClickArrow); // 点击输出：按钮组件（箭头函数保持this）
```

### 8. 函数绑定方法（8分）

```javascript
const student1 = { name: '王五' };
const student2 = { name: '赵六' };

function showInfo(grade, school) {
    return `我是${this.name}，${grade}年级，就读于${school}`;
}

// 使用call
console.log(showInfo.call(student1, '三年级', '实验小学'));

// 使用apply
console.log(showInfo.apply(student1, ['三年级', '实验小学']));

// 使用bind
const bindFunc = showInfo.bind(student1);
console.log(bindFunc('三年级', '实验小学'));
```

### 9. 构造函数与原型（7分）

```javascript
function Person(name) {
    this.name = name;
}

Person.prototype.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
};

const john = new Person('John');
const greet = john.greet;

john.greet();    // 输出：Hello, I'm John
greet();         // 输出：Hello, I'm undefined（严格模式下报错）
greet.call(john); // 输出：Hello, I'm John
```

### 10. 异步回调中的上下文（7分）

```javascript
const counter = {
    value: 0,
    increment: function() {
        setTimeout(function() {
            this.value++;
            console.log(this.value);
        }, 1000);
    },
    incrementArrow: function() {
        setTimeout(() => {
            this.value++;
            console.log(this.value);
        }, 1000);
    }
};

counter.increment();      // 输出：NaN（普通函数中this指向window/undefined）
counter.incrementArrow(); // 输出：1（箭头函数保持外层this）
```

## 四、综合应用题（15分钟，20分）

### 11. 算法实现题（20分）

**选项1：数组去重**
```javascript
function removeDuplicates(nums) {
    if (nums.length === 0) return 0;
    
    let slow = 0;
    for (let fast = 1; fast < nums.length; fast++) {
        if (nums[fast] !== nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }
    return slow + 1;
}
```

**选项2：零元素移动**
```javascript
function moveZeroes(nums) {
    let nonZeroIndex = 0;
    
    // 将所有非零元素移到前面
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            nums[nonZeroIndex] = nums[i];
            nonZeroIndex++;
        }
    }
    
    // 将剩余位置填充为0
    for (let i = nonZeroIndex; i < nums.length; i++) {
        nums[i] = 0;
    }
    
    return nums;
}
```

**选项3：删除指定元素**
```javascript
function removeElement(nums, val) {
    let k = 0;
    
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== val) {
            nums[k] = nums[i];
            k++;
        }
    }
    
    return k;
}
```