# 前端面试题 - 标准答案版（60分钟，100分）

## 一、HTML部分（10分钟，15分）

### 1. HTML语义化与SEO优化（5分）

#### 题目1：HTML语义化问题改进（3分）

**原始代码问题分析：**
1. **标题标签误用**：使用`<b>`表示标题，应使用`<h1>`-`<h6>`
2. **交互元素语义错误**：`<span>`用于交互，应使用`<button>`或`<a>`
3. **图片缺少描述**：`<img>`缺少alt属性，影响可访问性和SEO
4. **表格结构不规范**：缺少`<thead>`、`<tbody>`、`<th>`等语义标签
5. **容器语义缺失**：整体用`<div>`包裹，缺少语义化容器

**改进后的代码：**
```html
<article class="announcement">
  <header>
    <h1>重要公告：系统维护通知</h1>
  </header>
  
  <button type="button" onclick="showDetails()" aria-label="展开详情">
    点击查看详情
  </button>
  
  <section class="product-section">
    <img src="banner.jpg" alt="最新产品发布横幅图" loading="lazy">
    <h2>最新产品发布</h2>
  </section>
  
  <table class="staff-table">
    <caption>员工信息表</caption>
    <thead>
      <tr>
        <th scope="col">姓名</th>
        <th scope="col">年龄</th>
        <th scope="col">职位</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>张三</td>
        <td>28</td>
        <td>前端工程师</td>
      </tr>
    </tbody>
  </table>
</article>
```

#### 题目2：块级元素和内联元素的区别（2分）

**完整答案：**

**块级元素（Block-level Elements）：**
- 独占一行，从新行开始，后面的元素另起一行
- 可以设置width、height、margin、padding所有属性
- 默认宽度为父容器的100%
- 可以包含其他块级元素和内联元素
- 常见元素：`<div>`、`<p>`、`<h1>-<h6>`、`<ul>`、`<ol>`、`<li>`、`<table>`、`<form>`、`<header>`、`<footer>`、`<section>`、`<article>`

**内联元素（Inline Elements）：**
- 不独占一行，与其他内联元素在同一行显示
- 设置width、height无效
- 垂直方向的padding和margin无效（水平方向有效）
- 宽高由内容决定
- 只能包含文本或其他内联元素
- 常见元素：`<span>`、`<a>`、`<strong>`、`<em>`、`<img>`、`<input>`、`<label>`、`<code>`

**特殊情况：**
- `display: inline-block`：结合两者特点，可设置宽高但不独占一行
- 替换元素（如`<img>`、`<input>`）虽为内联元素但可设置宽高

### 2. HTML5特性与存储（6分）

#### 题目1：存储方式对比（3分）

| 特性 | localStorage | sessionStorage | Cookie |
|------|-------------|----------------|--------|
| **存储大小** | 5-10MB（通常5MB） | 5-10MB（通常5MB） | 4KB |
| **生命周期** | 永久存储，除非手动清除或清除浏览器数据 | 标签页/窗口关闭时清除 | 可设置过期时间，默认会话结束时清除 |
| **作用域** | 同源（协议+域名+端口） | 同源且同一标签页/窗口 | 同源，可通过domain和path配置 |
| **与服务器通信** | 仅在客户端存储 | 仅在客户端存储 | 每次HTTP请求都会携带 |
| **API易用性** | 简单的键值对API | 简单的键值对API | 需要自己解析字符串 |
| **数据类型** | 只能存储字符串 | 只能存储字符串 | 只能存储字符串 |
| **事件监听** | 支持storage事件 | 支持storage事件 | 不支持 |

**使用建议：**
- localStorage：用户偏好设置、主题、长期缓存数据
- sessionStorage：表单临时数据、一次性令牌、页面状态
- Cookie：身份认证、跨子域共享数据、需要发送到服务器的数据

#### 题目2：HTML5新增表单特性（3分）

**新增输入类型：**
1. `email` - 邮箱输入，自动验证邮箱格式
2. `url` - URL地址输入，自动验证URL格式
3. `number` - 数字输入，可设置min/max/step属性
4. `tel` - 电话号码输入，移动端弹出数字键盘
5. `search` - 搜索框，部分浏览器显示清除按钮
6. `date` - 日期选择器（YYYY-MM-DD）
7. `time` - 时间选择器（HH:MM）
8. `datetime-local` - 本地日期时间选择器
9. `month` - 月份选择器
10. `week` - 周选择器
11. `color` - 颜色选择器
12. `range` - 滑块范围选择器

**新增表单属性：**
1. `placeholder` - 输入框提示文本
2. `required` - 必填字段验证
3. `pattern` - 正则表达式验证
4. `autofocus` - 页面加载时自动获取焦点
5. `autocomplete` - 控制自动填充（on/off/具体类型）
6. `multiple` - 允许多选（file、email类型）
7. `min/max` - 设置数值或日期的最小/最大值
8. `step` - 设置数值的步进值
9. `form` - 关联到指定form（可在form外部）
10. `formaction/formmethod` - 覆盖form的action/method

### 3. 表单属性与验证（4分）

#### 题目1：表单属性详解（2分）

**`readonly` vs `disabled`：**
- `readonly`：
  - 只读，用户不能修改但可以选中、复制
  - 可以获取焦点
  - **表单提交时会包含该字段**
  - 适用于显示不可修改的数据
- `disabled`：
  - 完全禁用，不能编辑、选中、获取焦点
  - **表单提交时不会包含该字段**
  - 通常显示为灰色
  - 适用于条件性启用的字段

**`required` vs `pattern`：**
- `required`：
  - 验证字段是否有值（非空验证）
  - 空格也算有值
  - 提交时自动验证
- `pattern`：
  - 使用正则表达式验证输入格式
  - 只在有值时验证（配合required使用）
  - 可通过title属性提供错误提示

**`placeholder` vs `value`：**
- `placeholder`：
  - 占位提示文本，灰色显示
  - 不是实际值，不会被提交
  - 输入内容后消失
- `value`：
  - 输入框的实际值
  - 会被表单提交
  - 可作为默认值

**`autocomplete`：**
- 控制浏览器自动填充行为
- 值：`on`（启用）、`off`（禁用）
- 可指定具体类型：`autocomplete="email"`、`autocomplete="current-password"`
- 对安全敏感字段建议设置为`off`

#### 题目2：表单提交分析（2分）

```html
<form action="/submit" method="post">
  <input type="text" name="a" value="test" readonly>  <!-- ✅ 会提交 -->
  <input type="text" name="b" value="test" disabled>  <!-- ❌ 不会提交 -->
  <input type="hidden" name="c" value="test">         <!-- ✅ 会提交 -->
  <input type="text" name="d" placeholder="test">     <!-- ❌ 不会提交（无value） -->
  <input type="text" name="e" value="">               <!-- ✅ 会提交（空字符串） -->
</form>
```

**提交结果：**
- **a=test**（readonly只读但会提交）
- **c=test**（hidden类型正常提交）
- **e=**（空字符串也会提交）

**不会提交：**
- b（disabled禁用不提交）
- d（只有placeholder没有value）

## 二、CSS部分（15分钟，25分）

### 3. 盒模型与布局（10分）

#### 题目1：CSS盒模型详解（4分）

**盒模型组成（由内到外）：**
1. **Content（内容区）**：实际的内容，如文本、图片
2. **Padding（内边距）**：内容与边框之间的距离
3. **Border（边框）**：围绕内边距的边框
4. **Margin（外边距）**：元素与其他元素之间的距离

**标准盒模型（W3C盒模型）：**
- `box-sizing: content-box`（默认值）
- width/height = content内容区的宽高
- 元素实际占用宽度 = width + padding-left + padding-right + border-left + border-right
- 元素实际占用高度 = height + padding-top + padding-bottom + border-top + border-bottom

**IE盒模型（怪异盒模型）：**
- `box-sizing: border-box`
- width/height = content + padding + border的总和
- 元素实际占用宽度 = width（已包含padding和border）
- 更符合直觉，Bootstrap等框架默认使用

**切换方式：**
```css
/* 全局设置为IE盒模型 */
* {
  box-sizing: border-box;
}

/* 设置为标准盒模型 */
.standard-box {
  box-sizing: content-box;
}
```

#### 题目2：元素居中方法汇总（6分）

**方法1：Flexbox（最推荐）**
```css
.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
```
适用场景：现代浏览器，最简单通用的方案

**方法2：Grid**
```css
.parent {
  display: grid;
  place-items: center;
}
/* 或者 */
.parent {
  display: grid;
  justify-content: center;
  align-content: center;
}
```
适用场景：需要网格布局的复杂页面

**方法3：绝对定位 + transform**
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```
适用场景：不知道元素宽高，需要脱离文档流

**方法4：绝对定位 + margin auto**
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  margin: auto;
  width: 200px;  /* 需要固定宽高 */
  height: 100px;
}
```
适用场景：已知元素宽高

**方法5：绝对定位 + 负margin**
```css
.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 200px;
  height: 100px;
  margin-top: -50px;  /* height的一半 */
  margin-left: -100px; /* width的一半 */
}
```
适用场景：已知元素宽高，兼容性好

**方法6：table-cell**
```css
.parent {
  display: table-cell;
  vertical-align: middle;
  text-align: center;
  width: 500px;  /* 需要设置宽度 */
  height: 500px; /* 需要设置高度 */
}
.child {
  display: inline-block;
}
```
适用场景：需要兼容IE8等老浏览器

**方法7：line-height（仅适用于单行文本）**
```css
.parent {
  height: 100px;
  line-height: 100px;
  text-align: center;
}
```
适用场景：单行文本垂直居中

### 4. CSS选择器与优先级（8分）

#### 题目1：选择器优先级计算（4分）

**优先级计算规则：**
- 内联样式：1000
- ID选择器：100
- 类选择器、属性选择器、伪类：10
- 元素选择器、伪元素：1
- 通配符、子选择器、相邻选择器等：0

**计算结果：**
```css
a) #header .nav li.active a:hover
   = (0, 1, 2, 2) = 0-1-2-2
   /* 1个ID(#header) + 2个类(.nav,.active) + 1个伪类(:hover) + 2个元素(li,a) */

b) body header nav ul li a
   = (0, 0, 0, 6) = 0-0-0-6
   /* 6个元素选择器 */

c) [data-role="navigation"] > ul > li
   = (0, 0, 1, 2) = 0-0-1-2
   /* 1个属性选择器 + 2个元素(ul,li) */

d) .main-nav .menu-item.selected
   = (0, 0, 3, 0) = 0-0-3-0
   /* 3个类选择器 */

e) nav ul li:first-child::before
   = (0, 0, 1, 4) = 0-0-1-4
   /* 1个伪类(:first-child) + 3个元素(nav,ul,li) + 1个伪元素(::before) */

f) html body div.container #content
   = (0, 1, 1, 3) = 0-1-1-3
   /* 1个ID(#content) + 1个类(.container) + 3个元素(html,body,div) */
```

**优先级从高到低排序：**
1. a) 0-1-2-2
2. f) 0-1-1-3
3. d) 0-0-3-0
4. e) 0-0-1-4
5. c) 0-0-1-2
6. b) 0-0-0-6

#### 题目2：CSS属性继承（4分）

**可继承的属性：**
1. **color** - 文本颜色
2. **font系列** - font-family、font-size、font-weight、font-style
3. **text系列** - text-align、text-indent、text-transform、letter-spacing、word-spacing
4. **line-height** - 行高
5. **visibility** - 可见性（但不是display）
6. **cursor** - 鼠标指针样式
7. **list-style** - 列表样式

**不可继承的属性：**
1. **盒模型属性** - width、height、margin、padding、border
2. **定位属性** - position、top、left、right、bottom、z-index
3. **display** - 显示类型
4. **background** - 背景相关属性
5. **float、clear** - 浮动相关
6. **overflow** - 溢出处理
7. **vertical-align** - 垂直对齐

**记忆技巧：**
- 文本相关的大多可继承
- 布局相关的大多不可继承

### 5. CSS3新特性与响应式（7分）

#### 题目1：CSS单位详解（3分）

**rem（root em）：**
- 相对于根元素（html）的字体大小
- 1rem = html的font-size值
- 使用场景：移动端适配、整体缩放、响应式设计
```css
html { font-size: 16px; }
.box { width: 10rem; } /* 160px */
```

**em：**
- 相对于父元素的字体大小
- 用于font-size时，相对于父元素；用于其他属性时，相对于自身font-size
- 使用场景：组件内部相对尺寸、按钮内边距
```css
.parent { font-size: 20px; }
.child { 
  font-size: 0.8em; /* 16px */
  padding: 1em; /* 16px */
}
```

**vw（viewport width）：**
- 视口宽度的1%
- 100vw = 视口宽度
- 使用场景：全屏布局、响应式设计、移动端适配
```css
.full-width { width: 100vw; }
.half-width { width: 50vw; }
```

**vh（viewport height）：**
- 视口高度的1%
- 100vh = 视口高度
- 使用场景：全屏高度元素、首屏展示、移动端适配
```css
.full-height { height: 100vh; }
.hero-section { min-height: 100vh; }
```

**其他视口单位：**
- `vmin`：vw和vh中的较小值
- `vmax`：vw和vh中的较大值

#### 题目2：BFC（块级格式化上下文）（4分）

**BFC触发条件：**
1. 根元素（`<html>`）
2. 浮动元素（float不为none）
3. 绝对定位元素（position为absolute或fixed）
4. display为：
   - `inline-block`
   - `table-cell`、`table-caption`
   - `flex`、`inline-flex`
   - `grid`、`inline-grid`
   - `flow-root`（专门触发BFC）
5. overflow不为visible（auto、scroll、hidden）
6. contain为layout、content或paint
7. 多列容器

**BFC的特性和作用：**
1. **内部盒子垂直排列**
2. **垂直margin会重叠**（同一个BFC内）
3. **BFC区域不会与float元素重叠**
4. **BFC内部浮动元素也参与高度计算**（清除浮动）
5. **BFC是独立容器**，内外元素互不影响

**实际应用示例：**

**1. 清除浮动：**
```css
.container {
  overflow: hidden; /* 触发BFC */
}
.float-child {
  float: left;
}
```

**2. 防止margin重叠：**
```html
<div class="bfc">
  <p>段落1</p>
</div>
<div class="bfc">
  <p>段落2</p>
</div>
```
```css
.bfc {
  overflow: hidden; /* 每个div都是BFC，内部margin不会重叠 */
}
p {
  margin: 20px 0;
}
```

**3. 自适应两栏布局：**
```html
<div class="container">
  <div class="sidebar">侧边栏</div>
  <div class="main">主内容</div>
</div>
```
```css
.sidebar {
  float: left;
  width: 200px;
  background: #f0f0f0;
}
.main {
  overflow: hidden; /* 触发BFC，不与float重叠 */
  background: #fff;
}
```

**4. 防止文字环绕：**
```css
.image {
  float: left;
  margin-right: 10px;
}
.text {
  overflow: hidden; /* BFC不与浮动元素重叠 */
}
```

## 三、JavaScript部分（25分钟，40分）

### 6. 数据类型与检测（8分）

#### 题目1：JavaScript数据类型（4分）

**基本数据类型（Primitive Types）- 7种：**
1. **undefined** - 未定义
2. **null** - 空值
3. **boolean** - 布尔值（true/false）
4. **number** - 数字（包括整数、浮点数、NaN、Infinity）
5. **string** - 字符串
6. **symbol** - 符号（ES6新增，唯一标识符）
7. **bigint** - 大整数（ES2020新增）

**引用数据类型（Reference Types）：**
- **Object** - 对象（包括普通对象、数组、函数、日期、正则等）

**准确检测类型的方法：**

```javascript
// 1. typeof操作符（基础但有缺陷）
typeof undefined    // 'undefined'
typeof null        // 'object' ⚠️ 历史bug
typeof true        // 'boolean'
typeof 42          // 'number'
typeof 'str'       // 'string'
typeof Symbol()    // 'symbol'
typeof 10n         // 'bigint'
typeof {}          // 'object'
typeof []          // 'object' ⚠️ 
typeof function(){} // 'function'

// 2. instanceof（检测原型链）
[] instanceof Array        // true
{} instanceof Object       // true
/reg/ instanceof RegExp    // true
// 注意：跨iframe时会失效

// 3. Object.prototype.toString.call()（最准确）
const getType = obj => Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();

getType(undefined)  // 'undefined'
getType(null)      // 'null'
getType(true)      // 'boolean'
getType(42)        // 'number'
getType('str')     // 'string'
getType(Symbol())  // 'symbol'
getType(10n)       // 'bigint'
getType({})        // 'object'
getType([])        // 'array'
getType(/reg/)     // 'regexp'
getType(new Date()) // 'date'
getType(Math)      // 'math'

// 4. 特定类型检测
Array.isArray([])           // true
Number.isNaN(NaN)           // true
Number.isFinite(100)        // true
Number.isInteger(10)        // true
```

#### 题目2：代码输出解释（4分）

```javascript
console.log(typeof null);           
// 输出：'object'
// 原因：JavaScript的历史bug，null的类型标签是000，与对象相同

console.log(typeof undefined);      
// 输出：'undefined'
// 原因：undefined有自己的类型

console.log(typeof []);             
// 输出：'object'
// 原因：数组是特殊的对象

console.log(typeof {});             
// 输出：'object'
// 原因：普通对象

console.log(null == undefined);     
// 输出：true
// 原因：宽松相等，null和undefined被认为相等（都表示"无值"）

console.log(null === undefined);    
// 输出：false
// 原因：严格相等，类型不同（null是object，undefined是undefined）

console.log(NaN == NaN);           
// 输出：false
// 原因：NaN的特殊性，它不等于任何值，包括自己。使用Number.isNaN()检测

console.log(0.1 + 0.2 == 0.3);    
// 输出：false
// 原因：浮点数精度问题，0.1+0.2=0.30000000000000004
// 解决：使用Number.EPSILON或toFixed()
```

### 7. this指向与call/apply/bind（10分）

#### 题目1：this指向分析（5分）

```javascript
var name = '全局';

const obj = {
    name: '对象',
    regular: function() {
        console.log('regular:', this.name);
        // 作为对象方法调用，this指向obj
        
        const inner = function() {
            console.log('inner:', this.name);
            // 普通函数调用，this指向window（严格模式下是undefined）
        };
        inner();
        
        const arrow = () => {
            console.log('arrow:', this.name);
            // 箭头函数继承外层this，指向obj
        };
        arrow();
    },
    arrow: () => {
        console.log('obj.arrow:', this.name);
        // 箭头函数定义时this指向window
    }
};

obj.regular();
// 输出：
// regular: 对象
// inner: 全局
// arrow: 对象

obj.arrow();
// 输出：
// obj.arrow: 全局

const extracted = obj.regular;
extracted();
// 输出：
// regular: 全局（函数被提取后，失去对象上下文）
// inner: 全局
// arrow: 全局

obj.regular.call({ name: '自定义' });
// 输出：
// regular: 自定义（call改变this）
// inner: 全局（inner的this不受影响）
// arrow: 自定义（arrow继承改变后的this）
```

**this指向规则总结：**
1. **默认绑定**：独立函数调用，this指向window（严格模式undefined）
2. **隐式绑定**：对象方法调用，this指向该对象
3. **显式绑定**：call/apply/bind指定this
4. **new绑定**：构造函数中this指向新创建的对象
5. **箭头函数**：继承外层作用域的this，定义时确定

#### 题目2：实现call和bind（5分）

```javascript
// 实现call
Function.prototype.myCall = function(context, ...args) {
    // 处理context为null或undefined的情况
    context = context == null ? globalThis : Object(context);
    
    // 用Symbol避免属性名冲突
    const fnSymbol = Symbol('fn');
    
    // 将函数作为context的方法
    context[fnSymbol] = this;
    
    // 调用函数
    const result = context[fnSymbol](...args);
    
    // 删除临时属性
    delete context[fnSymbol];
    
    return result;
};

// 实现apply
Function.prototype.myApply = function(context, args = []) {
    context = context == null ? globalThis : Object(context);
    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;
    const result = context[fnSymbol](...args);
    delete context[fnSymbol];
    return result;
};

// 实现bind
Function.prototype.myBind = function(context, ...args) {
    const fn = this;
    
    // 返回的函数
    const boundFn = function(...newArgs) {
        // 判断是否使用new调用
        if (new.target) {
            // new调用时，this应该是新创建的对象
            return fn.apply(this, [...args, ...newArgs]);
        }
        // 普通调用
        return fn.apply(context, [...args, ...newArgs]);
    };
    
    // 维护原型链
    if (fn.prototype) {
        boundFn.prototype = Object.create(fn.prototype);
    }
    
    return boundFn;
};

// 测试用例
function greet(greeting, punctuation) {
    return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: 'Alice' };
console.log(greet.myCall(person, 'Hello', '!')); // "Hello, Alice!"
console.log(greet.myApply(person, ['Hi', '?'])); // "Hi, Alice?"

const boundGreet = greet.myBind(person, 'Hi');
console.log(boundGreet('?')); // "Hi, Alice?"
```

### 8. 作用域与闭包（8分）

#### 题目1：循环中的闭包（4分）

```javascript
// 问题代码
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log('var:', i);
    }, 100);
}
// 输出：var: 3, var: 3, var: 3
// 原因：var是函数作用域，循环结束后i=3，所有setTimeout共享同一个i

for (let j = 0; j < 3; j++) {
    setTimeout(function() {
        console.log('let:', j);
    }, 100);
}
// 输出：let: 0, let: 1, let: 2
// 原因：let是块级作用域，每次循环创建新的j变量

// 修改第一个循环使其输出0,1,2的方法：

// 方法1：使用IIFE创建闭包
for (var i = 0; i < 3; i++) {
    (function(index) {
        setTimeout(function() {
            console.log('var:', index);
        }, 100);
    })(i);
}

// 方法2：使用setTimeout的第三个参数
for (var i = 0; i < 3; i++) {
    setTimeout(function(index) {
        console.log('var:', index);
    }, 100, i);
}

// 方法3：使用bind
for (var i = 0; i < 3; i++) {
    setTimeout(function(index) {
        console.log('var:', index);
    }.bind(null, i), 100);
}

// 方法4：使用forEach（如果是数组遍历）
[0, 1, 2].forEach(function(i) {
    setTimeout(function() {
        console.log('var:', i);
    }, 100);
});
```

#### 题目2：闭包实现私有计数器（4分）

```javascript
function createCounter(initialValue = 0) {
    // 私有变量
    let count = initialValue;
    let history = [];
    
    // 返回公共接口
    return {
        // 增加
        increment(step = 1) {
            count += step;
            history.push({ action: 'increment', value: step, result: count });
            return count;
        },
        
        // 减少
        decrement(step = 1) {
            count -= step;
            history.push({ action: 'decrement', value: step, result: count });
            return count;
        },
        
        // 获取当前值
        getValue() {
            return count;
        },
        
        // 重置
        reset(newValue = initialValue) {
            const oldValue = count;
            count = newValue;
            history.push({ action: 'reset', from: oldValue, to: count });
            return count;
        },
        
        // 获取历史记录
        getHistory() {
            return [...history]; // 返回副本，防止外部修改
        }
    };
}

// 使用示例
const counter = createCounter(10);
console.log(counter.increment());    // 11
console.log(counter.increment(5));   // 16
console.log(counter.decrement(3));   // 13
console.log(counter.getValue());     // 13
console.log(counter.reset());        // 10
console.log(counter.reset(0));       // 0
console.log(counter.getHistory());   // 查看所有操作历史

// 创建多个独立的计数器
const counter1 = createCounter();
const counter2 = createCounter(100);
// counter1和counter2相互独立
```

### 9. 原型与继承（7分）

```javascript
function Animal(name) {
    this.name = name;
    this.colors = ['white', 'black'];
}

Animal.prototype.sayName = function() {
    console.log('My name is ' + this.name);
};

function Dog(name, breed) {
    // 调用父构造函数，继承实例属性
    Animal.call(this, name);
    // 添加子类特有属性
    this.breed = breed;
}

// 继承原型方法（方式1：Object.create）
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// 或者（方式2：ES6的setPrototypeOf）
// Object.setPrototypeOf(Dog.prototype, Animal.prototype);

// 添加Dog特有的方法
Dog.prototype.bark = function() {
    console.log('Woof! I am a ' + this.breed);
};

const dog1 = new Dog('Max', 'Golden Retriever');
const dog2 = new Dog('Buddy', 'Labrador');

dog1.colors.push('brown');
console.log(dog1.colors); // ['white', 'black', 'brown']
console.log(dog2.colors); // ['white', 'black']
// 每个实例有独立的colors数组，因为在构造函数中通过Animal.call(this, name)创建

dog1.sayName(); // "My name is Max"
dog1.bark();    // "Woof! I am a Golden Retriever"

// ES6 Class语法（推荐）
class AnimalES6 {
    constructor(name) {
        this.name = name;
        this.colors = ['white', 'black'];
    }
    
    sayName() {
        console.log('My name is ' + this.name);
    }
}

class DogES6 extends AnimalES6 {
    constructor(name, breed) {
        super(name); // 调用父类构造函数
        this.breed = breed;
    }
    
    bark() {
        console.log('Woof! I am a ' + this.breed);
    }
}
```

### 10. 变量提升与执行上下文（7分）

#### 题目1：变量提升规则（4分）

```javascript
// 实际执行顺序（提升后）：
// var a; // 声明提升
// function foo() { return 'foo'; } // 函数声明完全提升
// var bar; // 声明提升
// var test; // 声明提升
// function test() {} // 函数声明提升，覆盖var声明

console.log(a);     // undefined（声明提升但未赋值）
console.log(b);     // ReferenceError: Cannot access 'b' before initialization（暂时性死区）
console.log(c);     // ReferenceError: Cannot access 'c' before initialization（暂时性死区）
console.log(foo);   // [Function: foo]（函数声明完全提升）
console.log(bar);   // undefined（var声明提升）

var a = 1;
let b = 2;
const c = 3;

function foo() {
    return 'foo';
}

var bar = function() {
    return 'bar';
};

// 函数和变量同名时的优先级
console.log(test);  // [Function: test]（函数声明优先）
var test = 1;       // 此时test被赋值为1
function test() {}  // 函数声明已经提升
console.log(test);  // 1（赋值后的结果）
```

**提升规则总结：**
1. **函数声明**：完全提升（声明+定义）
2. **var变量**：声明提升到作用域顶部，赋值留在原地
3. **let/const**：不提升，存在暂时性死区（TDZ）
4. **同名冲突**：函数声明 > var声明（但赋值会覆盖）
5. **class声明**：类似let/const，存在TDZ

#### 题目2：实现new操作符（3分）

```javascript
function myNew(Constructor, ...args) {
    // 1. 创建一个新对象，原型指向构造函数的prototype
    const obj = Object.create(Constructor.prototype);
    
    // 2. 执行构造函数，this指向新对象，获取返回值
    const result = Constructor.apply(obj, args);
    
    // 3. 如果构造函数返回对象类型，则返回该对象
    // 否则返回新创建的对象
    return result instanceof Object ? result : obj;
}

// 更完整的实现
function myNewComplete(Constructor, ...args) {
    // 检查Constructor是否是函数
    if (typeof Constructor !== 'function') {
        throw new TypeError('Constructor must be a function');
    }
    
    // 创建新对象，继承构造函数的原型
    const obj = Object.create(Constructor.prototype);
    
    // 执行构造函数
    const result = Constructor.apply(obj, args);
    
    // 判断返回值类型
    // 如果是对象（包括数组、函数等）或函数，返回它
    // 否则返回新创建的对象
    return (typeof result === 'object' && result !== null) || 
           typeof result === 'function' ? result : obj;
}

// 测试用例
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.sayHello = function() {
    console.log(`Hello, I'm ${this.name}`);
};

const person = myNew(Person, 'Alice', 20);
console.log(person.name);        // 'Alice'
console.log(person.age);         // 20
console.log(person instanceof Person); // true
person.sayHello();               // "Hello, I'm Alice"

// 测试返回对象的情况
function ReturnObj() {
    this.name = 'test';
    return { custom: 'object' };
}
const obj = myNew(ReturnObj);
console.log(obj); // { custom: 'object' }
```

**new操作符的执行过程：**
1. 创建一个新的空对象
2. 将新对象的`[[Prototype]]`（`__proto__`）指向构造函数的`prototype`
3. 将构造函数的`this`绑定到新对象并执行构造函数
4. 如果构造函数返回对象类型，返回该对象；否则返回新创建的对象

## 四、综合应用题（15分钟，20分）

### 11. 算法实现题（20分）

#### 第一部分：LeetCode算法题（10分，三选一）

**选项A：长度最小的子数组（滑动窗口）**
```javascript
function minSubArrayLen(target, nums) {
    let left = 0;
    let sum = 0;
    let minLen = Infinity;
    
    // 滑动窗口
    for (let right = 0; right < nums.length; right++) {
        sum += nums[right];
        
        // 当窗口内的和>=target时，尝试缩小窗口
        while (sum >= target) {
            minLen = Math.min(minLen, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }
    
    return minLen === Infinity ? 0 : minLen;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)

// 测试
console.log(minSubArrayLen(7, [2,3,1,2,4,3])); // 2 ([4,3])
console.log(minSubArrayLen(4, [1,4,4]));        // 1 ([4])
console.log(minSubArrayLen(11, [1,1,1,1]));     // 0
```

**选项B：螺旋矩阵 II**
```javascript
function generateMatrix(n) {
    const matrix = Array(n).fill().map(() => Array(n).fill(0));
    
    let left = 0, right = n - 1;
    let top = 0, bottom = n - 1;
    let num = 1;
    
    while (num <= n * n) {
        // 从左到右
        for (let i = left; i <= right; i++) {
            matrix[top][i] = num++;
        }
        top++;
        
        // 从上到下
        for (let i = top; i <= bottom; i++) {
            matrix[i][right] = num++;
        }
        right--;
        
        // 从右到左
        for (let i = right; i >= left; i--) {
            matrix[bottom][i] = num++;
        }
        bottom--;
        
        // 从下到上
        for (let i = bottom; i >= top; i--) {
            matrix[i][left] = num++;
        }
        left++;
    }
    
    return matrix;
}

// 时间复杂度：O(n²)
// 空间复杂度：O(n²)

// 测试
console.log(generateMatrix(3));
// [[1,2,3],
//  [8,9,4],
//  [7,6,5]]
```

**选项C：区间和（前缀和优化）**
```javascript
function rangeSum(nums, queries) {
    // 构建前缀和数组
    const n = nums.length;
    const prefixSum = new Array(n + 1).fill(0);
    
    // prefixSum[i] = nums[0] + nums[1] + ... + nums[i-1]
    for (let i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }
    
    // 处理查询
    const results = [];
    for (const [start, end] of queries) {
        // 区间[start, end]的和 = prefixSum[end+1] - prefixSum[start]
        results.push(prefixSum[end + 1] - prefixSum[start]);
    }
    
    return results;
}

// 时间复杂度：O(n + q)，n是数组长度，q是查询次数
// 空间复杂度：O(n)

// 测试
console.log(rangeSum([1, 2, 3, 4, 5], [[0, 2], [1, 3], [2, 4]]));
// [6, 9, 12]

// 二维前缀和（扩展）
function rangeSum2D(matrix, queries) {
    const m = matrix.length;
    const n = matrix[0].length;
    const prefixSum = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // 构建二维前缀和
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            prefixSum[i][j] = matrix[i-1][j-1] + 
                              prefixSum[i-1][j] + 
                              prefixSum[i][j-1] - 
                              prefixSum[i-1][j-1];
        }
    }
    
    // 查询矩形区域和
    return queries.map(([r1, c1, r2, c2]) => {
        return prefixSum[r2+1][c2+1] - 
               prefixSum[r1][c2+1] - 
               prefixSum[r2+1][c1] + 
               prefixSum[r1][c1];
    });
}
```

#### 第二部分：实用函数实现（10分，三选一）

**选项1：防抖函数（完整版）**
```javascript
function debounce(fn, delay, options = {}) {
    const { immediate = false, maxWait = null } = options;
    let timer = null;
    let lastCallTime = null;
    let lastInvokeTime = null;
    let result;
    
    const invokeFunc = function(context, args) {
        result = fn.apply(context, args);
        lastInvokeTime = Date.now();
        return result;
    };
    
    const shouldInvoke = function() {
        const now = Date.now();
        if (maxWait !== null && lastCallTime !== null) {
            return now - lastCallTime >= maxWait;
        }
        return false;
    };
    
    const debounced = function(...args) {
        const context = this;
        const now = Date.now();
        lastCallTime = now;
        
        // 清除之前的定时器
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
        
        // 立即执行
        if (immediate && !timer) {
            result = invokeFunc(context, args);
        }
        
        // 检查是否达到最大等待时间
        if (shouldInvoke()) {
            result = invokeFunc(context, args);
        }
        
        // 设置新的定时器
        timer = setTimeout(() => {
            timer = null;
            if (!immediate) {
                result = invokeFunc(context, args);
            }
        }, delay);
        
        return result;
    };
    
    // 取消防抖
    debounced.cancel = function() {
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
        lastCallTime = null;
        lastInvokeTime = null;
    };
    
    // 立即执行
    debounced.flush = function() {
        if (timer) {
            clearTimeout(timer);
            const args = arguments;
            result = invokeFunc(this, args);
            timer = null;
        }
        return result;
    };
    
    return debounced;
}

// 使用示例
const search = debounce((query) => {
    console.log('Searching for:', query);
}, 500, { immediate: false });

// 节流函数（补充）
function throttle(fn, delay, options = {}) {
    const { leading = true, trailing = true } = options;
    let timer = null;
    let lastCallTime = 0;
    
    return function(...args) {
        const context = this;
        const now = Date.now();
        
        if (!lastCallTime && !leading) {
            lastCallTime = now;
        }
        
        const remaining = delay - (now - lastCallTime);
        
        if (remaining <= 0 || remaining > delay) {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            lastCallTime = now;
            fn.apply(context, args);
        } else if (!timer && trailing) {
            timer = setTimeout(() => {
                lastCallTime = leading ? Date.now() : 0;
                timer = null;
                fn.apply(context, args);
            }, remaining);
        }
    };
}
```

**选项2：深拷贝（完整版）**
```javascript
function deepClone(obj, map = new WeakMap()) {
    // 基本类型和null直接返回
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    // 检查循环引用
    if (map.has(obj)) {
        return map.get(obj);
    }
    
    // 处理特殊对象类型
    const type = Object.prototype.toString.call(obj);
    
    // 日期对象
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    
    // 正则对象
    if (obj instanceof RegExp) {
        const flags = obj.flags;
        return new RegExp(obj.source, flags);
    }
    
    // Map
    if (obj instanceof Map) {
        const cloned = new Map();
        map.set(obj, cloned);
        obj.forEach((value, key) => {
            cloned.set(deepClone(key, map), deepClone(value, map));
        });
        return cloned;
    }
    
    // Set
    if (obj instanceof Set) {
        const cloned = new Set();
        map.set(obj, cloned);
        obj.forEach(value => {
            cloned.add(deepClone(value, map));
        });
        return cloned;
    }
    
    // ArrayBuffer
    if (obj instanceof ArrayBuffer) {
        const cloned = new ArrayBuffer(obj.byteLength);
        new Uint8Array(cloned).set(new Uint8Array(obj));
        return cloned;
    }
    
    // TypedArray
    if (ArrayBuffer.isView(obj)) {
        const cloned = new obj.constructor(obj);
        return cloned;
    }
    
    // 函数（通常不需要深拷贝函数）
    if (typeof obj === 'function') {
        return obj; // 或者使用eval(obj.toString())，但不推荐
    }
    
    // 数组
    if (Array.isArray(obj)) {
        const cloned = [];
        map.set(obj, cloned);
        obj.forEach((item, index) => {
            cloned[index] = deepClone(item, map);
        });
        return cloned;
    }
    
    // 普通对象
    const cloned = Object.create(Object.getPrototypeOf(obj));
    map.set(obj, cloned);
    
    // 拷贝所有属性（包括不可枚举属性和Symbol属性）
    Reflect.ownKeys(obj).forEach(key => {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
            if (descriptor.value !== undefined) {
                descriptor.value = deepClone(descriptor.value, map);
            }
            Object.defineProperty(cloned, key, descriptor);
        }
    });
    
    return cloned;
}

// 测试
const original = {
    num: 42,
    str: 'hello',
    date: new Date(),
    regex: /test/gi,
    arr: [1, 2, { nested: true }],
    map: new Map([['key', 'value']]),
    set: new Set([1, 2, 3]),
    fn: function() { console.log('test'); },
    [Symbol('sym')]: 'symbol value'
};

// 添加循环引用
original.circular = original;

const cloned = deepClone(original);
console.log(cloned);
console.log(cloned.circular === cloned); // true
```

**选项3：数组扁平化（多种实现）**
```javascript
// 方法1：递归实现
function flatten(arr, depth = 1) {
    if (depth <= 0) return arr.slice();
    
    return arr.reduce((result, item) => {
        if (Array.isArray(item)) {
            result.push(...flatten(item, depth - 1));
        } else {
            result.push(item);
        }
        return result;
    }, []);
}

// 方法2：迭代实现
function flattenIterative(arr, depth = 1) {
    let result = [...arr];
    let currentDepth = 0;
    
    while (currentDepth < depth) {
        let hasNestedArray = false;
        const newResult = [];
        
        for (const item of result) {
            if (Array.isArray(item)) {
                newResult.push(...item);
                hasNestedArray = true;
            } else {
                newResult.push(item);
            }
        }
        
        result = newResult;
        if (!hasNestedArray) break;
        currentDepth++;
    }
    
    return result;
}

// 方法3：生成器实现（内存效率高）
function* flattenGenerator(arr, depth = 1) {
    for (const item of arr) {
        if (Array.isArray(item) && depth > 0) {
            yield* flattenGenerator(item, depth - 1);
        } else {
            yield item;
        }
    }
}

// 方法4：使用栈（不使用递归）
function flattenStack(arr, depth = Infinity) {
    const stack = arr.map((item, index) => [item, depth]);
    const result = [];
    
    while (stack.length > 0) {
        const [item, currentDepth] = stack.pop();
        
        if (Array.isArray(item) && currentDepth > 0) {
            stack.push(...item.map(subItem => [subItem, currentDepth - 1]));
        } else {
            result.unshift(item);
        }
    }
    
    return result;
}

// 方法5：正则表达式（仅适用于基本类型）
function flattenRegex(arr) {
    let str = JSON.stringify(arr);
    while (str.includes('[')) {
        str = str.replace(/\[|\]/g, '');
    }
    return JSON.parse('[' + str + ']');
}

// 测试
const nested = [1, [2, [3, [4, [5]]]]];
console.log(flatten(nested, 2));        // [1, 2, 3, [4, [5]]]
console.log(flatten(nested, Infinity)); // [1, 2, 3, 4, 5]
console.log([...flattenGenerator(nested, 3)]); // [1, 2, 3, 4, [5]]

// 处理特殊情况
const special = [1, , [2, undefined, [3, null, [4]]], NaN];
console.log(flatten(special, Infinity)); // [1, undefined, 2, undefined, 3, null, 4, NaN]
```

---

## 答题要求

1. **时间分配**：
   - HTML：10分钟
   - CSS：15分钟
   - JavaScript：25分钟
   - 综合题：10分钟

2. **评分标准**：
   - HTML：15分
   - CSS：25分
   - JavaScript：40分
   - 综合应用：20分
   - 总分：100分

3. **注意事项**：
   - 优先完成熟悉的题目，确保基础分
   - JavaScript部分重点考察基础概念理解
   - 算法题选择两道完成即可
   - 注意代码的规范性和可读性
   - 时间控制很重要，避免在单题停留过久

**考试时间：60分钟 | 满分：100分**