# 前端面试题 - 参考答案（满分120分）

## 一、HTML部分（15分）

### 1. 页面组成（8分）

**答案：**
前端页面由三部分组成：

1. **HTML（结构层）**：
   - 负责页面的结构和内容
   - 定义网页的语义化标签
   - 提供页面的骨架，如标题、段落、列表、表格、表单等

2. **CSS（表现层）**：
   - 负责页面的样式、布局和视觉效果
   - 控制元素的颜色、字体、间距、位置、动画等
   - 实现响应式设计和美化界面

3. **JavaScript（行为层）**：
   - 负责页面的交互逻辑和动态效果
   - 处理用户事件、DOM操作、数据处理
   - 实现与服务器的异步通信（Ajax）

### 2. 路由模式（7分）

**答案：**

**区别：**
- **hash模式**：URL中带有#号（如：`example.com/#/user`），通过监听hashchange事件来实现路由切换，不会向服务器发送请求
- **history模式**：URL格式正常（如：`example.com/user`），使用HTML5 History API（pushState、replaceState），刷新页面会向服务器发送请求

**优缺点：**

**hash模式：**
- 优点：
  - 兼容性好，支持所有浏览器
  - 无需服务器配置，部署简单
  - 页面刷新不会404
- 缺点：
  - URL不美观，带有#号
  - 不利于SEO优化
  - 不能使用锚点定位功能

**history模式：**
- 优点：
  - URL美观，符合正常URL规范
  - 有利于SEO优化
  - 可以使用浏览器的前进后退功能
- 缺点：
  - 需要服务器配置支持（nginx配置try_files）
  - 刷新页面可能出现404错误
  - 兼容性要求IE10+

## 二、CSS部分（15分）

### 3. BFC（7分）

**答案：**

**BFC是什么：**
BFC（Block Formatting Context）块格式化上下文，是一个独立的渲染区域，内部元素的布局不会影响外部元素，同时外部元素也不会影响内部元素。

**触发BFC的条件：**
1. 根元素（`<html>`）
2. 浮动元素（float不为none）
3. 绝对定位元素（position为absolute或fixed）
4. display为inline-block、table-cell、table-caption、flex、inline-flex、grid、inline-grid
5. overflow不为visible（hidden、auto、scroll）
6. contain为layout、content或paint
7. display: flow-root

**BFC应用场景：**
1. **清除浮动**：父元素设置BFC可以包含浮动子元素
2. **防止margin重叠**：相邻块级元素的垂直margin会重叠，BFC可以阻止
3. **自适应两栏布局**：BFC区域不会与float元素重叠

### 4. 居中布局（8分）

**答案：**

**5种居中方法：**

```css
/* 1. Flexbox（最常用） */
.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}

/* 2. Grid */
.parent {
    display: grid;
    place-items: center;
}

/* 3. 绝对定位 + transform */
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

/* 4. 绝对定位 + margin auto（需要固定宽高） */
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    margin: auto;
    width: 200px;
    height: 100px;
}

/* 5. table-cell */
.parent {
    display: table-cell;
    vertical-align: middle;
    text-align: center;
}
.child {
    display: inline-block;
}
```

**宽高固定和不固定的实现：**

宽高固定：
- 可以使用绝对定位 + margin auto
- 可以使用绝对定位 + 负margin（top: 50%; left: 50%; margin-top: -50px; margin-left: -100px;）

宽高不固定：
- 推荐使用flexbox或grid
- 使用transform: translate(-50%, -50%)
- 使用table-cell方式

## 三、JavaScript基础（45分）

### 5. 变量声明（12分）

**答案：**

**定义变量的方式：**
- var、let、const、function、class、import

**let、const、var的区别：**

| 特性 | var | let | const |
|------|-----|-----|-------|
| 作用域 | 函数作用域 | 块级作用域 | 块级作用域 |
| 变量提升 | 存在（声明提升） | 不存在（暂时性死区） | 不存在（暂时性死区） |
| 重复声明 | 可以 | 不可以 | 不可以 |
| 重新赋值 | 可以 | 可以 | 不可以 |
| 初始化 | 可选 | 可选 | 必须 |

**const原理：**
const声明创建一个值的只读引用。对于基本类型，值本身不可改变；对于引用类型，引用地址不可改变，但对象内容可以修改。

**const定义的对象：**
```javascript
const obj = { name: 'John' };
obj.name = 'Jane';  // 可以修改属性
obj.age = 25;       // 可以添加属性
// obj = {};        // 错误！不能重新赋值
```

**var特性和结果：**
```javascript
console.log(a); // undefined（变量提升）
var a = 1;
```

**代码分析：**
```javascript
// 情况1：SyntaxError: Identifier 'a' has already been declared
let a = 1; 
let a = 2;

// 情况2：正常执行，a = 2
var a = 1; 
var a = 2;

// 情况3：SyntaxError: Identifier 'a' has already been declared
var a = 1; 
let a = 2;

// 情况4：SyntaxError: Unexpected token 'null'（null是保留字）
let null = 1;
```

### 6. 数据类型与存储（8分）

**答案：**

**基本数据类型：**
7种基本类型：Number、String、Boolean、Null、Undefined、Symbol、BigInt

**存储位置：**
- **栈内存**：基本数据类型直接存储在栈中
- **堆内存**：引用类型（Object、Array、Function等）存储在堆中，栈中存储指向堆内存的指针

**代码分析：**
```javascript
let a = {}; 
b = a;  // b和a指向同一个对象，修改b会影响a

// 避免方法（深拷贝）：
// 1. JSON方法（有限制）
let b = JSON.parse(JSON.stringify(a));

// 2. 递归深拷贝
function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof Array) return obj.map(item => deepClone(item));
    const cloned = {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloned[key] = deepClone(obj[key]);
        }
    }
    return cloned;
}

// 3. structuredClone（新API）
let b = structuredClone(a);

// 4. 第三方库
let b = _.cloneDeep(a); // lodash
```

### 7. 作用域与闭包（6分）

**答案：**

**作用域：**
作用域是变量和函数的可访问范围，决定了代码中变量的可见性和生命周期。

JavaScript有三种作用域：
1. **全局作用域**：在代码任何地方都能访问
2. **函数作用域**：在函数内部声明的变量只能在函数内部访问
3. **块级作用域**：ES6引入，let和const声明的变量在{}内有效

**作用域链：**
当查找变量时，JavaScript引擎会从当前作用域开始查找，如果没有找到，就向上级作用域查找，直到全局作用域。这个查找过程形成的链条就是作用域链。

```javascript
var global = 'global';
function outer() {
    var outer = 'outer';
    function inner() {
        var inner = 'inner';
        console.log(inner);  // 查找顺序：inner作用域
        console.log(outer);  // 查找顺序：inner → outer作用域
        console.log(global); // 查找顺序：inner → outer → global作用域
    }
    inner();
}
```

**闭包：**
闭包是指函数可以访问其外部作用域的变量，即使外部函数已经执行完毕。

```javascript
function createCounter() {
    let count = 0;
    return function() {
        return ++count;
    };
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

### 8. 事件委托（4分）

**答案：**

**事件委托：**
事件委托是利用事件冒泡机制，将子元素的事件处理委托给父元素处理的技术。

**原理：**
基于DOM事件冒泡机制，事件会从目标元素向上传播到父元素，在父元素上统一处理子元素的事件。

**优势：**
1. 减少内存占用（只需一个事件处理器）
2. 动态添加的元素自动拥有事件处理
3. 减少事件绑定，提高性能

**代码分析：**
```javascript
// 原代码：点击每项都会输出对应的0,1,2,3,4（let有块级作用域）

// 事件委托改写：
const list = document.getElementById('list');
// 先添加li元素
for (let i = 0; i < 5; i++) {
    const li = document.createElement('li');
    li.textContent = `Item ${i}`;
    li.dataset.index = i; // 存储索引
    list.appendChild(li);
}
// 事件委托
list.addEventListener('click', function(e) {
    if (e.target.tagName === 'LI') {
        console.log(e.target.dataset.index);
    }
});
```

### 9. 异步编程（8分）

**答案：**

**同步和异步：**
- **同步**：代码按顺序执行，当前任务完成后才执行下一个任务，会阻塞后续代码
- **异步**：不阻塞后续代码执行，通过回调、Promise或async/await处理结果

**异步使用场景：**
1. 网络请求（Ajax、Fetch、Axios）
2. 定时器（setTimeout、setInterval）
3. 文件操作（Node.js）
4. 事件处理（用户交互）
5. 资源加载（图片、脚本）

**异步结果给同步使用：**
```javascript
// 1. async/await（推荐）
async function getData() {
    const result = await fetch('/api/data');
    const data = await result.json();
    return data; // 可以像同步一样使用
}

// 2. Promise.then()
fetch('/api/data')
    .then(res => res.json())
    .then(data => {
        // 在这里使用data
    });

// 3. 回调函数
function fetchData(callback) {
    setTimeout(() => {
        callback('data');
    }, 1000);
}
```

**Promise方法区别：**
- **.then()**：处理Promise成功（resolved）的结果
- **.catch()**：处理Promise失败（rejected）的结果或捕获错误

**await使用场景：**
- 必须在async函数内使用
- 等待Promise结果，使异步代码看起来像同步
- 需要按顺序执行多个异步操作时

### 10. 运算符与类型（5分）

**答案：**

**== 和 === 的区别：**
- **==**：相等运算符，比较时会进行类型转换
- **===**：严格相等运算符，不进行类型转换，类型和值都必须相同

**typeof和instanceof的区别：**
- **typeof**：返回一个字符串，表示操作数的类型
  ```javascript
  typeof 123 // "number"
  typeof {} // "object"
  typeof [] // "object"（注意）
  typeof null // "object"（历史bug）
  ```
- **instanceof**：检测对象的原型链上是否存在构造函数的prototype
  ```javascript
  [] instanceof Array // true
  {} instanceof Object // true
  ```

**表达式结果：**
```javascript
false == '0'        // true（都转换为0）
false == undefined  // false（undefined只与null相等）
null == undefined   // true（特殊规定）
```

### 11. 内置对象方法（6分）

**答案：**

**String常用方法：**
1. `slice(start, end)` - 提取字符串片段
2. `substring(start, end)` - 提取子字符串
3. `substr(start, length)` - 提取指定长度的子字符串
4. `split(separator)` - 分割成数组
5. `replace(search, replacement)` - 替换内容
6. `indexOf(searchValue)` - 查找位置
7. `trim()` - 去除首尾空格
8. `toLowerCase()/toUpperCase()` - 大小写转换

**数组方法作用：**
- **pop()**：删除并返回数组最后一个元素
- **push()**：在数组末尾添加元素，返回新长度
- **shift()**：删除并返回数组第一个元素
- **unshift()**：在数组开头添加元素，返回新长度
- **split()**：字符串方法，将字符串分割成数组
- **join()**：将数组元素连接成字符串

**Array增删改查方法：**
- **增**：push()、unshift()、concat()、spread(...)
- **删**：pop()、shift()、splice()、filter()
- **改**：splice()、map()、forEach()、fill()
- **查**：find()、findIndex()、includes()、indexOf()、some()、every()

## 四、Vue框架（25分）

### 12. Vue基础（10分）

**答案：**

**v-if和v-show的区别：**

| 特性 | v-if | v-show |
|------|------|---------|
| 渲染方式 | 条件渲染，false时不渲染DOM | 始终渲染，通过display控制显示 |
| 切换开销 | 高（需要销毁/重建DOM） | 低（只改变CSS） |
| 初始开销 | 低（false时不渲染） | 高（总是渲染） |
| 使用场景 | 切换频率低，条件很少改变 | 频繁切换显示状态 |

**nextTick：**
- **作用**：在DOM更新循环结束后执行回调函数，用于获取更新后的DOM
- **原理**：Vue的DOM更新是异步的，nextTick利用微任务（Promise.then、MutationObserver）或宏任务（setTimeout）在DOM更新后执行回调

```javascript
// 使用示例
this.message = 'changed';
this.$nextTick(() => {
    // DOM已更新，可以访问更新后的DOM
    console.log(this.$refs.msg.textContent);
});
```

**v-model原理：**
v-model本质是语法糖，等价于：
```javascript
// 原生元素
<input v-model="value" />
// 等价于
<input :value="value" @input="value = $event.target.value" />

// 自定义组件（Vue2）
<custom-input v-model="value" />
// 等价于
<custom-input :value="value" @input="value = $event" />

// 自定义组件实现（Vue3）
// 父组件
<custom-input v-model="modelValue" />
// 子组件
props: ['modelValue'],
emits: ['update:modelValue'],
// 触发更新
this.$emit('update:modelValue', newValue)
```

### 13. Vue响应式（8分）

**答案：**

**Vue2响应式：**
- **核心**：Object.defineProperty劫持对象属性的getter/setter
- **依赖收集**：getter中通过Dep收集依赖的Watcher
- **派发更新**：setter中通过Dep.notify()通知Watcher更新
- **缺陷**：
  1. 无法检测数组索引和长度的变化
  2. 无法检测对象属性的添加和删除
  3. 需要递归遍历对象，初始化性能差

**Vue3响应式：**
- **核心**：Proxy代理整个对象，Reflect操作对象
- **响应式API**：reactive（对象）、ref（基本类型）、computed、watch
- **依赖收集**：effect副作用函数，track收集依赖，trigger触发更新
- **优势**：
  1. 可以监听数组索引和length变化
  2. 可以监听属性的添加和删除
  3. 惰性监听，性能更好
  4. 更好的TypeScript支持

**主要区别：**
1. 实现原理：Object.defineProperty vs Proxy
2. API设计：选项式API vs 组合式API
3. 性能优化：Vue3编译时优化更多（静态提升、事件缓存、Block Tree）
4. TypeScript支持：Vue3原生支持更好

### 14. 虚拟DOM（7分）

**答案：**

**虚拟DOM的作用：**
1. **性能优化**：批量更新，减少真实DOM操作，提升性能
2. **跨平台**：抽象层可以渲染到不同平台（Web、Native、小程序）
3. **函数式编程**：将UI作为状态的函数映射，便于测试和调试
4. **diff算法**：通过对比新旧虚拟DOM树，精确更新变化的部分

**Vue的diff算法：**
1. **同层比较**：只比较同一层级的节点，不跨层级比较
2. **双端比较**：使用四个指针（新旧列表的头尾）进行比较
3. **就地复用**：通过key标识节点，尽可能复用DOM

比较过程：
- 头头比较、尾尾比较
- 头尾交叉比较
- 通过key建立索引map查找

**key的作用：**
1. **唯一标识**：帮助Vue识别哪些元素是相同的
2. **提高性能**：避免不必要的DOM操作
3. **保持状态**：在组件切换时保持组件状态
4. **注意事项**：不要使用index作为key（当列表顺序变化时会导致问题）

## 五、综合实践题（20分）

### 15. 性能优化（5分）

**答案：**

**加载优化：**
1. **代码分割**：路由懒加载、动态import()
2. **资源压缩**：gzip/brotli压缩、图片压缩
3. **CDN加速**：静态资源使用CDN
4. **缓存策略**：HTTP缓存、Service Worker

**渲染优化：**
5. **虚拟列表**：大数据量列表使用虚拟滚动
6. **防抖节流**：优化高频事件
7. **CSS优化**：减少重排重绘、使用transform代替top/left
8. **懒加载**：图片懒加载、组件懒加载

**代码优化：**
9. **Tree Shaking**：移除未使用代码
10. **减少打包体积**：按需引入、代码压缩

### 16. 防抖和节流（8分）

**答案：**

**防抖（debounce）：**
- **原理**：事件触发后等待n秒执行，如果n秒内再次触发，重新计时
- **实现**：
```javascript
function debounce(fn, delay) {
    let timer = null;
    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    };
}
```

**节流（throttle）：**
- **原理**：规定时间内只执行一次，稀释执行频率
- **实现**：
```javascript
function throttle(fn, delay) {
    let lastTime = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastTime >= delay) {
            fn.apply(this, args);
            lastTime = now;
        }
    };
}
```

**使用场景：**

**防抖场景：**
- 搜索框输入（用户停止输入后才搜索）
- 窗口resize（调整完成后重新计算）
- 表单验证（停止输入后验证）
- 按钮提交（防止重复提交）

**节流场景：**
- 滚动事件（scroll）
- 鼠标移动（mousemove）
- 页面滚动加载（下拉加载更多）
- 播放进度更新

### 17. 深拷贝（7分）

**答案：**

**其他深拷贝方法：**
1. `JSON.parse(JSON.stringify(obj))` - 简单但有限制（不能处理函数、undefined、Symbol等）
2. `structuredClone(obj)` - 新的Web API，功能更完善
3. `lodash.cloneDeep(obj)` - 第三方库，功能完整

**手撕深拷贝函数：**
```javascript
function deepClone(obj) {
    // 处理null和非对象类型
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    // 处理日期对象
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    
    // 处理正则对象
    if (obj instanceof RegExp) {
        return new RegExp(obj);
    }
    
    // 处理数组
    if (obj instanceof Array) {
        const cloneArr = [];
        for (let i = 0; i < obj.length; i++) {
            cloneArr[i] = deepClone(obj[i]);
        }
        return cloneArr;
    }
    
    // 处理普通对象
    const cloneObj = {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloneObj[key] = deepClone(obj[key]);
        }
    }
    
    return cloneObj;
}

// 测试用例
const obj = {
    a: 1,
    b: { c: 2, d: [3, 4] },
    e: [5, { f: 6 }]
};
const cloned = deepClone(obj);
console.log(cloned);
console.log(cloned.b === obj.b); // false，确认是深拷贝
```

## 六、算法题（15分）

### 18. 有效的括号（15分）

**答案：**

```javascript
function isValid(s) {
    // 如果字符串长度为奇数，肯定不匹配
    if (s.length % 2 !== 0) return false;
    
    // 使用栈来存储左括号
    const stack = [];
    
    // 定义括号映射关系
    const map = {
        ')': '(',
        '}': '{',
        ']': '['
    };
    
    // 遍历字符串
    for (let char of s) {
        if (char in map) {
            // 如果是右括号，检查栈顶是否匹配
            if (stack.pop() !== map[char]) {
                return false;
            }
        } else {
            // 如果是左括号，入栈
            stack.push(char);
        }
    }
    
    // 栈为空说明所有括号都匹配
    return stack.length === 0;
}

// 测试
console.log(isValid("()"));       // true
console.log(isValid("()[]{}"));   // true
console.log(isValid("(]"));       // false
console.log(isValid("([)]"));     // false
console.log(isValid("{[]}"));     // true
```

**算法思路：**
1. 使用栈数据结构
2. 遇到左括号入栈
3. 遇到右括号时，检查栈顶是否为对应的左括号
4. 最后检查栈是否为空

**时间复杂度**：O(n)
**空间复杂度**：O(n)