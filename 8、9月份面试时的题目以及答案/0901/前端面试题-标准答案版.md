# 前端面试题 - 标准答案版（60分钟，100分）

**姓名：_________  日期：_________**

## 一、HTML部分（10分钟，10分）

### 1. H5兼容性（4分）
1. 在实际H5开发中，你遇到过哪些兼容性问题？请列举至少3个并说明解决方案（4分）

**答案：**
```
1. iOS Safari固定定位问题
   问题：当软键盘弹出时，position（位置）:fixed(固定)会失效，导致固定元素错位
   解决：使用transform（变换）定位或absolute（绝对）模拟，监听键盘事件动态调整

2. 移动端1px边框问题
   问题：在高清屏（2x、3x）下，1px边框会显示过粗
   解决：使用transform:scale（规模）(0.5)缩放或使用伪元素+transform实现

3. iOS点击300ms延迟
   问题：移动端Safari为了识别双击缩放，点击事件有300ms延迟
   解决：使用FastClick库或设置viewport的width=device-width
```

### 2. 浏览器存储（6分）
1. 浏览器的存储方式有哪些？请从存储大小、生命周期、作用域等方面对比（3分）

**答案：**
```
Cookie:   4KB（注意单位）可设置过期时间 同源策略，可设置path/domain  
每次请求携带
LocalStorage:   5-10MB  永久存储，手动删除     同源下所有页面共享          仅客户端
SessionStorage: 5-10MB  页面会话期间          同源的同一标签页            页面独立
IndexedDB:      无限制  永久存储              同源策略                    异步API
```

2. localStorage和sessionStorage有什么区别？（2分）

**答案：**
```
localStorage: 永久存储，除非手动删除；所有同源窗口共享；适合存储用户配置
sessionStorage: 关闭标签页即清除；仅当前标签页可访问；适合存储临时数据
```

3. sessionStorage的存储时效性，如果刷新了页面，它存储的内容会丢失吗？（1分）

**答案：**
```
不会丢失。sessionStorage在页面刷新时会保留，只有关闭标签页才会清除
```

## 二、CSS部分（10分钟，13分）

### 3. 响应式布局（4分）
1. 怎么实现响应式布局？请列举至少4种方案并说明其优缺点（4分）

**答案：**
```
1. 媒体查询(Media Queries)
   优点：精确控制不同屏幕下的样式，兼容性好
   缺点：需要写多套CSS，维护成本高

2. 百分比布局
   优点：简单直观，自动适应父容器
   缺点：高度百分比计算复杂，需要父元素有明确高度

3. rem/em单位
   优点：只需改变根字体大小即可整体缩放
   缺点：需要计算转换，可能影响文字可读性

4. Flexbox/Grid布局
   优点：强大灵活，易于实现复杂布局
   缺点：Grid兼容性相对较差(IE11部分支持)
```

### 4. 单位转换（4分）
1. rem是怎么转换成px的？如何在项目中配置rem适配方案？（4分）

**答案：**
```
转换原理：
1rem = html元素的font-size值
例如：html { font-size: 16px; } 则 1rem = 16px

项目配置方案：
1. 动态设置根字体：
   const setRem = () => {
     const width = document.documentElement.clientWidth;
     const rem = width / 10; // 设计稿宽度除以10
     document.documentElement.style.fontSize = rem + 'px';
   }

2. 使用postcss-pxtorem插件自动转换px为rem

3. 配合flexible.js或amfe-flexible库使用
```

### 5. Flex布局（5分）
1. 请详细说明flex布局的核心属性，包括容器属性和项目属性（3分）

**答案：**
```
容器属性：
- display: flex盒子独占一行/inline-flex
- flex-direction（排列方向）: row/column/row-reverse/column-reverse
- flex-wrap（是否换行）: nowrap/wrap/wrap-reverse
- justify-content（主轴对齐）: flex-start/flex-end/center/space-between/space-around/space-evenly
- align-items（交叉轴对齐）: flex-start/flex-end/center/baseline/stretch
- align-content: 多行对齐方式

项目属性：
- flex-grow（放大比例）: 放大比例，默认0
- flex-shrink（缩小比例）: 缩小比例，默认1
- flex-basis: 项目基础大小
- flex: grow shrink basis的简写
- align-self: 单个项目对齐方式
- order: 排序，数值越小越靠前
```

2. 使用flex实现一个圣杯布局（左右固定，中间自适应）（2分）

**答案：**
```css
.container {
    display: flex;
    min-height: 100vh;
}
.left {
    width: 200px;
    background: #f0f0f0;
}
.center {
    flex: 1;
    background: #fff;
}
.right {
    width: 200px;
    background: #f0f0f0;
}
```

## 三、JavaScript部分（20分钟，37分）

### 7. 内存管理（4分）
1. 说下堆和栈的区别，并举例说明JavaScript中哪些数据存储在堆中，哪些存储在栈中（4分）

**答案：**
```
栈(Stack)：
- 存储基本类型：Number、String、Boolean、Undefined、Null、Symbol、BigInt
- 特点：固定大小、自动分配释放、后进先出、存取速度快
- 示例：let a = 10; let b = 'hello'; // 值直接存在栈中

堆(Heap)：
- 存储引用类型：Object、Array、Function、Date、RegExp、Map、Set等
- 特点：大小不固定、动态分配、需要垃圾回收、存取相对慢
- 示例：let obj = {name: 'Tom'}; // 对象存在堆中，栈中存储堆地址

区别：
1. 栈由系统自动管理，堆需要垃圾回收机制
2. 栈内存连续，堆内存不连续
3. 栈有大小限制(约1MB)，堆理论上无限制
```

### 8. 进程与线程（4分）
1. 解释进程和线程的区别，并说明浏览器中的进程和线程架构（4分）

**答案：**
```
进程与线程区别：
- 进程：独立的内存空间，资源分配基本单位，切换开销大
- 线程：共享进程资源，CPU调度基本单位，切换开销小

浏览器进程架构：
1. Browser进程：主进程，负责界面显示、用户交互、子进程管理
2. Renderer进程：渲染进程，每个标签页一个，包含：
   - GUI渲染线程：负责页面渲染
   - JS引擎线程：执行JavaScript（与GUI互斥）
   - 定时器线程：setTimeout/setInterval
   - 事件触发线程：管理事件循环
   - 异步HTTP请求线程：XMLHttpRequest
3. GPU进程：3D绘制、硬件加速
4. Network进程：网络资源加载
5. Plugin进程：插件运行
```

### 9. 事件循环（10分）
1. 说下事件循环机制，画出事件循环的流程图（5分）

**答案：**
```
事件循环机制：
JavaScript是单线程语言，通过事件循环实现异步操作

执行流程：
1. 执行全局同步代码
2. 执行栈清空后，检查微任务队列
3. 执行所有微任务
4. 如需要，渲染页面
5. 执行一个宏任务
6. 重复步骤2-5

流程图：
┌───────────────┐
│   Call Stack  │ ← 执行同步代码
└───────┬───────┘
        ↓ 清空
┌───────────────┐
│  Microtasks   │ ← Promise.then、MutationObserver
└───────┬───────┘
        ↓ 全部执行
┌───────────────┐
│    Render     │ ← 浏览器渲染
└───────┬───────┘
        ↓
┌───────────────┐
│  Macrotask    │ ← setTimeout、setInterval
└───────────────┘
        ↑
        └──────── 循环
```

2. 说下宏任务、微任务都有哪些？执行顺序是怎样的？（3分）

**答案：**
```
宏任务(Macrotask)：
- setTimeout、setInterval
- setImmediate(Node.js)
- I/O操作
- UI渲染
- MessageChannel

微任务(Microtask)：
- Promise.then/catch/finally
- async/await(实际是Promise)
- MutationObserver
- queueMicrotask
- process.nextTick(Node.js，优先级最高)

执行顺序：
同步代码 → 清空所有微任务 → 渲染 → 执行一个宏任务 → 清空所有微任务 → 循环
```

3. 分析以下代码的输出顺序（2分）

**答案：**
```
输出顺序：1 6 4 2 3 5

执行分析：
1. 执行console.log('1') → 输出1
2. setTimeout加入宏任务队列(宏1)
3. Promise.then加入微任务队列(微1)
4. 执行console.log('6') → 输出6
5. 执行微任务(微1) → 输出4，setTimeout加入宏任务队列(宏2)
6. 执行宏任务(宏1) → 输出2，Promise.then加入微任务队列(微2)
7. 执行微任务(微2) → 输出3
8. 执行宏任务(宏2) → 输出5
```

### 10. Promise原理（12分）
1. 介绍一下Promise，它解决了什么问题？（2分）

**答案：**
```
Promise是ES6引入的异步编程解决方案，表示一个异步操作的最终结果

三种状态：
- pending(进行中)
- fulfilled(已成功)
- rejected(已失败)

解决的问题：
1. 回调地狱：通过链式调用解决嵌套问题
2. 错误处理：统一的catch处理错误
3. 并发控制：Promise.all、Promise.race等方法
4. 可读性：代码结构更清晰
```

2. 为什么Promise可以一直.then？请解释链式调用的原理（4分）

**答案：**
```
链式调用原理：
1. then方法返回一个新的Promise对象
2. 新Promise的状态由then的回调函数决定：
   - 返回普通值 → 新Promise变为fulfilled，值为返回值
   - 返回Promise → 新Promise采用返回的Promise的状态
   - 抛出异常 → 新Promise变为rejected
   - 没有返回值 → 新Promise变为fulfilled，值为undefined

示例：
promise.then(value => {
    return 123; // 返回新Promise，状态fulfilled，值123
}).then(value => {
    console.log(value); // 123
    return Promise.reject('error'); // 返回rejected的Promise
}).catch(err => {
    console.log(err); // 'error'
});
```

3. Promise.all和Promise.race有什么区别？（3分）

**答案：**
```
Promise.all：
- 接收Promise数组，返回新Promise
- 全部成功才成功，返回所有结果数组
- 一个失败就失败，返回第一个失败原因
- 用途：并发请求，需要全部完成

Promise.race：
- 接收Promise数组，返回新Promise
- 返回最快改变状态的Promise结果
- 不管成功失败，只要最快
- 用途：超时控制、竞速请求
```

4. Promise.all是串行还是并行？为什么Promise.all是并行处理却可以做到按序返回结果？（3分）

**答案：**
```
Promise.all是并行执行的

按序返回原理：
1. 创建结果数组results和计数器count
2. 遍历输入数组，记录每个Promise的索引
3. 所有Promise同时开始执行（并行）
4. 每个Promise完成时，将结果存入results[index]
5. count++，当count等于数组长度时，resolve(results)
6. 虽然完成时间不同，但结果按原始索引存储

伪代码：
const results = [];
let count = 0;
promises.forEach((p, index) => {
    p.then(value => {
        results[index] = value; // 按索引存储
        if (++count === promises.length) {
            resolve(results);
        }
    });
});
```

## 四、Vue部分（10分钟，15分）

### 11. Vue生命周期（7分）
1. 说明Vue的生命周期钩子有哪些？各个阶段可以做什么？（3分）

**答案：**
```
Vue2生命周期：
创建阶段：
- beforeCreate: 实例初始化，无法访问data/methods
- created: 可访问data/methods，常用于接口请求

挂载阶段：
- beforeMount: 模板编译完成，$el还是旧的
- mounted: DOM挂载完成，可操作DOM，常用于第三方库初始化

更新阶段：
- beforeUpdate: 数据更新但DOM未更新
- updated: DOM更新完成，避免在此修改数据

销毁阶段：
- beforeDestroy: 清理定时器、解绑事件、取消订阅
- destroyed: 实例销毁完成

Vue3对应：
setup() → onBeforeMount → onMounted → onBeforeUpdate → 
onUpdated → onBeforeUnmount → onUnmounted
```

2. 父子组件的生命周期执行顺序是怎样的？（2分）

**答案：**
```
挂载阶段：
父beforeCreate → 父created → 父beforeMount → 
子beforeCreate → 子created → 子beforeMount → 子mounted → 父mounted

更新阶段：
父beforeUpdate → 子beforeUpdate → 子updated → 父updated

销毁阶段：
父beforeDestroy → 子beforeDestroy → 子destroyed → 父destroyed
```

3. keep-alive组件有哪些生命周期？（2分）

**答案：**
```
activated: 缓存组件激活时调用（进入页面）
deactivated: 缓存组件停用时调用（离开页面）

使用场景：列表页缓存、表单数据保持、页面状态保存
```

### 12. Vue组件通信（8分）
1. Vue父子组件通信有哪些方式？请列举至少5种并说明使用场景（8分）

**答案：**
```
1. props/$emit
   场景：父子组件数据传递，最常用的通信方式
   父→子：props传递数据
   子→父：$emit触发事件

2. v-model
   场景：表单组件双向绑定
   本质：:value + @input的语法糖

3. $refs
   场景：父组件直接调用子组件方法
   特点：获取组件实例，可访问所有属性方法

4. provide/inject
   场景：跨级组件通信，祖先向后代传递
   特点：不限层级，但不是响应式（Vue3中可响应）

5. Vuex/Pinia
   场景：全局状态管理，多组件共享状态
   特点：单向数据流，可追踪状态变化

6. EventBus
   场景：兄弟组件通信（Vue3已移除）
   特点：发布订阅模式，解耦组件

7. $attrs/$listeners
   场景：组件封装，属性和事件透传
   特点：Vue3中合并为$attrs

8. $parent/$children
   场景：直接访问父子实例（不推荐）
   特点：Vue3中$children已移除
```

## 五、综合实践题（15分钟，25分）

### 13. URL输入过程（6分）
1. 详细描述在浏览器中输入URL后的完整过程（6分）

**答案：**
```
1. URL解析
   浏览器解析URL，提取协议、域名、路径等信息

2. DNS查询
   - 浏览器缓存 → 系统缓存 → 路由器缓存
   - 本地DNS服务器 → 根DNS → 顶级DNS → 权威DNS
   - 获取服务器IP地址

3. 建立TCP连接
   三次握手：SYN → SYN-ACK → ACK

4. 发送HTTP请求
   构造请求报文：请求行、请求头、请求体

5. 服务器处理请求
   服务器解析请求，处理业务逻辑，返回响应

6. 返回HTTP响应
   响应报文：状态行、响应头、响应体

7. 浏览器解析渲染
   - 解析HTML构建DOM树
   - 解析CSS构建CSSOM树
   - 合并生成渲染树
   - 布局(Layout)：计算位置大小
   - 绘制(Paint)：绘制页面
   - 合成(Composite)：GPU加速

8. 断开连接
   四次挥手：FIN → ACK → FIN → ACK
```

### 14. 性能优化（4分）
1. 如果进入一个页面，它的加载时间很久，怎么排查？（4分）

**答案：**
```
网络方面：
- Chrome DevTools Network面板查看资源加载
- 检查慢请求、大文件、失败请求
- 查看是否启用gzip压缩、CDN
- 检查并发请求数、HTTP版本

渲染方面：
- Performance面板录制性能
- 查看FCP、LCP、TTI等指标
- 检查长任务、重绘重排
- 分析主线程阻塞情况

JavaScript执行：
- 查看JS执行时间、调用栈
- 检查是否有死循环、复杂计算
- 内存泄漏检查(Memory面板)
- 第三方脚本影响

其他优化：
- Lighthouse性能评分
- 图片优化(格式、大小、懒加载)
- 代码分割、按需加载
- 缓存策略优化
```

### 15. 防抖实现（8分）
**手撕代码：** 实现一个防抖函数，支持立即执行和取消功能（8分）

**答案：**
```javascript
function debounce(fn, delay, immediate = false) {
    let timer = null;
    let result;
    
    const debounced = function(...args) {
        const context = this;
        
        // 清除之前的定时器
        if (timer) clearTimeout(timer);
        
        if (immediate) {
            // 立即执行模式
            const callNow = !timer;
            timer = setTimeout(() => {
                timer = null;
            }, delay);
            if (callNow) {
                result = fn.apply(context, args);
            }
        } else {
            // 延迟执行模式
            timer = setTimeout(() => {
                result = fn.apply(context, args);
            }, delay);
        }
        
        return result;
    };
    
    // 取消功能
    debounced.cancel = function() {
        clearTimeout(timer);
        timer = null;
    };
    
    return debounced;
}

// 测试用例
const handleInput = debounce(() => {
    console.log('Input handled');
}, 500, true);
```

### 16. 三列布局（7分）
**手撕代码：** 实现一个三列布局，左右宽度是中间的一半，整体宽度自适应（7分）

**答案：**
```css
/* 方案1：Flexbox */
.container {
    display: flex;
    width: 100%;
    height: 100vh;
}
.left, .right {
    flex: 1;
    background: #f0f0f0;
}
.center {
    flex: 2;
    background: #ffffff;
}

/* 方案2：Grid */
.container {
    display: grid;
    grid-template-columns: 1fr 2fr 1fr;
    height: 100vh;
}

/* 方案3：Float */
.container {
    width: 100%;
    overflow: hidden;
}
.left {
    float: left;
    width: 25%;
    background: #f0f0f0;
}
.center {
    float: left;
    width: 50%;
    background: #ffffff;
}
.right {
    float: left;
    width: 25%;
    background: #f0f0f0;
}

/* 方案4：Position */
.container {
    position: relative;
    width: 100%;
    height: 100vh;
}
.left {
    position: absolute;
    left: 0;
    width: 25%;
}
.center {
    position: absolute;
    left: 25%;
    width: 50%;
}
.right {
    position: absolute;
    right: 0;
    width: 25%;
}
```

### 17. 字符串中的第一个唯一字符（加分题，10分）
**算法题：** LeetCode 387题 - 字符串中的第一个唯一字符（10分）

**答案：**
```javascript
// 方法1：哈希表两次遍历
function firstUniqChar(s) {
    const map = new Map();
    
    // 第一次遍历：统计字符出现次数
    for (let char of s) {
        map.set(char, (map.get(char) || 0) + 1);
    }
    
    // 第二次遍历：找第一个出现一次的字符
    for (let i = 0; i < s.length; i++) {
        if (map.get(s[i]) === 1) {
            return i;
        }
    }
    
    return -1;
}

// 方法2：indexOf和lastIndexOf
function firstUniqChar2(s) {
    for (let i = 0; i < s.length; i++) {
        const char = s[i];
        if (s.indexOf(char) === s.lastIndexOf(char)) {
            return i;
        }
    }
    return -1;
}

// 方法3：数组计数（仅限小写字母）
function firstUniqChar3(s) {
    const count = new Array(26).fill(0);
    
    // 统计每个字符出现次数
    for (let char of s) {
        count[char.charCodeAt(0) - 97]++;
    }
    
    // 找第一个出现一次的字符
    for (let i = 0; i < s.length; i++) {
        if (count[s.charCodeAt(i) - 97] === 1) {
            return i;
        }
    }
    
    return -1;
}

// 测试
console.log(firstUniqChar("leetcode")); // 0
console.log(firstUniqChar("loveleetcode")); // 2
console.log(firstUniqChar("aabb")); // -1
```

---

## 答题要求

1. **时间分配**：
   - HTML：10分钟
   - CSS：10分钟
   - JavaScript：20分钟
   - Vue：10分钟
   - 综合实践：15分钟

2. **评分标准**：
   - HTML：10分
   - CSS：13分
   - JavaScript：37分
   - Vue：15分
   - 综合实践：25分
   - 总分：100分（算法题为加分题）

3. **注意事项**：
   - 手撕代码题要求代码可运行，注意边界条件
   - 概念题要求条理清晰，要点完整
   - 时间控制很重要，优先完成熟悉的题目
   - 算法题为加分题，有余力再完成

**考试时间：60分钟 | 满分：100分**