# 算法题面试总结大全

## 一、数组相关算法

### 1. 两数之和
**题目：** 给定一个整数数组 nums 和一个目标值 target，在该数组中找出和为目标值的两个整数，并返回它们的数组下标。

**示例：**
```javascript
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] = 2 + 7 = 9
```

**解法：**
```javascript
// 方法1：暴力法 O(n²)
function twoSum(nums, target) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
}

// 方法2：哈希表 O(n)
function twoSum(nums, target) {
    const map = new Map();
    
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        
        map.set(nums[i], i);
    }
    
    return [];
}
```

### 2. 删除有序数组中的重复项
**题目：** 给定一个有序数组 nums，原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。

**示例：**
```javascript
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
```

**解法：**
```javascript
function removeDuplicates(nums) {
    if (nums.length === 0) return 0;
    
    let slow = 0;
    for (let fast = 1; fast < nums.length; fast++) {
        if (nums[fast] !== nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }
    return slow + 1;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 3. 移动零
**题目：** 给定一个数组 nums，将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例：**
```javascript
输入：nums = [0,1,0,3,12]
输出：[1,3,12,0,0]
```

**解法：**
```javascript
function moveZeroes(nums) {
    let nonZeroIndex = 0;
    
    // 将所有非零元素移到前面
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            nums[nonZeroIndex] = nums[i];
            nonZeroIndex++;
        }
    }
    
    // 将剩余位置填充为0
    for (let i = nonZeroIndex; i < nums.length; i++) {
        nums[i] = 0;
    }
    
    return nums;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 4. 移除元素
**题目：** 给定数组 nums 和值 val，原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

**示例：**
```javascript
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
```

**解法：**
```javascript
function removeElement(nums, val) {
    let k = 0;
    
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== val) {
            nums[k] = nums[i];
            k++;
        }
    }
    
    return k;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 5. 长度最小的子数组
**题目：** 给定一个含有 n 个正整数的数组和一个正整数 target，找出该数组中满足其和 ≥ target 的长度最小的连续子数组，并返回其长度。

**示例：**
```javascript
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组
```

**解法：**
```javascript
function minSubArrayLen(target, nums) {
    let left = 0;
    let sum = 0;
    let minLength = Infinity;
    
    for (let right = 0; right < nums.length; right++) {
        sum += nums[right];
        
        while (sum >= target) {
            minLength = Math.min(minLength, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }
    
    return minLength === Infinity ? 0 : minLength;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 6. 螺旋矩阵 II
**题目：** 给你一个正整数 n，生成一个包含 1 到 n² 所有元素，且元素按顺时针螺旋排列的 n x n 正方形矩阵。

**示例：**
```javascript
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**解法：**
```javascript
function generateMatrix(n) {
    const matrix = Array(n).fill().map(() => Array(n).fill(0));
    let num = 1;
    let top = 0, bottom = n - 1, left = 0, right = n - 1;
    
    while (top <= bottom && left <= right) {
        // 从左到右
        for (let i = left; i <= right; i++) {
            matrix[top][i] = num++;
        }
        top++;
        
        // 从上到下
        for (let i = top; i <= bottom; i++) {
            matrix[i][right] = num++;
        }
        right--;
        
        // 从右到左
        if (top <= bottom) {
            for (let i = right; i >= left; i--) {
                matrix[bottom][i] = num++;
            }
            bottom--;
        }
        
        // 从下到上
        if (left <= right) {
            for (let i = bottom; i >= top; i--) {
                matrix[i][left] = num++;
            }
            left++;
        }
    }
    
    return matrix;
}

// 时间复杂度：O(n²)
// 空间复杂度：O(1)
```

## 二、字符串相关算法

### 1. 有效的括号
**题目：** 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s，判断字符串是否有效。

**示例：**
```javascript
输入：s = "()[]{}"
输出：true
```

**解法：**
```javascript
function isValid(s) {
    const stack = [];
    const map = {
        ')': '(',
        '}': '{',
        ']': '['
    };
    
    for (let char of s) {
        if (char in map) {
            if (stack.length === 0 || stack.pop() !== map[char]) {
                return false;
            }
        } else {
            stack.push(char);
        }
    }
    
    return stack.length === 0;
}

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

### 2. 字符串中的第一个唯一字符
**题目：** 给定一个字符串 s，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**示例：**
```javascript
输入：s = "leetcode"
输出：0
解释：第一个不重复字符是 "l"，它的索引为 0
```

**解法：**
```javascript
function firstUniqChar(s) {
    const charCount = {};
    
    // 统计每个字符的出现次数
    for (let char of s) {
        charCount[char] = (charCount[char] || 0) + 1;
    }
    
    // 找到第一个出现次数为1的字符
    for (let i = 0; i < s.length; i++) {
        if (charCount[s[i]] === 1) {
            return i;
        }
    }
    
    return -1;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1) - 最多26个字母
```

### 3. 有效的字母异位词
**题目：** 给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。

**示例：**
```javascript
输入：s = "anagram", t = "nagaram"
输出：true
```

**解法：**
```javascript
function isAnagram(s, t) {
    if (s.length !== t.length) return false;
    
    const charCount = {};
    
    // 统计s中每个字符的出现次数
    for (let char of s) {
        charCount[char] = (charCount[char] || 0) + 1;
    }
    
    // 检查t中的每个字符
    for (let char of t) {
        if (!charCount[char]) return false;
        charCount[char]--;
    }
    
    return true;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 4. 反转字符串中的单词
**题目：** 给定一个字符串，反转字符串中每个单词的字符顺序，同时保留空格和单词的初始顺序。

**示例：**
```javascript
输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"
```

**解法：**
```javascript
function reverseWords(s) {
    return s.split(' ')
            .map(word => word.split('').reverse().join(''))
            .join(' ');
}

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

## 三、链表相关算法

### 1. 反转链表
**题目：** 给你单链表的头节点 head，请你反转链表，并返回反转后的链表。

**示例：**
```javascript
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**解法：**
```javascript
function reverseList(head) {
    let prev = null;
    let current = head;
    
    while (current) {
        const next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    return prev;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 2. 合并两个有序链表
**题目：** 将两个升序链表合并为一个新的升序链表并返回。

**示例：**
```javascript
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**解法：**
```javascript
function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let current = dummy;
    
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    current.next = l1 || l2;
    
    return dummy.next;
}

// 时间复杂度：O(n + m)
// 空间复杂度：O(1)
```

## 四、树相关算法

### 1. 二叉树的最大深度
**题目：** 给定一个二叉树，找出其最大深度。

**示例：**
```javascript
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**解法：**
```javascript
// 递归解法
function maxDepth(root) {
    if (!root) return 0;
    
    const leftDepth = maxDepth(root.left);
    const rightDepth = maxDepth(root.right);
    
    return Math.max(leftDepth, rightDepth) + 1;
}

// 迭代解法
function maxDepth(root) {
    if (!root) return 0;
    
    const queue = [root];
    let depth = 0;
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        
        depth++;
    }
    
    return depth;
}

// 时间复杂度：O(n)
// 空间复杂度：O(h) - h为树的高度
```

### 2. 对称二叉树
**题目：** 给定一个二叉树，检查它是否是镜像对称的。

**示例：**
```javascript
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**解法：**
```javascript
function isSymmetric(root) {
    if (!root) return true;
    
    return isMirror(root.left, root.right);
}

function isMirror(left, right) {
    if (!left && !right) return true;
    if (!left || !right) return false;
    
    return left.val === right.val &&
           isMirror(left.left, right.right) &&
           isMirror(left.right, right.left);
}

// 时间复杂度：O(n)
// 空间复杂度：O(h)
```

## 五、动态规划

### 1. 爬楼梯
**题目：** 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：**
```javascript
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**解法：**
```javascript
function climbStairs(n) {
    if (n <= 2) return n;
    
    let prev2 = 1; // f(1)
    let prev1 = 2; // f(2)
    
    for (let i = 3; i <= n; i++) {
        const current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    
    return prev1;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

### 2. 最大子数组和
**题目：** 给你一个整数数组 nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例：**
```javascript
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6
```

**解法：**
```javascript
function maxSubArray(nums) {
    let maxSum = nums[0];
    let currentSum = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        currentSum = Math.max(nums[i], currentSum + nums[i]);
        maxSum = Math.max(maxSum, currentSum);
    }
    
    return maxSum;
}

// 时间复杂度：O(n)
// 空间复杂度：O(1)
```

## 六、排序算法

### 1. 快速排序
```javascript
function quickSort(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(x => x < pivot);
    const middle = arr.filter(x => x === pivot);
    const right = arr.filter(x => x > pivot);
    
    return [...quickSort(left), ...middle, ...quickSort(right)];
}

// 时间复杂度：O(n log n) 平均，O(n²) 最坏
// 空间复杂度：O(log n)
```

### 2. 归并排序
```javascript
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }
    
    return result.concat(left.slice(i)).concat(right.slice(j));
}

// 时间复杂度：O(n log n)
// 空间复杂度：O(n)
```

### 3. 冒泡排序
```javascript
function bubbleSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
        let swapped = false;
        
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                swapped = true;
            }
        }
        
        if (!swapped) break;
    }
    
    return arr;
}

// 时间复杂度：O(n²)
// 空间复杂度：O(1)
```

## 七、搜索算法

### 1. 二分查找
```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// 时间复杂度：O(log n)
// 空间复杂度：O(1)
```

### 2. 深度优先搜索（DFS）
```javascript
function dfs(node, visited = new Set()) {
    if (!node || visited.has(node)) return;
    
    visited.add(node);
    console.log(node.val);
    
    if (node.left) dfs(node.left, visited);
    if (node.right) dfs(node.right, visited);
}
```

### 3. 广度优先搜索（BFS）
```javascript
function bfs(root) {
    if (!root) return;
    
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        console.log(node.val);
        
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
    }
}
```

## 八、常用工具函数

### 1. 数组去重
```javascript
// 方法1：Set
function unique(arr) {
    return [...new Set(arr)];
}

// 方法2：filter + indexOf
function unique(arr) {
    return arr.filter((item, index) => arr.indexOf(item) === index);
}

// 方法3：reduce
function unique(arr) {
    return arr.reduce((prev, cur) => {
        return prev.includes(cur) ? prev : [...prev, cur];
    }, []);
}
```

### 2. 数组扁平化
```javascript
// 方法1：递归
function flatten(arr) {
    return arr.reduce((prev, cur) => {
        return prev.concat(Array.isArray(cur) ? flatten(cur) : cur);
    }, []);
}

// 方法2：flat方法
function flatten(arr) {
    return arr.flat(Infinity);
}
```

### 3. 深拷贝
```javascript
function deepClone(obj, map = new WeakMap()) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    
    if (map.has(obj)) {
        return map.get(obj);
    }
    
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    
    if (obj instanceof RegExp) {
        return new RegExp(obj.source, obj.flags);
    }
    
    const cloned = Array.isArray(obj) ? [] : {};
    map.set(obj, cloned);
    
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloned[key] = deepClone(obj[key], map);
        }
    }
    
    return cloned;
}
```

### 4. 防抖函数
```javascript
function debounce(fn, delay, immediate = false) {
    let timer = null;
    
    return function(...args) {
        const context = this;
        
        if (immediate && !timer) {
            fn.apply(context, args);
        }
        
        clearTimeout(timer);
        timer = setTimeout(() => {
            if (!immediate) {
                fn.apply(context, args);
            }
            timer = null;
        }, delay);
    };
}
```

### 5. 节流函数
```javascript
function throttle(fn, delay) {
    let timer = null;
    let lastTime = 0;
    
    return function(...args) {
        const context = this;
        const now = Date.now();
        
        if (now - lastTime >= delay) {
            fn.apply(context, args);
            lastTime = now;
        } else {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fn.apply(context, args);
                lastTime = Date.now();
            }, delay - (now - lastTime));
        }
    };
}
```

## 九、算法复杂度分析

### 1. 时间复杂度
- **O(1)** - 常数时间
- **O(log n)** - 对数时间
- **O(n)** - 线性时间
- **O(n log n)** - 线性对数时间
- **O(n²)** - 平方时间
- **O(2^n)** - 指数时间

### 2. 空间复杂度
- **O(1)** - 常数空间
- **O(n)** - 线性空间
- **O(n²)** - 平方空间

### 3. 常见算法复杂度
| 算法 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 二分查找 | O(log n) | O(1) |
| 快速排序 | O(n log n) | O(log n) |
| 归并排序 | O(n log n) | O(n) |
| 冒泡排序 | O(n²) | O(1) |
| 深度优先搜索 | O(V + E) | O(V) |
| 广度优先搜索 | O(V + E) | O(V) |

## 十、解题技巧

### 1. 双指针
- 快慢指针
- 左右指针
- 滑动窗口

### 2. 哈希表
- 快速查找
- 计数
- 去重

### 3. 栈和队列
- 栈：后进先出
- 队列：先进先出
- 单调栈
- 优先队列

### 4. 递归和回溯
- 递归：自相似性
- 回溯：尝试所有可能
- 剪枝优化

### 5. 动态规划
- 最优子结构
- 重叠子问题
- 状态转移方程

### 6. 贪心算法
- 局部最优
- 全局最优
- 证明正确性

## 十一、面试准备建议

### 1. 基础准备
- 熟练掌握基本数据结构
- 理解常见算法思想
- 练习代码实现
- 分析时间空间复杂度

### 2. 解题步骤
1. 理解题目
2. 分析思路
3. 选择算法
4. 编写代码
5. 测试验证
6. 优化改进

### 3. 常见错误
- 边界条件处理
- 数组越界
- 空指针异常
- 逻辑错误

### 4. 优化技巧
- 空间换时间
- 时间换空间
- 预处理
- 缓存结果

### 5. 练习建议
- 每天练习1-2道题
- 分类练习
- 总结规律
- 反复练习
