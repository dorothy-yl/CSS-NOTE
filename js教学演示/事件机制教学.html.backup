<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 事件机制教学演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            padding: 30px;
            border-radius: 10px;
            background: #f8f9fa;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8em;
            display: flex;
            align-items: center;
        }

        .section h2::before {
            content: "📚";
            margin-right: 10px;
        }

        .section h3 {
            color: #555;
            margin: 20px 0 10px 0;
            font-size: 1.3em;
        }

        .demo-area {
            background: white;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            border: 2px solid #e9ecef;
            position: relative;
        }

        .event-flow-demo {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            position: relative;
        }

        .event-container {
            width: 300px;
            height: 300px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .event-container:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .event-middle {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .event-middle:hover {
            transform: scale(1.05);
        }

        .event-inner {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #feca57, #ff9ff3);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .event-inner:hover {
            transform: scale(1.1);
        }

        .event-log {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            max-height: 200px;
            overflow-y: auto;
        }

        .event-log .log-entry {
            margin: 5px 0;
            padding: 8px 12px;
            border-radius: 4px;
            animation: fadeIn 0.3s ease;
        }

        .log-capture {
            background: rgba(231, 76, 60, 0.2);
            border-left: 3px solid #e74c3c;
        }

        .log-target {
            background: rgba(46, 204, 113, 0.2);
            border-left: 3px solid #2ecc71;
        }

        .log-bubble {
            background: rgba(52, 152, 219, 0.2);
            border-left: 3px solid #3498db;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
            color: #333;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(255, 234, 167, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #fd79a8, #fdcb6e);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(253, 121, 168, 0.3);
        }

        .delegation-demo {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 20px 0;
        }

        .item {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(116, 185, 255, 0.3);
        }

        .item.clicked {
            background: linear-gradient(135deg, #00b894, #00a085);
            animation: pulse 0.6s ease;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            position: relative;
        }

        .code-block::before {
            content: "JavaScript";
            position: absolute;
            top: 8px;
            right: 15px;
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .highlight {
            background: rgba(255, 255, 0, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .info-box {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            position: relative;
        }

        .info-box::before {
            content: "💡";
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 1.5em;
        }

        .info-box h4 {
            margin-left: 40px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .info-box p {
            margin-left: 40px;
            line-height: 1.6;
        }

        .phase-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
        }

        .stat-label {
            color: #666;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
            }
            
            .content {
                padding: 20px;
            }
            
            .event-container {
                width: 250px;
                height: 250px;
            }
            
            .event-middle {
                width: 150px;
                height: 150px;
            }
            
            .event-inner {
                width: 75px;
                height: 75px;
                font-size: 12px;
            }
            
            .controls {
                justify-content: center;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>JavaScript 事件机制</h1>
            <p>交互式教学演示 - 理解事件委托、事件流和事件传播</p>
        </div>

        <div class="content">
            <!-- 事件委托部分 -->
            <div class="section">
                <h2>什么是事件委托？</h2>
                <p>事件委托是利用事件冒泡机制，将子元素的事件处理函数绑定到父元素上。</p>
                
                <div class="info-box">
                    <h4>事件委托的优点：</h4>
                    <p>• 减少内存消耗，不需要为每个子元素绑定事件<br>
                       • 动态绑定，新增的子元素自动有事件处理</p>
                </div>

                <h3>🎯 交互演示：点击任意方块</h3>
                <div class="demo-area">
                    <div class="delegation-demo" id="delegationDemo">
                        <div class="item" data-id="1">项目 1</div>
                        <div class="item" data-id="2">项目 2</div>
                        <div class="item" data-id="3">项目 3</div>
                        <div class="item" data-id="4">项目 4</div>
                        <div class="item" data-id="5">项目 5</div>
                        <div class="item" data-id="6">项目 6</div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-secondary" onclick="addNewItem()">➕ 添加新项目</button>
                        <button class="btn btn-danger" onclick="resetDelegation()">🔄 重置</button>
                    </div>

                    <div class="stats">
                        <div class="stat-card">
                            <div class="stat-number" id="clickCount">0</div>
                            <div class="stat-label">总点击次数</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="itemCount">6</div>
                            <div class="stat-label">项目总数</div>
                        </div>
                    </div>
                </div>

                <div class="code-block">
<pre><code>// 使用事件委托
const ul = document.querySelector('ul');
ul.addEventListener('click', function(e) {
  if (e.target.tagName === 'LI') {
    console.log(e.target.textContent);
  }
});

// 不使用事件委托（不推荐）
const lis = document.querySelectorAll('li');
lis.forEach(li => {
  li.addEventListener('click', function() {
    console.log(this.textContent);
  });
});</code></pre>
                </div>
            </div>

            <!-- 事件流部分 -->
            <div class="section">
                <h2>事件流的三个阶段</h2>
                <p>事件流描述了事件从页面中接收事件的顺序，包含三个阶段：</p>
                
                <div class="info-box">
                    <h4>事件流三阶段：</h4>
                    <p>1. <span class="highlight">捕获阶段</span>：事件从window向目标元素传播<br>
                       2. <span class="highlight">目标阶段</span>：事件到达目标元素<br>
                       3. <span class="highlight">冒泡阶段</span>：事件从目标元素向window传播</p>
                </div>

                <h3>🎯 交互演示：点击中心按钮观察事件传播</h3>
                <div class="demo-area">
                    <div class="event-flow-demo">
                        <div class="event-container" id="outerDiv">
                            <div class="event-middle" id="middleDiv">
                                <div class="event-inner" id="innerDiv">
                                    点击我
                                </div>
                            </div>
                        </div>
                        <div class="phase-indicator" id="phaseIndicator">等待点击</div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-primary" onclick="toggleCapture()">📥 切换捕获模式</button>
                        <button class="btn btn-secondary" onclick="toggleBubble()">📤 切换冒泡模式</button>
                        <button class="btn btn-danger" onclick="clearEventLog()">🧹 清空日志</button>
                    </div>
                    
                    <div class="event-log" id="eventLog">
                        <div class="log-entry">点击上方的嵌套元素来观察事件传播过程...</div>
                    </div>
                </div>

                <div class="code-block">
<pre><code>// 在捕获阶段监听事件
element.addEventListener('click', handler, <span class="highlight">true</span>);

// 在冒泡阶段监听事件（默认）
element.addEventListener('click', handler, <span class="highlight">false</span>);

// 阻止事件传播
event.<span class="highlight">stopPropagation()</span>;

// 阻止默认行为
event.<span class="highlight">preventDefault()</span>;</code></pre>
                </div>
            </div>

            <!-- 阻止事件传播部分 -->
            <div class="section">
                <h2>如何阻止事件传播和默认行为？</h2>
                
                <div class="demo-area">
                    <h3>🚫 阻止传播演示</h3>
                    <div class="controls">
                        <button class="btn btn-primary" id="normalBtn">正常传播</button>
                        <button class="btn btn-secondary" id="stopPropBtn">阻止传播</button>
                        <button class="btn btn-danger" id="preventDefaultBtn">阻止默认行为</button>
                    </div>
                    
                    <div class="event-log" id="propagationLog">
                        <div class="log-entry">点击上方按钮观察不同的事件行为...</div>
                    </div>
                </div>

                <div class="code-block">
<pre><code>element.addEventListener('click', function(e) {
  // 阻止事件冒泡
  e.<span class="highlight">stopPropagation()</span>;
  
  // 阻止事件捕获和冒泡
  e.<span class="highlight">stopImmediatePropagation()</span>;
  
  // 阻止默认行为
  e.<span class="highlight">preventDefault()</span>;
  
  // 或者直接返回false（仅在onclick等属性绑定中有效）
  return false;
});</code></pre>
                </div>
            </div>

            <!-- 实际应用场景 -->
            <div class="section">
                <h2>实际应用场景</h2>
                
                <div class="info-box">
                    <h4>常见应用场景：</h4>
                    <p>• 表格行点击事件处理<br>
                       • 动态列表项的交互<br>
                       • 模态框的关闭处理<br>
                       • 菜单系统的实现</p>
                </div>

                <div class="code-block">
<pre><code>// 表格行点击事件委托
document.querySelector('table').addEventListener('click', function(e) {
  const row = e.target.closest('tr');
  if (row && row.parentNode.tagName === 'TBODY') {
    console.log('选中行:', row.dataset.id);
    row.classList.toggle('selected');
  }
});

// 模态框关闭
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('modal-backdrop')) {
    closeModal();
  }
});</code></pre>
                </div>
            </div>

            <!-- 高频面试题 -->
            <div class="section">
                <h2>🔥 高频面试题</h2>
                
                <div class="demo-area">
                    <h3>面试题1：什么是事件委托？有什么优点？</h3>
                    <div class="info-box">
                        <h4>标准答案：</h4>
                        <p><strong>事件委托</strong>是利用事件冒泡机制，将子元素的事件处理函数绑定到父元素上。<br><br>
                        <strong>优点：</strong><br>
                        • 减少内存消耗，不需要为每个子元素绑定事件<br>
                        • 动态绑定，新增的子元素自动有事件处理<br>
                        • 代码更简洁，易于维护</p>
                    </div>
                    
                    <div class="code-block">
<pre><code>// ❌ 不使用事件委托（为每个li绑定事件）
const lis = document.querySelectorAll('li');
lis.forEach(li => {
  li.addEventListener('click', function() {
    console.log(this.textContent);
  });
});

// ✅ 使用事件委托（只在ul上绑定一个事件）
const ul = document.querySelector('ul');
ul.addEventListener('click', function(e) {
  if (e.target.tagName === 'LI') {
    console.log(e.target.textContent);
  }
});</code></pre>
                    </div>
                </div>

                <div class="demo-area">
                    <h3>面试题2：事件流的三个阶段是什么？执行顺序如何？</h3>
                    <div class="info-box">
                        <h4>标准答案：</h4>
                        <p><strong>三个阶段：</strong><br>
                        1. <span class="highlight">捕获阶段</span>：事件从window向目标元素传播<br>
                        2. <span class="highlight">目标阶段</span>：事件到达目标元素<br>
                        3. <span class="highlight">冒泡阶段</span>：事件从目标元素向window传播<br><br>
                        <strong>执行顺序：</strong> 捕获阶段 → 目标阶段 → 冒泡阶段</p>
                    </div>
                    
                    <div class="code-block">
<pre><code>// addEventListener的第三个参数控制在哪个阶段触发
element.addEventListener('click', handler, true);  // 捕获阶段
element.addEventListener('click', handler, false); // 冒泡阶段（默认）

// 实际例子
document.addEventListener('click', () => console.log('1-document捕获'), true);
div.addEventListener('click', () => console.log('2-div捕获'), true);
button.addEventListener('click', () => console.log('3-button目标'));
div.addEventListener('click', () => console.log('4-div冒泡'));
document.addEventListener('click', () => console.log('5-document冒泡'));

// 点击button的输出顺序：1 → 2 → 3 → 4 → 5</code></pre>
                    </div>
                </div>

                <div class="demo-area">
                    <h3>面试题3：如何阻止事件传播和默认行为？区别是什么？</h3>
                    <div class="info-box">
                        <h4>标准答案：</h4>
                        <p><strong>阻止事件传播的方法：</strong><br>
                        • <span class="highlight">stopPropagation()</span>：阻止事件继续传播（捕获或冒泡）<br>
                        • <span class="highlight">stopImmediatePropagation()</span>：阻止事件传播，并且阻止同一元素上的其他事件监听器执行<br><br>
                        <strong>阻止默认行为：</strong><br>
                        • <span class="highlight">preventDefault()</span>：阻止元素的默认行为（如链接跳转、表单提交）</p>
                    </div>
                    
                    <div class="code-block">
<pre><code>element.addEventListener('click', function(e) {
  // 阻止事件冒泡到父元素
  e.stopPropagation();
  
  // 阻止事件传播，并且阻止同元素上其他监听器
  e.stopImmediatePropagation();
  
  // 阻止默认行为（如&lt;a&gt;标签的跳转）
  e.preventDefault();
  
  // return false 等同于同时调用 preventDefault 和 stopPropagation
  // 但只在DOM0级事件处理程序中有效
  return false;
});</code></pre>
                    </div>
                </div>

                <div class="demo-area">
                    <h3>面试题4：以下代码的输出顺序是什么？</h3>
                    <div class="code-block">
<pre><code>// HTML结构
&lt;div id="outer"&gt;
  &lt;div id="middle"&gt;
    &lt;div id="inner"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

// JavaScript代码
document.getElementById('outer').addEventListener('click', 
  () =&gt; console.log('outer-capture'), true);
document.getElementById('middle').addEventListener('click', 
  () =&gt; console.log('middle-capture'), true);
document.getElementById('inner').addEventListener('click', 
  () =&gt; console.log('inner-target'));
document.getElementById('middle').addEventListener('click', 
  () =&gt; console.log('middle-bubble'));
document.getElementById('outer').addEventListener('click', 
  () =&gt; console.log('outer-bubble'));

// 点击inner元素，输出顺序是？</code></pre>
                    </div>
                    
                    <div class="info-box">
                        <h4>答案分析：</h4>
                        <p><strong>输出顺序：</strong><br>
                        1. outer-capture （捕获阶段）<br>
                        2. middle-capture （捕获阶段）<br>
                        3. inner-target （目标阶段）<br>
                        4. middle-bubble （冒泡阶段）<br>
                        5. outer-bubble （冒泡阶段）<br><br>
                        <strong>解释：</strong>事件从最外层开始捕获，到达目标元素后开始冒泡返回</p>
                    </div>
                </div>

                <div class="demo-area">
                    <h3>面试题5：事件委托在什么场景下不适用？</h3>
                    <div class="info-box">
                        <h4>标准答案：</h4>
                        <p><strong>不适用场景：</strong><br>
                        • 某些事件不支持冒泡（如 focus、blur、load、scroll 等）<br>
                        • 需要精确控制事件触发时机的场景<br>
                        • 事件处理逻辑需要访问具体元素属性的场景<br>
                        • 性能要求极高，事件频繁触发的场景（如 mousemove）</p>
                    </div>
                    
                    <div class="code-block">
<pre><code>// 不冒泡的事件示例
input.addEventListener('focus', handler);    // focus不冒泡
input.addEventListener('focusin', handler);  // focusin冒泡，可用事件委托

// 频繁触发的事件不适合事件委托
container.addEventListener('mousemove', function(e) {
  // 这会导致性能问题，因为mousemove事件触发频率很高
  if (e.target.matches('.draggable')) {
    handleDrag(e);
  }
});

// 更好的方案是直接绑定
document.querySelectorAll('.draggable').forEach(el => {
  el.addEventListener('mousemove', handleDrag);
});</code></pre>
                    </div>
                </div>

                <div class="demo-area">
                    <h3>🎯 快速测试：检验你的理解</h3>
                    <div class="controls">
                        <button class="btn btn-primary" onclick="startQuiz()">🧠 开始测试</button>
                        <button class="btn btn-secondary" onclick="showAnswer()">👁️ 查看答案</button>
                        <button class="btn btn-danger" onclick="resetQuiz()">🔄 重置测试</button>
                    </div>
                    
                    <div class="event-log" id="quizLog">
                        <div class="log-entry">点击"开始测试"来检验你对事件机制的理解...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 事件委托演示
        let clickCount = 0;
        let itemCount = 6;
        let isCapturing = false;
        let isBubbling = true;

        // 事件委托实现
        document.getElementById('delegationDemo').addEventListener('click', function(e) {
            if (e.target.classList.contains('item')) {
                clickCount++;
                document.getElementById('clickCount').textContent = clickCount;
                
                // 添加点击效果
                e.target.classList.add('clicked');
                setTimeout(() => {
                    e.target.classList.remove('clicked');
                }, 600);

                // 显示点击的项目信息
                console.log(`点击了项目: ${e.target.dataset.id}`);
            }
        });

        function addNewItem() {
            itemCount++;
            const delegationDemo = document.getElementById('delegationDemo');
            const newItem = document.createElement('div');
            newItem.className = 'item';
            newItem.dataset.id = itemCount;
            newItem.textContent = `项目 ${itemCount}`;
            delegationDemo.appendChild(newItem);
            
            document.getElementById('itemCount').textContent = itemCount;
        }

        function resetDelegation() {
            clickCount = 0;
            itemCount = 6;
            document.getElementById('clickCount').textContent = '0';
            document.getElementById('itemCount').textContent = '6';
            
            const delegationDemo = document.getElementById('delegationDemo');
            delegationDemo.innerHTML = `
                <div class="item" data-id="1">项目 1</div>
                <div class="item" data-id="2">项目 2</div>
                <div class="item" data-id="3">项目 3</div>
                <div class="item" data-id="4">项目 4</div>
                <div class="item" data-id="5">项目 5</div>
                <div class="item" data-id="6">项目 6</div>
            `;
        }

        // 事件流演示
        const eventLog = document.getElementById('eventLog');
        const phaseIndicator = document.getElementById('phaseIndicator');
        
        function logEvent(phase, element) {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${phase}`;
            logEntry.textContent = `${getCurrentTime()} - ${phase.toUpperCase()}阶段: ${element}`;
            eventLog.appendChild(logEntry);
            eventLog.scrollTop = eventLog.scrollHeight;
        }

        function getCurrentTime() {
            return new Date().toLocaleTimeString();
        }

        function setupEventListeners() {
            const outerDiv = document.getElementById('outerDiv');
            const middleDiv = document.getElementById('middleDiv');
            const innerDiv = document.getElementById('innerDiv');

            // 移除所有现有的监听器
            const newOuterDiv = outerDiv.cloneNode(true);
            const newMiddleDiv = newOuterDiv.querySelector('#middleDiv');
            const newInnerDiv = newOuterDiv.querySelector('#innerDiv');
            
            outerDiv.parentNode.replaceChild(newOuterDiv, outerDiv);

            // 根据当前模式添加监听器
            if (isCapturing) {
                newOuterDiv.addEventListener('click', function(e) {
                    logEvent('capture', '外层容器');
                    phaseIndicator.textContent = '捕获阶段';
                }, true);

                newMiddleDiv.addEventListener('click', function(e) {
                    logEvent('capture', '中间容器');
                }, true);

                newInnerDiv.addEventListener('click', function(e) {
                    logEvent('target', '内层按钮');
                    phaseIndicator.textContent = '目标阶段';
                });
            }

            if (isBubbling) {
                newInnerDiv.addEventListener('click', function(e) {
                    if (!isCapturing) {
                        logEvent('target', '内层按钮');
                        phaseIndicator.textContent = '目标阶段';
                    }
                });

                newMiddleDiv.addEventListener('click', function(e) {
                    logEvent('bubble', '中间容器');
                    phaseIndicator.textContent = '冒泡阶段';
                });

                newOuterDiv.addEventListener('click', function(e) {
                    logEvent('bubble', '外层容器');
                    setTimeout(() => {
                        phaseIndicator.textContent = '事件完成';
                    }, 100);
                });
            }
        }

        function toggleCapture() {
            isCapturing = !isCapturing;
            setupEventListeners();
            logEvent('info', `捕获模式: ${isCapturing ? '开启' : '关闭'}`);
        }

        function toggleBubble() {
            isBubbling = !isBubbling;
            setupEventListeners();
            logEvent('info', `冒泡模式: ${isBubbling ? '开启' : '关闭'}`);
        }

        function clearEventLog() {
            eventLog.innerHTML = '<div class="log-entry">事件日志已清空，点击元素开始新的演示...</div>';
            phaseIndicator.textContent = '等待点击';
        }

        // 阻止传播演示
        const propagationLog = document.getElementById('propagationLog');
        
        function logPropagation(message) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `${getCurrentTime()} - ${message}`;
            propagationLog.appendChild(logEntry);
            propagationLog.scrollTop = propagationLog.scrollHeight;
        }

        // 为传播演示按钮添加事件监听
        document.getElementById('normalBtn').addEventListener('click', function(e) {
            logPropagation('正常传播 - 事件会继续传播到父元素');
        });

        document.getElementById('stopPropBtn').addEventListener('click', function(e) {
            e.stopPropagation();
            logPropagation('阻止传播 - stopPropagation() 已调用，事件不会传播到父元素');
        });

        document.getElementById('preventDefaultBtn').addEventListener('click', function(e) {
            e.preventDefault();
            logPropagation('阻止默认行为 - preventDefault() 已调用，默认行为被阻止');
        });

        // 为按钮容器添加监听器以演示传播
        document.querySelector('.controls').addEventListener('click', function(e) {
            if (e.target.id === 'normalBtn') {
                logPropagation('父容器接收到了正常传播的事件');
            }
        });

        // 初始化事件监听器
        setupEventListeners();

        // 面试题测试功能
        let currentQuiz = 0;
        const quizQuestions = [
            {
                question: "在事件委托中，如何判断点击的是目标元素？",
                options: [
                    "A. e.target.tagName === 'LI'",
                    "B. e.currentTarget.matches('.item')",
                    "C. e.target.classList.contains('item')",
                    "D. 以上都可以"
                ],
                correct: 3,
                explanation: "在事件委托中，可以通过多种方式判断目标元素：tagName检查标签名、matches()检查CSS选择器、classList.contains()检查类名等。"
            },
            {
                question: "以下哪个事件不支持冒泡？",
                options: [
                    "A. click",
                    "B. focus",
                    "C. mouseover",
                    "D. keydown"
                ],
                correct: 1,
                explanation: "focus、blur、load、scroll等事件不支持冒泡。如需在父元素监听focus事件，应使用focusin事件。"
            },
            {
                question: "stopPropagation()和preventDefault()的区别是？",
                options: [
                    "A. 都是阻止事件传播",
                    "B. 都是阻止默认行为",
                    "C. 前者阻止传播，后者阻止默认行为",
                    "D. 没有区别"
                ],
                correct: 2,
                explanation: "stopPropagation()阻止事件在DOM树中传播（捕获或冒泡），preventDefault()阻止浏览器的默认行为（如链接跳转、表单提交等）。"
            },
            {
                question: "事件流的正确顺序是？",
                options: [
                    "A. 冒泡阶段 → 目标阶段 → 捕获阶段",
                    "B. 捕获阶段 → 目标阶段 → 冒泡阶段",
                    "C. 目标阶段 → 捕获阶段 → 冒泡阶段",
                    "D. 捕获阶段 → 冒泡阶段 → 目标阶段"
                ],
                correct: 1,
                explanation: "DOM事件流包含三个阶段：捕获阶段（从window到目标元素）→ 目标阶段（在目标元素上）→ 冒泡阶段（从目标元素到window）。"
            },
            {
                question: "什么情况下事件委托不是最佳选择？",
                options: [
                    "A. 动态添加元素",
                    "B. mousemove等高频触发事件",
                    "C. 大量同类元素需要相同处理",
                    "D. 减少内存使用"
                ],
                correct: 1,
                explanation: "mousemove、scroll等高频触发的事件不适合事件委托，因为会导致性能问题。这种情况下直接为目标元素绑定事件更好。"
            }
        ];

        function startQuiz() {
            currentQuiz = 0;
            showCurrentQuestion();
        }

        function showCurrentQuestion() {
            if (currentQuiz >= quizQuestions.length) {
                showQuizComplete();
                return;
            }

            const quiz = quizQuestions[currentQuiz];
            const quizLog = document.getElementById('quizLog');
            
            quizLog.innerHTML = `
                <div class="log-entry">
                    <strong>面试题 ${currentQuiz + 1}/${quizQuestions.length}:</strong><br>
                    ${quiz.question}<br><br>
                    ${quiz.options.map((option, index) => 
                        `<div style="margin: 8px 0; cursor: pointer; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;" 
                              onclick="selectAnswer(${index})" 
                              onmouseover="this.style.background='rgba(255,255,255,0.2)'" 
                              onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                            ${option}
                         </div>`
                    ).join('')}
                </div>
            `;
        }

        function selectAnswer(selectedIndex) {
            const quiz = quizQuestions[currentQuiz];
            const quizLog = document.getElementById('quizLog');
            
            const isCorrect = selectedIndex === quiz.correct;
            const resultColor = isCorrect ? '#2ecc71' : '#e74c3c';
            const resultIcon = isCorrect ? '✅' : '❌';
            
            quizLog.innerHTML += `
                <div class="log-entry" style="border-left: 3px solid ${resultColor}; background: rgba(${isCorrect ? '46, 204, 113' : '231, 76, 60'}, 0.2); margin-top: 10px;">
                    <strong>${resultIcon} ${isCorrect ? '正确！' : '错误！'}</strong><br>
                    你选择了：${quiz.options[selectedIndex]}<br>
                    正确答案：${quiz.options[quiz.correct]}<br>
                    <strong>解释：</strong>${quiz.explanation}
                </div>
            `;

            setTimeout(() => {
                currentQuiz++;
                setTimeout(showCurrentQuestion, 2000);
            }, 3000);
        }

        function showQuizComplete() {
            const quizLog = document.getElementById('quizLog');
            quizLog.innerHTML = `
                <div class="log-entry" style="border-left: 3px solid #f39c12; background: rgba(243, 156, 18, 0.2);">
                    <strong>🎉 恭喜完成所有面试题测试！</strong><br><br>
                    你已经完成了JavaScript事件机制的所有核心面试题。<br>
                    这些题目涵盖了：<br>
                    • 事件委托的判断方法<br>
                    • 不支持冒泡的事件类型<br>
                    • 事件传播控制方法<br>
                    • 事件流的执行顺序<br>
                    • 事件委托的适用场景<br><br>
                    建议继续练习上方的交互演示，加深理解！
                </div>
            `;
        }

        function showAnswer() {
            if (currentQuiz >= quizQuestions.length) {
                alert('请先开始测试！');
                return;
            }

            const quiz = quizQuestions[currentQuiz];
            const quizLog = document.getElementById('quizLog');
            
            quizLog.innerHTML += `
                <div class="log-entry" style="border-left: 3px solid #3498db; background: rgba(52, 152, 219, 0.2); margin-top: 10px;">
                    <strong>💡 提示答案：</strong><br>
                    正确答案：${quiz.options[quiz.correct]}<br>
                    <strong>解释：</strong>${quiz.explanation}
                </div>
            `;
        }

        function resetQuiz() {
            currentQuiz = 0;
            const quizLog = document.getElementById('quizLog');
            quizLog.innerHTML = '<div class="log-entry">测试已重置，点击"开始测试"来重新开始...</div>';
        }

        // 页面加载完成提示
        window.addEventListener('load', function() {
            setTimeout(() => {
                alert('🎉 JavaScript事件机制教学演示已加载完成！\n\n请尝试:\n• 点击事件委托区域的方块\n• 点击事件流演示的嵌套元素\n• 尝试不同的按钮功能\n• 完成高频面试题测试\n\n观察控制台日志获取更多信息！');
            }, 1000);
        });
    </script>
</body>
</html>