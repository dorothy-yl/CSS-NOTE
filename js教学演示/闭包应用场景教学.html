<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 闭包应用场景教学</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', '微软雅黑', sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        h2 {
            color: #007bff;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }

        .demo-area {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #28a745;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        .output {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
            min-height: 30px;
        }

        .highlight {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #ffc107;
        }
    </style>
    <!-- 代码高亮样式 -->
    <link rel="stylesheet" href="../shared/code-highlight.css">
</head>
<body>
    <div class="container">
        <h1>🔒 JavaScript 闭包应用场景教学</h1>

        <div class="section">
            <h2>1. 数据私有化 - 模拟私有变量</h2>
            <p>闭包最经典的应用场景之一，创建私有变量，防止外部直接访问。</p>
            
            <div class="code-block">
function createCounter() {
    let count = 0; // 私有变量
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <button onclick="testCounter1()">计数+1</button>
                <button onclick="testCounter2()">计数-1</button>
                <button onclick="testCounter3()">获取计数</button>
                <button onclick="testCounter4()">尝试直接访问count</button>
                <div class="output" id="counter-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>2. 函数柯里化 (Currying)</h2>
            <p>将多个参数的函数转换为一系列单参数函数。</p>
            
            <div class="code-block">
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...nextArgs) {
                return curried.apply(this, args.concat(nextArgs));
            }
        }
    }
}

// 原始函数
function add(a, b, c) {
    return a + b + c;
}

const curriedAdd = curry(add);
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <button onclick="testCurry1()">正常调用 add(1,2,3)</button>
                <button onclick="testCurry2()">柯里化 curriedAdd(1)(2)(3)</button>
                <button onclick="testCurry3()">部分应用 curriedAdd(1,2)(3)</button>
                <div class="output" id="curry-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>3. 防抖和节流</h2>
            <p>利用闭包保存定时器状态，控制函数执行频率。</p>
            
            <div class="code-block">
// 防抖函数
function debounce(func, delay) {
    let timer;
    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// 节流函数
function throttle(func, delay) {
    let lastTime = 0;
    return function(...args) {
        let now = Date.now();
        if (now - lastTime > delay) {
            func.apply(this, args);
            lastTime = now;
        }
    };
}
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <input type="text" id="debounce-input" placeholder="输入文字测试防抖...">
                <button onclick="startThrottle()">开始节流测试</button>
                <button onclick="stopThrottle()">停止测试</button>
                <div class="output" id="debounce-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>4. 模块模式 (Module Pattern)</h2>
            <p>创建具有公共和私有方法的模块。</p>
            
            <div class="code-block">
const UserModule = (function() {
    // 私有变量和方法
    let users = [];
    let currentId = 1;
    
    function generateId() {
        return currentId++;
    }
    
    function validateUser(user) {
        return user && user.name && user.email;
    }
    
    // 公共接口
    return {
        addUser: function(name, email) {
            const user = { id: generateId(), name, email };
            if (validateUser(user)) {
                users.push(user);
                return user;
            }
            return null;
        },
        
        getUser: function(id) {
            return users.find(user => user.id === id);
        },
        
        getAllUsers: function() {
            return [...users]; // 返回副本
        },
        
        getUserCount: function() {
            return users.length;
        }
    };
})();
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <input type="text" id="username" placeholder="用户名">
                <input type="email" id="email" placeholder="邮箱">
                <button onclick="addUser()">添加用户</button>
                <button onclick="showUsers()">显示所有用户</button>
                <div class="output" id="module-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>5. 缓存函数 (Memoization)</h2>
            <p>利用闭包缓存函数计算结果，避免重复计算。</p>
            
            <div class="code-block">
function memoize(fn) {
    const cache = {};
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache[key]) {
            console.log('从缓存中获取结果');
            return cache[key];
        }
        
        console.log('计算新结果');
        const result = fn.apply(this, args);
        cache[key] = result;
        return result;
    };
}

// 斐波那契数列
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <input type="number" id="fib-input" placeholder="输入数字计算斐波那契" min="0" max="40">
                <button onclick="calcFib()">普通计算</button>
                <button onclick="calcMemoFib()">缓存计算</button>
                <div class="output" id="memo-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>6. 事件监听器管理</h2>
            <p>创建可以管理事件监听器的闭包函数。</p>
            
            <div class="code-block">
function createEventManager() {
    const listeners = new Map();
    
    return {
        on: function(event, callback) {
            if (!listeners.has(event)) {
                listeners.set(event, []);
            }
            listeners.get(event).push(callback);
        },
        
        off: function(event, callback) {
            if (listeners.has(event)) {
                const callbacks = listeners.get(event);
                const index = callbacks.indexOf(callback);
                if (index > -1) {
                    callbacks.splice(index, 1);
                }
            }
        },
        
        emit: function(event, ...args) {
            if (listeners.has(event)) {
                listeners.get(event).forEach(callback => {
                    callback(...args);
                });
            }
        },
        
        getListenerCount: function(event) {
            return listeners.has(event) ? listeners.get(event).length : 0;
        }
    };
}

const eventManager = createEventManager();
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <button onclick="addListener()">添加监听器</button>
                <button onclick="emitEvent()">触发事件</button>
                <button onclick="showListeners()">显示监听器数量</button>
                <div class="output" id="event-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>7. 单例模式 (Singleton Pattern)</h2>
            <p>确保一个类只有一个实例，并提供全局访问点。</p>
            
            <div class="code-block">
const Singleton = (function() {
    let instance;
    let instanceCount = 0;
    
    function createInstance() {
        instanceCount++;
        return {
            id: instanceCount,
            getData: function() {
                return `单例实例 ID: ${this.id}`;
            },
            timestamp: Date.now()
        };
    }
    
    return {
        getInstance: function() {
            if (!instance) {
                instance = createInstance();
            }
            return instance;
        },
        
        getInstanceCount: function() {
            return instanceCount;
        }
    };
})();
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <button onclick="getSingleton1()">获取实例1</button>
                <button onclick="getSingleton2()">获取实例2</button>
                <button onclick="compareSingleton()">比较两个实例</button>
                <div class="output" id="singleton-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>8. 工厂函数</h2>
            <p>使用闭包创建对象的工厂函数，封装对象创建逻辑。</p>
            
            <div class="code-block">
function createPersonFactory() {
    let personId = 0;
    const persons = [];
    
    return function(name, age, profession) {
        const id = ++personId;
        
        const person = {
            id,
            name,
            age,
            profession,
            introduce: function() {
                return `我是${this.name}，${this.age}岁，职业是${this.profession}`;
            },
            updateAge: function(newAge) {
                this.age = newAge;
                return this;
            }
        };
        
        persons.push(person);
        
        // 返回带有额外方法的对象
        return Object.assign(person, {
            getAllPersons: () => persons.slice(),
            getTotalCount: () => persons.length
        });
    };
}

const PersonFactory = createPersonFactory();
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <input type="text" id="person-name" placeholder="姓名">
                <input type="number" id="person-age" placeholder="年龄">
                <input type="text" id="person-profession" placeholder="职业">
                <button onclick="createPerson()">创建人员</button>
                <button onclick="showAllPersons()">显示所有人员</button>
                <div class="output" id="factory-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>9. 循环中的异步问题解决</h2>
            <p>经典的闭包应用场景：解决循环中异步操作的变量捕获问题。</p>
            
            <div class="code-block">
// 问题代码 - 都会输出3
function problemCode() {
    for (var i = 0; i < 3; i++) {
        setTimeout(function() {
            console.log('问题代码输出:', i); // 都是3
        }, 100 * i);
    }
}

// 解决方案1：使用闭包
function solutionWithClosure() {
    for (var i = 0; i < 3; i++) {
        (function(j) {
            setTimeout(function() {
                console.log('闭包解决方案输出:', j);
            }, 100 * j);
        })(i);
    }
}

// 解决方案2：使用let
function solutionWithLet() {
    for (let i = 0; i < 3; i++) {
        setTimeout(function() {
            console.log('let解决方案输出:', i);
        }, 100 * i);
    }
}

// 解决方案3：使用bind
function solutionWithBind() {
    for (var i = 0; i < 3; i++) {
        setTimeout(function(j) {
            console.log('bind解决方案输出:', j);
        }.bind(null, i), 100 * i);
    }
}
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <button onclick="testProblemCode()">问题代码</button>
                <button onclick="testClosureSolution()">闭包解决</button>
                <button onclick="testLetSolution()">let解决</button>
                <button onclick="testBindSolution()">bind解决</button>
                <div class="output" id="async-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>10. 偏函数应用 (Partial Application)</h2>
            <p>创建一个新函数，其中一些参数已经被预设。</p>
            
            <div class="code-block">
function partial(fn, ...presetArgs) {
    return function(...laterArgs) {
        return fn(...presetArgs, ...laterArgs);
    };
}

// 原始函数
function multiply(a, b, c) {
    return a * b * c;
}

function greet(greeting, punctuation, name) {
    return `${greeting}, ${name}${punctuation}`;
}

// 创建偏函数
const double = partial(multiply, 2);
const sayHello = partial(greet, 'Hello', '!');
const multiplyBy10 = partial(multiply, 10);
            </div>
            
            <div class="demo-area">
                <h3>演示：</h3>
                <input type="number" id="partial-input1" placeholder="输入数字" value="5">
                <input type="number" id="partial-input2" placeholder="输入数字" value="3">
                <button onclick="testPartial1()">double(5, 3)</button>
                <button onclick="testPartial2()">multiplyBy10(2, 4)</button>
                <input type="text" id="name-input" placeholder="输入姓名" value="张三">
                <button onclick="testPartial3()">sayHello('张三')</button>
                <div class="output" id="partial-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>11. 状态机 (State Machine)</h2>
            <p>使用闭包维护状态转换逻辑。</p>
            
            <div class="code-block">
function createStateMachine(initialState, transitions) {
    let currentState = initialState;
    const history = [initialState];
    
    return {
        getCurrentState: function() {
            return currentState;
        },
        
        transition: function(action) {
            const possibleStates = transitions[currentState];
            
            if (possibleStates && possibleStates[action]) {
                const previousState = currentState;
                currentState = possibleStates[action];
                history.push(currentState);
                
                return {
                    success: true,
                    from: previousState,
                    to: currentState,
                    action: action
                };
            }
            
            return {
                success: false,
                message: `无法从 ${currentState} 执行 ${action} 操作`
            };
        },
        
        getHistory: function() {
            return [...history];
        },
        
        canTransition: function(action) {
            const possibleStates = transitions[currentState];
            return possibleStates && possibleStates[action] !== undefined;
        }
    };
}

// 创建一个简单的门状态机
const doorStates = {
    'closed': { 'open': 'open' },
    'open': { 'close': 'closed', 'lock': 'locked' },
    'locked': { 'unlock': 'closed' }
};

const door = createStateMachine('closed', doorStates);
            </div>
            
            <div class="demo-area">
                <h3>演示 - 门的状态机：</h3>
                <button onclick="doorAction('open')">开门</button>
                <button onclick="doorAction('close')">关门</button>
                <button onclick="doorAction('lock')">锁门</button>
                <button onclick="doorAction('unlock')">开锁</button>
                <button onclick="showDoorState()">显示状态</button>
                <button onclick="showDoorHistory()">显示历史</button>
                <div class="output" id="state-output"></div>
            </div>
        </div>

        <div class="section">
            <h2>12. 计时器和延迟执行</h2>
            <p>使用闭包创建可控制的计时器。</p>
            
            <div class="code-block">
function createTimer() {
    let timerId = null;
    let startTime = null;
    let pauseTime = 0;
    let isRunning = false;
    
    return {
        start: function(callback, interval = 1000) {
            if (isRunning) return false;
            
            startTime = Date.now() - pauseTime;
            isRunning = true;
            
            timerId = setInterval(() => {
                const elapsed = Date.now() - startTime;
                callback(Math.floor(elapsed / 1000));
            }, interval);
            
            return true;
        },
        
        pause: function() {
            if (!isRunning) return false;
            
            clearInterval(timerId);
            pauseTime = Date.now() - startTime;
            isRunning = false;
            return true;
        },
        
        stop: function() {
            clearInterval(timerId);
            timerId = null;
            startTime = null;
            pauseTime = 0;
            isRunning = false;
            return true;
        },
        
        isRunning: function() {
            return isRunning;
        },
        
        getElapsed: function() {
            if (startTime === null) return 0;
            
            if (isRunning) {
                return Math.floor((Date.now() - startTime) / 1000);
            } else {
                return Math.floor(pauseTime / 1000);
            }
        }
    };
}

const timer = createTimer();
            </div>
            
            <div class="demo-area">
                <h3>演示 - 可控计时器：</h3>
                <button onclick="startTimer()">开始计时</button>
                <button onclick="pauseTimer()">暂停计时</button>
                <button onclick="stopTimer()">停止计时</button>
                <button onclick="showTimerStatus()">显示状态</button>
                <div class="output" id="timer-output">计时器: 0秒</div>
            </div>
        </div>

        <div class="highlight">
            <h3>💡 闭包的核心要点：</h3>
            <ul>
                <li><strong>词法作用域：</strong>函数可以访问定义时的外部变量</li>
                <li><strong>变量保持：</strong>外部函数执行完毕后，内部函数仍能访问外部变量</li>
                <li><strong>数据封装：</strong>创建私有变量，控制访问权限</li>
                <li><strong>状态保持：</strong>在函数调用之间保持状态</li>
                <li><strong>内存管理：</strong>注意避免内存泄漏</li>
            </ul>
        </div>
    </div>

    <script>
        // 1. 数据私有化演示
        const counter = (function() {
            let count = 0;
            return {
                increment: function() {
                    count++;
                    return count;
                },
                decrement: function() {
                    count--;
                    return count;
                },
                getCount: function() {
                    return count;
                }
            };
        })();

        function testCounter1() {
            const result = counter.increment();
            document.getElementById('counter-output').innerHTML = `计数器递增：${result}`;
        }

        function testCounter2() {
            const result = counter.decrement();
            document.getElementById('counter-output').innerHTML = `计数器递减：${result}`;
        }

        function testCounter3() {
            const result = counter.getCount();
            document.getElementById('counter-output').innerHTML = `当前计数：${result}`;
        }

        function testCounter4() {
            try {
                const result = counter.count;
                document.getElementById('counter-output').innerHTML = `直接访问count: ${result} (undefined - 无法直接访问私有变量)`;
            } catch (e) {
                document.getElementById('counter-output').innerHTML = `错误：${e.message}`;
            }
        }

        // 2. 柯里化演示
        function curry(fn) {
            return function curried(...args) {
                if (args.length >= fn.length) {
                    return fn.apply(this, args);
                } else {
                    return function(...nextArgs) {
                        return curried.apply(this, args.concat(nextArgs));
                    }
                }
            }
        }

        function add(a, b, c) {
            return a + b + c;
        }

        const curriedAdd = curry(add);

        function testCurry1() {
            const result = add(1, 2, 3);
            document.getElementById('curry-output').innerHTML = `正常调用结果：${result}`;
        }

        function testCurry2() {
            const result = curriedAdd(1)(2)(3);
            document.getElementById('curry-output').innerHTML = `柯里化调用结果：${result}`;
        }

        function testCurry3() {
            const result = curriedAdd(1, 2)(3);
            document.getElementById('curry-output').innerHTML = `部分应用结果：${result}`;
        }

        // 3. 防抖节流演示
        function debounce(func, delay) {
            let timer;
            return function(...args) {
                clearTimeout(timer);
                timer = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        function throttle(func, delay) {
            let lastTime = 0;
            return function(...args) {
                let now = Date.now();
                if (now - lastTime > delay) {
                    func.apply(this, args);
                    lastTime = now;
                }
            };
        }

        const debouncedSearch = debounce(function(value) {
            document.getElementById('debounce-output').innerHTML = `防抖搜索：${value}`;
        }, 500);

        document.getElementById('debounce-input').addEventListener('input', function(e) {
            debouncedSearch(e.target.value);
        });

        let throttleInterval;
        const throttledLog = throttle(function() {
            const time = new Date().toLocaleTimeString();
            document.getElementById('debounce-output').innerHTML = `节流执行时间：${time}`;
        }, 1000);

        function startThrottle() {
            if (throttleInterval) return;
            throttleInterval = setInterval(throttledLog, 100);
        }

        function stopThrottle() {
            if (throttleInterval) {
                clearInterval(throttleInterval);
                throttleInterval = null;
            }
        }

        // 4. 模块模式演示
        const UserModule = (function() {
            let users = [];
            let currentId = 1;
            
            function generateId() {
                return currentId++;
            }
            
            function validateUser(user) {
                return user && user.name && user.email;
            }
            
            return {
                addUser: function(name, email) {
                    const user = { id: generateId(), name, email };
                    if (validateUser(user)) {
                        users.push(user);
                        return user;
                    }
                    return null;
                },
                
                getUser: function(id) {
                    return users.find(user => user.id === id);
                },
                
                getAllUsers: function() {
                    return [...users];
                },
                
                getUserCount: function() {
                    return users.length;
                }
            };
        })();

        function addUser() {
            const name = document.getElementById('username').value;
            const email = document.getElementById('email').value;
            
            if (name && email) {
                const user = UserModule.addUser(name, email);
                if (user) {
                    document.getElementById('module-output').innerHTML = `添加用户成功：${JSON.stringify(user)}`;
                    document.getElementById('username').value = '';
                    document.getElementById('email').value = '';
                } else {
                    document.getElementById('module-output').innerHTML = '添加用户失败';
                }
            } else {
                document.getElementById('module-output').innerHTML = '请填写完整信息';
            }
        }

        function showUsers() {
            const users = UserModule.getAllUsers();
            const count = UserModule.getUserCount();
            document.getElementById('module-output').innerHTML = 
                `用户总数：${count}<br>用户列表：${JSON.stringify(users, null, 2)}`;
        }

        // 5. 缓存函数演示
        function memoize(fn) {
            const cache = {};
            
            return function(...args) {
                const key = JSON.stringify(args);
                
                if (cache[key]) {
                    document.getElementById('memo-output').innerHTML += '<br>从缓存中获取结果';
                    return cache[key];
                }
                
                document.getElementById('memo-output').innerHTML += '<br>计算新结果';
                const result = fn.apply(this, args);
                cache[key] = result;
                return result;
            };
        }

        function fibonacci(n) {
            if (n <= 1) return n;
            return fibonacci(n - 1) + fibonacci(n - 2);
        }

        const memoizedFib = memoize(fibonacci);

        function calcFib() {
            const n = parseInt(document.getElementById('fib-input').value);
            if (isNaN(n)) return;
            
            const start = Date.now();
            const result = fibonacci(n);
            const time = Date.now() - start;
            
            document.getElementById('memo-output').innerHTML = 
                `普通计算 fib(${n}) = ${result}，耗时：${time}ms`;
        }

        function calcMemoFib() {
            const n = parseInt(document.getElementById('fib-input').value);
            if (isNaN(n)) return;
            
            const start = Date.now();
            const result = memoizedFib(n);
            const time = Date.now() - start;
            
            document.getElementById('memo-output').innerHTML += 
                `<br>缓存计算 fib(${n}) = ${result}，耗时：${time}ms`;
        }

        // 6. 事件管理器演示
        const eventManager = (function() {
            const listeners = new Map();
            
            return {
                on: function(event, callback) {
                    if (!listeners.has(event)) {
                        listeners.set(event, []);
                    }
                    listeners.get(event).push(callback);
                },
                
                off: function(event, callback) {
                    if (listeners.has(event)) {
                        const callbacks = listeners.get(event);
                        const index = callbacks.indexOf(callback);
                        if (index > -1) {
                            callbacks.splice(index, 1);
                        }
                    }
                },
                
                emit: function(event, ...args) {
                    if (listeners.has(event)) {
                        listeners.get(event).forEach(callback => {
                            callback(...args);
                        });
                    }
                },
                
                getListenerCount: function(event) {
                    return listeners.has(event) ? listeners.get(event).length : 0;
                }
            };
        })();

        let listenerCount = 0;

        function addListener() {
            const callback = function(message) {
                document.getElementById('event-output').innerHTML += 
                    `<br>监听器${++listenerCount}收到消息：${message}`;
            };
            
            eventManager.on('test', callback);
            document.getElementById('event-output').innerHTML = 
                `添加了监听器，当前监听器数量：${eventManager.getListenerCount('test')}`;
        }

        function emitEvent() {
            eventManager.emit('test', `Hello at ${new Date().toLocaleTimeString()}`);
        }

        function showListeners() {
            const count = eventManager.getListenerCount('test');
            document.getElementById('event-output').innerHTML = `当前test事件的监听器数量：${count}`;
        }

        // 7. 单例模式演示
        const Singleton = (function() {
            let instance;
            let instanceCount = 0;
            
            function createInstance() {
                instanceCount++;
                return {
                    id: instanceCount,
                    getData: function() {
                        return `单例实例 ID: ${this.id}`;
                    },
                    timestamp: Date.now()
                };
            }
            
            return {
                getInstance: function() {
                    if (!instance) {
                        instance = createInstance();
                    }
                    return instance;
                },
                
                getInstanceCount: function() {
                    return instanceCount;
                }
            };
        })();

        let singletonInstance1, singletonInstance2;

        function getSingleton1() {
            singletonInstance1 = Singleton.getInstance();
            document.getElementById('singleton-output').innerHTML = 
                `实例1：${singletonInstance1.getData()}，时间戳：${singletonInstance1.timestamp}`;
        }

        function getSingleton2() {
            singletonInstance2 = Singleton.getInstance();
            document.getElementById('singleton-output').innerHTML = 
                `实例2：${singletonInstance2.getData()}，时间戳：${singletonInstance2.timestamp}`;
        }

        function compareSingleton() {
            if (singletonInstance1 && singletonInstance2) {
                const isSame = singletonInstance1 === singletonInstance2;
                document.getElementById('singleton-output').innerHTML = 
                    `两个实例是否相同：${isSame}<br>实例创建总数：${Singleton.getInstanceCount()}`;
            } else {
                document.getElementById('singleton-output').innerHTML = '请先获取两个实例';
            }
        }

        // 8. 工厂函数演示
        function createPersonFactory() {
            let personId = 0;
            const persons = [];
            
            return function(name, age, profession) {
                const id = ++personId;
                
                const person = {
                    id,
                    name,
                    age,
                    profession,
                    introduce: function() {
                        return `我是${this.name}，${this.age}岁，职业是${this.profession}`;
                    }
                };
                
                persons.push(person);
                
                return Object.assign(person, {
                    getAllPersons: () => persons.slice(),
                    getTotalCount: () => persons.length
                });
            };
        }

        const PersonFactory = createPersonFactory();

        function createPerson() {
            const name = document.getElementById('person-name').value;
            const age = parseInt(document.getElementById('person-age').value);
            const profession = document.getElementById('person-profession').value;
            
            if (name && age && profession) {
                const person = PersonFactory(name, age, profession);
                document.getElementById('factory-output').innerHTML = 
                    `${person.introduce()}<br>总人数：${person.getTotalCount()}`;
                
                // 清空输入框
                document.getElementById('person-name').value = '';
                document.getElementById('person-age').value = '';
                document.getElementById('person-profession').value = '';
            } else {
                document.getElementById('factory-output').innerHTML = '请填写完整信息';
            }
        }

        function showAllPersons() {
            const person = PersonFactory('临时', 0, '临时'); // 创建临时对象来访问方法
            const persons = person.getAllPersons();
            persons.pop(); // 移除临时对象
            
            if (persons.length === 0) {
                document.getElementById('factory-output').innerHTML = '暂无人员';
            } else {
                let html = `共${persons.length}个人员：<br>`;
                persons.forEach(p => {
                    html += `${p.id}. ${p.name}(${p.age}岁, ${p.profession})<br>`;
                });
                document.getElementById('factory-output').innerHTML = html;
            }
        }

        // 9. 循环异步问题演示
        function testProblemCode() {
            document.getElementById('async-output').innerHTML = '问题代码输出（都是3）：';
            for (var i = 0; i < 3; i++) {
                setTimeout(function() {
                    document.getElementById('async-output').innerHTML += ` ${i}`;
                }, 100 * i);
            }
        }

        function testClosureSolution() {
            document.getElementById('async-output').innerHTML = '闭包解决方案输出：';
            for (var i = 0; i < 3; i++) {
                (function(j) {
                    setTimeout(function() {
                        document.getElementById('async-output').innerHTML += ` ${j}`;
                    }, 100 * j);
                })(i);
            }
        }

        function testLetSolution() {
            document.getElementById('async-output').innerHTML = 'let解决方案输出：';
            for (let i = 0; i < 3; i++) {
                setTimeout(function() {
                    document.getElementById('async-output').innerHTML += ` ${i}`;
                }, 100 * i);
            }
        }

        function testBindSolution() {
            document.getElementById('async-output').innerHTML = 'bind解决方案输出：';
            for (var i = 0; i < 3; i++) {
                setTimeout(function(j) {
                    document.getElementById('async-output').innerHTML += ` ${j}`;
                }.bind(null, i), 100 * i);
            }
        }

        // 10. 偏函数应用演示
        function partial(fn, ...presetArgs) {
            return function(...laterArgs) {
                return fn(...presetArgs, ...laterArgs);
            };
        }

        function multiply(a, b, c) {
            return a * b * c;
        }

        function greet(greeting, punctuation, name) {
            return `${greeting}, ${name}${punctuation}`;
        }

        const double = partial(multiply, 2);
        const sayHello = partial(greet, 'Hello', '!');
        const multiplyBy10 = partial(multiply, 10);

        function testPartial1() {
            const val1 = parseInt(document.getElementById('partial-input1').value) || 5;
            const val2 = parseInt(document.getElementById('partial-input2').value) || 3;
            const result = double(val1, val2);
            document.getElementById('partial-output').innerHTML = 
                `double(${val1}, ${val2}) = 2 × ${val1} × ${val2} = ${result}`;
        }

        function testPartial2() {
            const val1 = parseInt(document.getElementById('partial-input1').value) || 2;
            const val2 = parseInt(document.getElementById('partial-input2').value) || 4;
            const result = multiplyBy10(val1, val2);
            document.getElementById('partial-output').innerHTML = 
                `multiplyBy10(${val1}, ${val2}) = 10 × ${val1} × ${val2} = ${result}`;
        }

        function testPartial3() {
            const name = document.getElementById('name-input').value || '张三';
            const result = sayHello(name);
            document.getElementById('partial-output').innerHTML = 
                `sayHello('${name}') = "${result}"`;
        }

        // 11. 状态机演示
        function createStateMachine(initialState, transitions) {
            let currentState = initialState;
            const history = [initialState];
            
            return {
                getCurrentState: function() {
                    return currentState;
                },
                
                transition: function(action) {
                    const possibleStates = transitions[currentState];
                    
                    if (possibleStates && possibleStates[action]) {
                        const previousState = currentState;
                        currentState = possibleStates[action];
                        history.push(currentState);
                        
                        return {
                            success: true,
                            from: previousState,
                            to: currentState,
                            action: action
                        };
                    }
                    
                    return {
                        success: false,
                        message: `无法从 ${currentState} 执行 ${action} 操作`
                    };
                },
                
                getHistory: function() {
                    return [...history];
                },
                
                canTransition: function(action) {
                    const possibleStates = transitions[currentState];
                    return possibleStates && possibleStates[action] !== undefined;
                }
            };
        }

        const doorStates = {
            'closed': { 'open': 'open' },
            'open': { 'close': 'closed', 'lock': 'locked' },
            'locked': { 'unlock': 'closed' }
        };

        const door = createStateMachine('closed', doorStates);

        function doorAction(action) {
            const result = door.transition(action);
            if (result.success) {
                document.getElementById('state-output').innerHTML = 
                    `执行${action}操作成功：${result.from} → ${result.to}`;
            } else {
                document.getElementById('state-output').innerHTML = 
                    `执行失败：${result.message}`;
            }
        }

        function showDoorState() {
            document.getElementById('state-output').innerHTML = 
                `当前门的状态：${door.getCurrentState()}`;
        }

        function showDoorHistory() {
            const history = door.getHistory();
            document.getElementById('state-output').innerHTML = 
                `状态历史：${history.join(' → ')}`;
        }

        // 12. 计时器演示
        function createTimer() {
            let timerId = null;
            let startTime = null;
            let pauseTime = 0;
            let isRunning = false;
            
            return {
                start: function(callback, interval = 1000) {
                    if (isRunning) return false;
                    
                    startTime = Date.now() - pauseTime;
                    isRunning = true;
                    
                    timerId = setInterval(() => {
                        const elapsed = Date.now() - startTime;
                        callback(Math.floor(elapsed / 1000));
                    }, interval);
                    
                    return true;
                },
                
                pause: function() {
                    if (!isRunning) return false;
                    
                    clearInterval(timerId);
                    pauseTime = Date.now() - startTime;
                    isRunning = false;
                    return true;
                },
                
                stop: function() {
                    clearInterval(timerId);
                    timerId = null;
                    startTime = null;
                    pauseTime = 0;
                    isRunning = false;
                    return true;
                },
                
                isRunning: function() {
                    return isRunning;
                },
                
                getElapsed: function() {
                    if (startTime === null) return 0;
                    
                    if (isRunning) {
                        return Math.floor((Date.now() - startTime) / 1000);
                    } else {
                        return Math.floor(pauseTime / 1000);
                    }
                }
            };
        }

        const timer = createTimer();

        function startTimer() {
            const success = timer.start(function(seconds) {
                document.getElementById('timer-output').innerHTML = `计时器: ${seconds}秒 (运行中)`;
            });
            
            if (success) {
                document.getElementById('timer-output').innerHTML = '计时器已开始';
            } else {
                document.getElementById('timer-output').innerHTML = '计时器已经在运行中';
            }
        }

        function pauseTimer() {
            const success = timer.pause();
            if (success) {
                const elapsed = timer.getElapsed();
                document.getElementById('timer-output').innerHTML = `计时器已暂停: ${elapsed}秒`;
            } else {
                document.getElementById('timer-output').innerHTML = '计时器未在运行';
            }
        }

        function stopTimer() {
            timer.stop();
            document.getElementById('timer-output').innerHTML = '计时器已停止: 0秒';
        }

        function showTimerStatus() {
            const elapsed = timer.getElapsed();
            const running = timer.isRunning();
            document.getElementById('timer-output').innerHTML = 
                `计时器状态：${running ? '运行中' : '已停止'}，已用时：${elapsed}秒`;
        }
    </script>
    <!-- 代码高亮脚本 -->
    <script src="../shared/code-highlight.js"></script>
</body>
</html>