# 前端面试题库 - 递进式面试题（UI + 功能 + 算法）

> 精选 16 套真实的前端面试题，按照难度递进：UI 实现 → 功能交互 → 算法设计

---

## 目录
1. [套题 1：搜索框](#套题-1搜索框)
2. [套题 2：日历选择器](#套题-2日历选择器)
3. [套题 3：评分组件](#套题-3评分组件)
4. [套题 4：树形菜单](#套题-4树形菜单)
5. [套题 5：拖拽排序列表](#套题-5拖拽排序列表)
6. [套题 6：虚拟滚动列表](#套题-6虚拟滚动列表)
7. [套题 7：轮播图](#套题-7轮播图)
8. [套题 8：电话拨号键盘（T9 输入法）](#套题-8电话拨号键盘t9-输入法)
9. [套题 9：无限滚动](#套题-9无限滚动)
10. [套题 10：模态框](#套题-10模态框)
11. [套题 11：表单验证](#套题-11表单验证)
12. [套题 12：标签页](#套题-12标签页)
13. [套题 13：图片懒加载](#套题-13图片懒加载)
14. [套题 14：倒计时](#套题-14倒计时)
15. [套题 15：进度条](#套题-15进度条)
16. [套题 16：TODO List](#套题-16todo-list)

---

## 套题 1：搜索框

### 第一题：UI 实现
**题目：** 实现下图的搜索框界面

```
┌─────────────────────────────────────────┐
│  🔍  Search...                      ✕   │
└─────────────────────────────────────────┘
     ┌───────────────────────────────────┐
     │ 🔍 apple                          │
     │ 🔍 application                    │
     │ 🔍 apply                          │
     │ 📝 Search history:                │
     │    • Previous search 1            │
     │    • Previous search 2            │
     └───────────────────────────────────┘
```

**UI 考点：**
- Flexbox 布局（输入框 + 图标对齐）
- 下拉列表的定位（absolute/relative）
- 列表项的 hover 效果
- 搜索图标和清空按钮的定位
- 阴影和圆角（box-shadow, border-radius）
- 分组样式（搜索建议 vs 历史记录）

**参考设计：** Google 搜索框、Algolia DocSearch

**真实题目链接：**
- 暂无公开题目（推荐自己设计）

---

### 第二题：功能实现
**题目：** 实现搜索框的交互功能

**功能考点：**
1. ⭐ **防抖（Debounce）** - 输入停止 300ms 后才触发搜索
2. ⭐ **键盘导航** - ArrowUp/Down 选择，Enter 确认，Esc 关闭
3. ⭐ **点击外部关闭** - useEffect + addEventListener + cleanup
4. **高亮匹配** - 正则替换或字符串分割
5. **历史记录** - localStorage 存储

---

### 第三题：算法

**LeetCode 题目：**
- **[208. Implement Trie (Prefix Tree)](https://leetcode.cn/problems/implement-trie-prefix-tree/)** ⭐⭐⭐
- **[1268. Search Suggestions System](https://leetcode.cn/problems/search-suggestions-system/)** ⭐⭐

**算法考点：**
- 前缀树（Trie）的构建
- 前缀匹配查找
- 字符串排序

---

## 套题 2：日历选择器

### 第一题：UI 实现
**题目：** 实现下图的日历界面

```
┌─────────────────────────────────┐
│  ← December 2024 →              │
├─────────────────────────────────┤
│ Sun Mon Tue Wed Thu Fri Sat     │
│                      1   2   3  │
│  4   5   6   7   8   9  10      │
│ 11  12  13  14 [15] 16  17      │
│ 18  19  20  21  22  23  24      │
│ 25  26  27  28  29  30  31      │
└─────────────────────────────────┘
      [Today] [Cancel] [Confirm]
```

**UI 考点：**
- Grid 布局（7列日期网格）
- 月份标题居中 + 左右箭头
- 当天高亮显示
- 选中日期样式（蓝色背景）
- 禁用日期样式（灰色）
- 范围选择的视觉效果（开始-结束之间的日期）

**参考设计：** Ant Design DatePicker、Material UI DatePicker

---

### 第二题：功能实现
**题目：** 实现日历的交互功能

**功能考点：**
1. ⭐ **日历渲染算法** - 计算当月第一天是星期几，需要显示几周
2. ⭐ **日期计算** - Date 对象操作，判断闰年，计算月份天数
3. ⭐ **范围选择逻辑** - 开始日期 + 结束日期，中间日期高亮
4. **月份切换** - 上一月/下一月计算（注意跨年）
5. **禁用日期判断** - 比较日期大小

---

### 第三题：算法

**LeetCode 题目：**
- **[1154. Day of the Year](https://leetcode.cn/problems/day-of-the-year/)** ⭐
- **[1185. Day of the Week](https://leetcode.cn/problems/day-of-the-week/)** ⭐

**算法考点：**
- 日期计算（闰年判断、月份天数）
- 蔡勒公式（计算星期几）
- 日期差值计算

---

## 套题 3：评分组件

### 第一题：UI 实现
**题目：** 实现下图的星级评分界面

```
Rating: 3.5 / 5.0

★ ★ ★ ⯨ ☆     (142 reviews)

Click to rate
```

**UI 考点：**
- 星星图标排列（Flexbox）
- 半星效果（CSS clip-path 或 linear-gradient）
- Hover 效果（鼠标悬停时预览）
- 不同状态的星星颜色（空星/满星/半星）
- 评分文字对齐

**参考设计：** Amazon 商品评分、IMDb 评分

**真实题目链接：**
- **[GreatFrontEnd - Star Rating](https://www.greatfrontend.com/questions/user-interface/star-rating)**
- **[Frontend Mentor - Interactive rating component](https://www.frontendmentor.io/challenges/interactive-rating-component-koxpeBUmI)**

---

### 第二题：功能实现
**题目：** 实现星级评分的交互功能

**功能考点：**
1. ⭐ **鼠标位置计算** - getBoundingClientRect() + event.clientX 判断左半边/右半边
2. ⭐ **Hover 预览逻辑** - hoverValue vs actualValue 状态管理
3. ⭐ **小数评分渲染** - 3.7 分 = 3 个满星 + 0.7 填充的半星
4. **只读/可编辑模式** - readonly 状态控制
5. **受控/非受控组件** - value vs defaultValue

---

### 第三题：算法

**前端评分组件的核心算法（真实场景）：**

评分组件的核心是**鼠标位置计算**和**小数评分渲染**，不需要复杂的统计算法。

**真实代码实现：**
```javascript
// 评分组件的真实算法需求
class StarRating {
  // 1. 根据鼠标位置计算评分（核心算法）
  calculateRating(event, starElement) {
    const rect = starElement.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const width = rect.width;
    const percentage = x / width;

    // 半星逻辑：< 0.5 为半星，>= 0.5 为满星
    return percentage < 0.5 ? 0.5 : 1;
  }

  // 2. 渲染小数评分（如 3.7 星）
  renderStars(rating) {
    const fullStars = Math.floor(rating); // 3
    const decimal = rating - fullStars;   // 0.7
    const halfStar = decimal >= 0.5 ? 1 : 0;
  }
}
```

**如果一定要 LeetCode 题目，推荐：**

**[215. Kth Largest Element in an Array](https://leetcode.cn/problems/kth-largest-element-in-an-array/)** ⭐⭐
- **真实场景**：找出第K高的评分（如找出前10%的高分商品）
- **算法考点**：快速选择算法、堆
- **实际应用**：筛选评分 >= 4.5 的优质商品

**注**：评分组件本身不需要复杂算法，主要考察 DOM 操作和数学计算。

---

## 套题 4：树形菜单

### 第一题：UI 实现
**题目：** 实现下图的树形文件浏览器

```
📁 src
  ▼ 📁 components
      📄 Button.tsx
      📄 Input.tsx
    📁 utils
  ▼ 📁 pages
      📄 Home.tsx
      📄 About.tsx
📁 public
📄 package.json
```

**UI 考点：**
- 树形缩进（padding-left 根据层级变化）
- 文件夹图标 vs 文件图标
- 展开/收起图标（▶ / ▼）
- 选中高亮效果
- Hover 效果
- 连接线（可选）

**参考设计：** VSCode 文件树、Windows 资源管理器

**真实题目链接：**
- **[GreatFrontEnd - File Explorer](https://www.greatfrontend.com/questions/user-interface/file-explorer)**

---

### 第二题：功能实现
**题目：** 实现树形菜单的交互功能

**功能考点：**
1. ⭐ **递归渲染** - 组件递归调用自身渲染子节点
2. ⭐ **树的遍历** - DFS/BFS 展开、收起、查找节点
3. ⭐ **搜索与路径** - 找到匹配节点，展开其所有父节点路径
4. **状态管理** - Set 存储 expandedKeys
5. **懒加载** - 点击展开时异步加载子节点

---

### 第三题：算法

**LeetCode 题目：**
- **[94. Binary Tree Inorder Traversal](https://leetcode.cn/problems/binary-tree-inorder-traversal/)** ⭐
- **[102. Binary Tree Level Order Traversal](https://leetcode.cn/problems/binary-tree-level-order-traversal/)** ⭐⭐
- **[297. Serialize and Deserialize Binary Tree](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)** ⭐⭐⭐

**算法考点：**
- 树的 DFS（前序/中序/后序）
- 树的 BFS（层序遍历）
- 树的序列化/反序列化

---

## 套题 5：拖拽排序列表

### 第一题：UI 实现
**题目：** 实现下图的可拖拽任务列表

```
My Tasks
┌─────────────────────────────────┐
│ ≡  Task 1: Buy groceries        │
├─────────────────────────────────┤
│ ≡  Task 2: Read book            │  ← (拖拽中，半透明)
├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤  ← (拖拽目标位置指示线)
│ ≡  Task 3: Write code           │
├─────────────────────────────────┤
│ ≡  Task 4: Exercise             │
└─────────────────────────────────┘
```

**UI 考点：**
- 拖拽手柄图标（≡）
- 拖拽中元素的样式（opacity: 0.5, shadow）
- 占位符样式（虚线边框）
- 插入位置指示线（border-top）
- 平滑过渡动画（transition）

**参考设计：** Trello、Notion、Jira

---

### 第二题：功能实现
**题目：** 实现拖拽排序功能

**功能考点：**
1. ⭐ **HTML5 Drag API** - dragstart, dragover, drop, dragend 事件
2. ⭐ **数组重排算法** - splice 实现从 index A 移动到 index B
3. ⭐ **拖拽视觉反馈** - dataTransfer, dropEffect, 占位符
4. **触摸事件** - 移动端支持（touchstart/move/end）
5. **跨列表拖拽** - 多个列表之间共享数据

**真实题目链接：**
- **[GreatFrontEnd - Sortable List](https://www.greatfrontend.com/questions/user-interface/sortable-list)**

---

### 第三题：算法

**前端拖拽列表的核心算法（真实场景）：**

拖拽列表的核心是**数组元素的删除和插入**，使用 `splice` 即可实现。

**真实代码实现：**

```javascript
// 拖拽列表的核心算法
class DragList {
  // 从 fromIndex 移动到 toIndex
  moveItem(items, fromIndex, toIndex) {
    // 1. 删除原位置的元素
    const [movedItem] = items.splice(fromIndex, 1);

    // 2. 插入到新位置
    items.splice(toIndex, 0, movedItem);

    return items;
  }

  // 跨列表拖拽
  moveItemBetweenLists(fromList, toList, fromIndex, toIndex) {
    const [item] = fromList.splice(fromIndex, 1);
    toList.splice(toIndex, 0, item);
  }
}
```

**如果一定要 LeetCode 题目，推荐：**

**[283. Move Zeroes](https://leetcode.cn/problems/move-zeroes/)** ⭐
- **真实场景**：移动元素到指定位置（保持相对顺序）
- **算法考点**：双指针、原地移动
- **实际应用**：类似拖拽时移动元素的逻辑

**注**：拖拽列表主要考察 DOM 操作和事件处理，数组操作用 `splice` 即可，不需要复杂算法。

---

## 套题 6：虚拟滚动列表

### 第一题：UI 实现
**题目：** 实现下图的长列表（显示 10000 条数据）

```
┌─────────────────────────────┐ ↑
│ Item 101                    │ │
│ Item 102                    │ │
│ Item 103                    │ │  (可见区域)
│ Item 104                    │ │
│ Item 105                    │ │
└─────────────────────────────┘ ↓
                               ║  (滚动条)
```

**UI 考点：**
- 固定高度容器 + overflow-y: auto
- 列表项统一高度
- 滚动条样式自定义
- Loading 状态

**参考设计：** Twitter 信息流、VSCode 文件列表

---

### 第二题：功能实现
**题目：** 实现虚拟滚动优化

**功能考点：**
1. ⭐ **可见区域计算** - scrollTop + containerHeight 计算 startIndex/endIndex
2. ⭐ **滚动条维护** - 用 spacer div 撑起总高度
3. ⭐ **偏移量定位** - transform: translateY() 定位可见元素
4. **缓冲区（Overscan）** - 上下多渲染几条，避免白屏
5. **动态高度** - ResizeObserver 测量高度
6. **滚动到指定位置** - scrollToIndex 实现

**真实题目链接：**
- **[Patterns.dev - List Virtualization](https://www.patterns.dev/vanilla/virtual-lists/)**
- **[Medium - Building a virtualized list from scratch](https://medium.com/ingeniouslysimple/building-a-virtualized-list-from-scratch-9225e8bec120)**

---

### 第三题：算法

**前端虚拟滚动的核心算法（真实场景）：**

虚拟滚动的核心是**数学计算可见范围**，不需要复杂的查找算法。

**真实代码实现：**

```javascript
// 虚拟滚动的核心算法
class VirtualScroll {
  constructor({ itemHeight = 50, containerHeight = 500, totalItems = 10000 }) {
    this.itemHeight = itemHeight;
    this.containerHeight = containerHeight;
    this.totalItems = totalItems;
  }

  // 核心算法：计算可见范围（线性计算，O(1) 时间复杂度）
  getVisibleRange(scrollTop) {
    // 1. 计算起始索引
    const startIndex = Math.floor(scrollTop / this.itemHeight);

    // 2. 计算结束索引
    const visibleCount = Math.ceil(this.containerHeight / this.itemHeight);
    const endIndex = Math.min(startIndex + visibleCount, this.totalItems);

    // 3. 缓冲区：多渲染上下各2条，避免白屏
    const overscan = 2;
    return {
      start: Math.max(0, startIndex - overscan),
      end: Math.min(this.totalItems, endIndex + overscan),
    };
  }

  // 计算偏移量
  getOffsetY(startIndex) {
    return startIndex * this.itemHeight;
  }

  // 总高度（撑起滚动条）
  getTotalHeight() {
    return this.totalItems * this.itemHeight;
  }
}
```

**注**：虚拟滚动主要考察**数学计算**和 **DOM 优化**，不需要 LeetCode 算法题。核心是理解可见区域计算和 `transform` 定位。

---

## 套题 7：轮播图

### 第一题：UI 实现
**题目：** 实现下图的图片轮播

```
┌────────────────────────────────────┐
│     ←                          →   │
│                                    │
│        [    Image 2/5    ]         │
│                                    │
└────────────────────────────────────┘
         ○ ○ ● ○ ○  (指示点)
```

**UI 考点：**
- 图片容器 + overflow: hidden
- 左右箭头按钮定位（absolute）
- 底部指示点（dots）居中
- 当前激活点的样式
- 图片标题/描述遮罩层

**参考设计：** Bootstrap Carousel、Swiper

---

### 第二题：功能实现
**题目：** 实现轮播图的交互功能

**功能考点：**
1. ⭐ **定时器管理** - setInterval 自动播放 + 清理
2. ⭐ **无限循环算法** - 克隆首尾元素实现无缝切换
3. ⭐ **CSS Transform 动画** - translateX 实现滑动
4. **触摸滑动** - touchstart/move/end 计算滑动方向
5. **Hover 暂停** - onMouseEnter/Leave 控制自动播放
6. **图片预加载** - new Image() 预加载下一张

**真实题目链接：**
- **[GreatFrontEnd - Carousel](https://www.greatfrontend.com/questions/user-interface/carousel)**
- **[Frontend Mentor - Testimonials slider](https://www.frontendmentor.io/challenges/testimonials-grid-section-Nnw6J7Un7)**

---

### 第三题：算法

**前端轮播图的核心算法（真实场景）：**

轮播图的核心是**索引循环**，使用取模运算即可实现，不需要数组旋转。

**真实代码实现：**

```javascript
// 轮播图的核心算法
class Carousel {
  constructor(images) {
    this.images = images;
    this.currentIndex = 0;
  }

  // 下一张（核心算法：取模实现循环）
  next() {
    this.currentIndex = (this.currentIndex + 1) % this.images.length;
    // 例如：3张图片，索引从 0 → 1 → 2 → 0 → 1 ...
  }

  // 上一张
  prev() {
    this.currentIndex = (this.currentIndex - 1 + this.images.length) % this.images.length;
    // 处理负数：-1 % 3 = -1，需要 +length 后再取模
  }

  // 无限循环的技巧（克隆首尾元素）
  setupInfiniteLoop() {
    // 在首部克隆最后一张，在尾部克隆第一张
    // [克隆3, 1, 2, 3, 克隆1]
    // 这样可以实现无缝循环的视觉效果
  }
}
```

**注**：轮播图主要考察**索引计算**、**定时器管理**和 **CSS Transform 动画**，不需要 LeetCode 算法题。核心是取模运算 `%` 和无限循环的实现技巧。

---

## 套题 8：电话拨号键盘（T9 输入法）

### 第一题：UI 实现
**题目：** 实现下图的电话拨号键盘

```
┌──────────────────────────────┐
│            0                 │  (显示区域)
└──────────────────────────────┘

┌────────┬────────┬────────┐
│   1    │ 2 ABC  │ 3 DEF  │
├────────┼────────┼────────┤
│ 4 GHI  │ 5 JKL  │ 6 MNO  │
├────────┼────────┼────────┤
│ 7 PQRS │ 8 TUV  │ 9 WXYZ │
├────────┼────────┼────────┤
│   *    │ 0 +    │   #    │
└────────┴────────┴────────┘
       [  Call  ] [ Cancel ]
```

**UI 考点：**
- Grid 布局（3x4 网格）
- 圆形按钮设计
- 数字和字母的排版
- 按钮 active 状态
- 响应式设计
- 深色主题（仿真手机）

**参考设计：** 苹果 iOS 拨号界面

---

### 第二题：功能实现
**题目：** 实现 T9 输入法功能

**功能考点：**
1. ⭐ **连击次数计算** - 同一按键多次点击循环输入字母
2. ⭐ **防抖判断** - 1 秒内没有新点击就确认输入
3. ⭐ **显示与确认分离** - 显示当前输入 vs 最终确认
4. **状态管理** - 记录当前按键、点击次数、定时器
5. **输入清除** - Backspace 删除最后一个字符
6. **长按支持** - 长按重复输入同一字符

---

### 第三题：算法

**LeetCode 题目：**
- **[17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)** ⭐⭐
- **[面试题 16.20. T9 键盘](https://leetcode.cn/problems/t9-lcci/)** ⭐⭐⭐

**算法考点：**
- 回溯算法（生成所有组合）
- 字符串映射
- 笛卡尔积

---

## 套题 9：无限滚动

### 第一题：UI 实现
**题目：** 实现一个无限滚动的新闻列表界面

```
┌────────────────────────────────┐
│ 📰 News Article 1              │
│    Lorem ipsum dolor sit...    │
├────────────────────────────────┤
│ 📰 News Article 2              │
│    Consectetur adipiscing...   │
├────────────────────────────────┤
│ 📰 News Article 3              │
│    Sed do eiusmod tempor...    │
├────────────────────────────────┤
│        ⏳ Loading more...      │
└────────────────────────────────┘
```

**UI 考点：**
- 列表布局（卡片式设计）
- Loading 骨架屏（Skeleton）
- 滚动到底部的视觉反馈
- 加载失败的错误状态
- "已加载全部"的提示

**真实题目链接：**
- **[GreatFrontEnd - Infinite Scroll](https://www.greatfrontend.com/questions/user-interface/infinite-scroll)**
- **[Frontend Mentor - News homepage](https://www.frontendmentor.io/challenges/news-homepage-H6SWTa1MFl)**

---

### 第二题：功能实现
**题目：** 实现无限滚动功能

**功能考点：**
1. ⭐ **Intersection Observer API** - 检测滚动到底部
2. ⭐ **异步数据加载** - 分页 API 请求（page, limit）
3. ⭐ **防止重复请求** - loading 状态标志位
4. **错误处理与重试** - 加载失败后重试机制
5. **滚动位置恢复** - 返回时恢复滚动位置
6. **内存管理** - 移除超出视口太远的元素

---

### 第三题：算法

**LeetCode 题目（贴合无限滚动真实场景）：**

1. **[88. Merge Sorted Array](https://leetcode.cn/problems/merge-sorted-array/)** ⭐
   - **真实场景**：分页数据合并 - 将新一页数据追加到现有列表
   - **算法考点**：数组合并
   - **实际应用**：`setItems([...existingList, ...newPageData])`

2. **[349. Intersection of Two Arrays](https://leetcode.cn/problems/intersection-of-two-arrays/)** ⭐
   - **真实场景**：数据去重 - 防止重复加载相同的数据
   - **算法考点**：哈希表、集合
   - **实际应用**：检查新加载的数据是否已存在，避免重复渲染

**推荐必做：** 88（分页合并）+ 349（去重）

---

## 套题 10：模态框

### 第一题：UI 实现
**题目：** 实现一个模态框组件

```
背景遮罩层（半透明黑色）
     ┌────────────────────────────┐
     │  ✕                         │
     │  Delete Item?              │
     │                            │
     │  Are you sure you want to  │
     │  delete this item?         │
     │                            │
     │  [Cancel]  [Delete]        │
     └────────────────────────────┘
```

**UI 考点：**
- 居中对齐（水平 + 垂直）
- 遮罩层（backdrop）
- 关闭按钮位置（右上角）
- 按钮组布局
- 动画效果（淡入淡出、缩放）
- 响应式设计（移动端全屏）

**真实题目链接：**
- **[GreatFrontEnd - Modal Dialog](https://www.greatfrontend.com/questions/user-interface/modal-dialog)**

---

### 第二题：功能实现
**题目：** 实现模态框的交互功能

**功能考点：**
1. ⭐ **焦点管理（Focus Trap）** - Tab 键只能在模态框内循环
2. ⭐ **键盘交互** - Esc 关闭，Enter 确认
3. ⭐ **Body 滚动锁定** - 打开模态框时禁止背景滚动
4. **Portal 渲染** - ReactDOM.createPortal 渲染到 body
5. **多层模态框** - 支持嵌套模态框（z-index 管理）
6. **无障碍访问** - aria-modal, role="dialog", aria-labelledby

---

### 第三题：算法

**LeetCode 题目（贴合模态框真实场景）：**

1. **[155. Min Stack](https://leetcode.cn/problems/min-stack/)** ⭐⭐
   - **真实场景**：多层模态框管理 - 栈结构追踪打开顺序
   - **算法考点**：栈的设计、辅助栈
   - **实际应用**：管理嵌套模态框的 z-index 和关闭顺序（后进先出）

2. **[20. Valid Parentheses](https://leetcode.cn/problems/valid-parentheses/)** ⭐
   - **真实场景**：检查模态框的配对关系 - 每个打开必须有对应关闭
   - **算法考点**：栈、括号匹配
   - **实际应用**：确保 openModal() 和 closeModal() 调用成对出现

**推荐必做：** 155（多层模态框管理核心）

---

## 套题 11：表单验证

### 第一题：UI 实现
**题目：** 实现一个注册表单

```
┌────────────────────────────────────┐
│  Register                          │
├────────────────────────────────────┤
│  Email *                           │
│  [                              ]  │
│  ✓ Valid email address             │
│                                    │
│  Password *                        │
│  [                              ]  │
│  ✗ Must be at least 8 characters   │
│                                    │
│  Confirm Password *                │
│  [                              ]  │
│  ✗ Passwords do not match          │
│                                    │
│  [ ] I agree to Terms & Conditions │
│                                    │
│  [      Sign Up      ]             │
└────────────────────────────────────┘
```

**UI 考点：**
- 表单布局（标签 + 输入框对齐）
- 错误提示样式（红色文字 + 图标）
- 成功提示样式（绿色文字 + 图标）
- 输入框状态（normal, focus, error, success）
- 必填标记（*）
- 按钮禁用状态

**真实题目链接：**
- **[Frontend Mentor - Intro component with signup form](https://www.frontendmentor.io/challenges/intro-component-with-signup-form-5cf91welr)**

---

### 第二题：功能实现
**题目：** 实现表单验证功能

**功能考点：**
1. ⭐ **实时验证（Real-time Validation）** - onChange vs onBlur
2. ⭐ **验证规则引擎** - 正则表达式、自定义验证函数
3. ⭐ **表单状态管理** - 字段值、错误、touched 状态
4. **异步验证** - 检查邮箱是否已注册（防抖）
5. **提交前验证** - 检查所有字段是否有效
6. **密码强度指示器** - 弱/中/强可视化

---

### 第三题：算法

**前端表单验证的核心算法（真实场景）：**

表单验证主要依赖**正则表达式**和**字符串处理**，而非 LeetCode 算法题。

**真实代码实现：**

```javascript
// 表单验证的真实实现
class FormValidator {
  // 邮箱验证
  validateEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
  }

  // 密码强度验证
  validatePassword(password) {
    // 至少8位，包含大小写字母和数字
    const hasLength = password.length >= 8;
    const hasUpper = /[A-Z]/.test(password);
    const hasLower = /[a-z]/.test(password);
    const hasNumber = /\d/.test(password);

    return hasLength && hasUpper && hasLower && hasNumber;
  }

  // 手机号验证（中国）
  validatePhone(phone) {
    const regex = /^1[3-9]\d{9}$/;
    return regex.test(phone);
  }

  // URL验证
  validateURL(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
}
```

**如果一定要 LeetCode 题目，推荐：**

**[468. Validate IP Address](https://leetcode.cn/problems/validate-ip-address/)** ⭐⭐
- **真实场景**：验证 IPv4/IPv6 地址格式
- **算法考点**：字符串分割、格式验证
- **实际应用**：表单中需要验证IP地址输入时使用

**注**：表单验证主要考察**正则表达式**和**业务逻辑**，不需要复杂算法。

---

## 套题 12：标签页

### 第一题：UI 实现
**题目：** 实现一个标签页组件

```
┌─────────────────────────────────────┐
│ [Home] [Profile] [Settings]        │
├─────────────────────────────────────┤
│                                     │
│  Home Content                       │
│  Welcome to the home page!          │
│                                     │
└─────────────────────────────────────┘
    ▔▔▔▔   (下划线跟随动画)
```

**UI 考点：**
- 标签栏布局（Flexbox）
- 激活状态样式（高亮、下划线）
- 下划线动画（跟随切换）
- 内容区域切换动画
- 响应式布局（移动端滚动）

**真实题目链接：**
- **[GreatFrontEnd - Tabs](https://www.greatfrontend.com/questions/user-interface/tabs)**

---

### 第二题：功能实现
**题目：** 实现标签页的交互功能

**功能考点：**
1. ⭐ **键盘导航** - Arrow Left/Right 切换标签
2. ⭐ **下划线跟随动画** - 计算目标标签的位置和宽度
3. ⭐ **URL 同步** - 使用 URL hash 或 query 参数
4. **懒加载内容** - 只渲染激活的标签内容
5. **受控/非受控模式** - activeTab prop vs defaultActiveTab
6. **无障碍访问** - role="tablist", aria-selected

---

### 第三题：算法

**LeetCode 题目（贴合标签页真实场景）：**

1. **[146. LRU Cache](https://leetcode.cn/problems/lru-cache/)** ⭐⭐
   - **真实场景**：标签页缓存策略 - 限制打开标签数量
   - **算法考点**：哈希表 + 双向链表
   - **实际应用**：最多保留10个标签，超出时移除最久未访问的标签

2. **[641. Design Circular Deque](https://leetcode.cn/problems/design-circular-deque/)** ⭐⭐
   - **真实场景**：标签切换历史记录（前进/后退）
   - **算法考点**：双端队列、循环数组
   - **实际应用**：浏览器标签的前进/后退功能

**推荐必做：** 146（缓存管理核心）

---

## 套题 13：图片懒加载

### 第一题：UI 实现
**题目：** 实现一个图片画廊

```
┌──────┐ ┌──────┐ ┌──────┐
│ IMG1 │ │ IMG2 │ │ IMG3 │
└──────┘ └──────┘ └──────┘
┌──────┐ ┌──────┐ ┌──────┐
│ 🔄   │ │ IMG5 │ │ IMG6 │  ← IMG4 加载中
└──────┘ └──────┘ └──────┘
┌──────┐ ┌──────┐ ┌──────┐
│      │ │      │ │      │  ← 未加载
└──────┘ └──────┘ └──────┘
```

**UI 考点：**
- 网格布局（Grid/Flexbox）
- 占位符（Placeholder）
- 加载骨架屏
- 加载失败状态
- 渐进式图片加载（模糊到清晰）

**真实题目链接：**
- **[Frontend Mentor - Galleria slideshow site](https://www.frontendmentor.io/challenges/galleria-slideshow-site-tEA4pwsa6)**

---

### 第二题：功能实现
**题目：** 实现图片懒加载功能

**功能考点：**
1. ⭐ **Intersection Observer** - 检测图片进入视口
2. ⭐ **渐进式加载** - 先加载缩略图，再加载高清图
3. ⭐ **加载状态管理** - loading, loaded, error
4. **图片预加载** - new Image() 预加载下一张
5. **响应式图片** - srcset, sizes 属性
6. **错误重试** - 加载失败后重试机制

---

### 第三题：算法

**LeetCode 题目（贴合图片懒加载真实场景）：**

1. **[146. LRU Cache](https://leetcode.cn/problems/lru-cache/)** ⭐⭐
   - **真实场景**：图片缓存管理 - 移除最久未使用的图片
   - **算法考点**：哈希表 + 双向链表
   - **实际应用**：缓存最近浏览的50张图片，超出时移除最久未使用的

2. **[621. Task Scheduler](https://leetcode.cn/problems/task-scheduler/)** ⭐⭐
   - **真实场景**：控制图片加载并发数 - 避免同时加载过多图片
   - **算法考点**：贪心算法、优先队列、任务调度
   - **实际应用**：最多同时加载6张图片，其他图片排队等待

**推荐必做：** 146（缓存核心）+ 621（并发控制）

---

## 套题 14：倒计时

### 第一题：UI 实现
**题目：** 实现一个倒计时组件

```
┌─────────────────────────────┐
│   Flash Sale Ends In:       │
│                             │
│   ┌───┐ ┌───┐ ┌───┐ ┌───┐  │
│   │ 2 │:│ 5 │:│ 3 │:│ 1 │  │
│   └───┘ └───┘ └───┘ └───┘  │
│   Days  Hrs  Mins  Secs     │
└─────────────────────────────┘
```

**UI 考点：**
- 数字翻页动画（Flip animation）
- 网格布局（时/分/秒）
- 进度条/圆环
- 到期状态样式
- 响应式设计

**真实题目链接：**
- **[Frontend Mentor - Launch countdown timer](https://www.frontendmentor.io/challenges/launch-countdown-timer-N0k2W0ypN)**

---

### 第二题：功能实现
**题目：** 实现倒计时功能

**功能考点：**
1. ⭐ **精确计时** - setInterval vs requestAnimationFrame
2. ⭐ **时间计算** - Date 对象，处理时区
3. ⭐ **页面不可见时的处理** - Page Visibility API
4. **暂停/恢复** - 暂停后恢复倒计时
5. **到期回调** - 倒计时结束后触发
6. **数字翻转动画** - CSS 3D transform

---

### 第三题：算法

**LeetCode 题目：**
- **[1154. Day of the Year](https://leetcode.cn/problems/day-of-the-year/)** ⭐
- **[1360. Number of Days Between Two Dates](https://leetcode.cn/problems/number-of-days-between-two-dates/)** ⭐

**算法考点：**
- 日期计算
- 时间戳转换

---

## 套题 15：进度条

### 第一题：UI 实现
**题目：** 实现一个文件上传进度条

```
Uploading file.pdf...
┌──────────────────────────────────┐
│████████████████░░░░░░░░░░░░░░░░░░│ 65%
└──────────────────────────────────┘
2.1 MB / 3.2 MB  •  30s remaining
```

**UI 考点：**
- 进度条填充动画
- 百分比文字居中
- 颜色变化（0-100% 渐变）
- 圆形进度条（SVG circle）
- 多段进度条（segmented）

**真实题目链接：**
- **[GreatFrontEnd - Progress Bar](https://www.greatfrontend.com/questions/user-interface/progress-bar)**

---

### 第二题：功能实现
**题目：** 实现进度条功能

**功能考点：**
1. ⭐ **文件上传进度** - XMLHttpRequest.upload.onprogress
2. ⭐ **平滑动画** - CSS transition vs requestAnimationFrame
3. ⭐ **剩余时间计算** - 基于已用时间和进度预估
4. **取消上传** - AbortController
5. **断点续传** - 记录已上传的部分
6. **多文件上传** - 并发控制（限制同时上传数量）

---

### 第三题：算法

**LeetCode 题目（贴合前端进度条真实场景）：**

1. **[346. Moving Average from Data Stream](https://leetcode.cn/problems/moving-average-from-data-stream/)** ⭐
   - **真实场景**：计算上传速度的滑动平均值（平滑速度波动）
   - **算法考点**：滑动窗口、队列
   - **实际应用**：每秒采样一次速度，取最近5秒的平均速度来预估剩余时间

2. **[933. Number of Recent Calls](https://leetcode.cn/problems/number-of-recent-calls/)** ⭐
   - **真实场景**：统计最近N秒内的请求数（监控上传频率）
   - **算法考点**：队列、时间窗口
   - **实际应用**：计算最近3秒内上传了多少个分片，用于动态调整并发数

**推荐必做：** 346（速度计算核心）+ 933（频率控制）

---

## 总结对比表

| 套题 | UI 难度 | 功能难度 | 核心考点1 | 核心考点2 | 核心考点3 | 真实题目 |
|------|---------|----------|-----------|-----------|-----------|---------|
| 搜索框 | ⭐⭐ | ⭐⭐⭐ | 防抖 | 键盘导航 | 点击外部关闭 | ❌ |
| 日历 | ⭐⭐ | ⭐⭐⭐ | 日期计算 | 日历算法 | 范围选择 | ❌ |
| 评分 | ⭐⭐⭐ | ⭐⭐⭐ | 鼠标位置计算 | Hover 状态 | 小数渲染 | ✅ GFE |
| 树形菜单 | ⭐⭐ | ⭐⭐⭐⭐ | 递归渲染 | 树的遍历 | 搜索与路径 | ✅ GFE |
| 拖拽列表 | ⭐⭐ | ⭐⭐⭐⭐ | Drag API | 数组重排 | 视觉反馈 | ✅ GFE |
| 虚拟滚动 | ⭐⭐ | ⭐⭐⭐⭐ | 可见区域计算 | 滚动条维护 | 偏移量计算 | ✅ |
| 轮播图 | ⭐⭐ | ⭐⭐⭐⭐ | 定时器管理 | 无限循环 | Transform 动画 | ✅ GFE |
| T9 输入法 | ⭐⭐ | ⭐⭐⭐ | 连击计算 | 防抖判断 | 显示确认分离 | ✅ |
| 无限滚动 | ⭐⭐ | ⭐⭐⭐ | Intersection Observer | 异步分页 | 防重复请求 | ✅ GFE |
| 模态框 | ⭐⭐⭐ | ⭐⭐⭐⭐ | Focus Trap | 键盘交互 | 滚动锁定 | ✅ GFE |
| 表单验证 | ⭐⭐ | ⭐⭐⭐⭐ | 实时验证 | 验证规则 | 异步验证 | ✅ FM |
| 标签页 | ⭐⭐ | ⭐⭐⭐ | 键盘导航 | 下划线动画 | URL 同步 | ✅ GFE |
| 图片懒加载 | ⭐⭐ | ⭐⭐⭐ | Intersection Observer | 渐进式加载 | 状态管理 | ✅ FM |
| 倒计时 | ⭐⭐⭐ | ⭐⭐⭐ | 精确计时 | 时间计算 | Visibility API | ✅ FM |
| 进度条 | ⭐⭐ | ⭐⭐⭐⭐ | Upload Progress | 平滑动画 | 时间预估 | ✅ GFE |

**图例说明：**
- ✅ GFE = GreatFrontEnd 有真实题目
- ✅ FM = Frontend Mentor 有真实题目
- ❌ = 暂无公开题目

---

## 推荐学习路线

### 初级（⭐⭐ - ⭐⭐⭐）
1. 搜索框
2. 日历选择器
3. 评分组件
4. T9 输入法（推荐先做这个）

### 中级（⭐⭐⭐ - ⭐⭐⭐⭐）
5. 树形菜单
6. 拖拽排序列表
7. 轮播图
8. 无限滚动
9. 标签页

### 高级（⭐⭐⭐⭐）
10. 虚拟滚动列表
11. 模态框
12. 表单验证
13. 图片懒加载
14. 倒计时
15. 进度条

---

## 常用 API 速查表

### 浏览器 API
| API | 用途 | 难度 |
|-----|------|------|
| `Intersection Observer` | 检测元素可见性 | ⭐⭐⭐ |
| `setTimeout/setInterval` | 定时器 | ⭐ |
| `requestAnimationFrame` | 帧动画 | ⭐⭐ |
| `HTML5 Drag API` | 拖拽 | ⭐⭐ |
| `XMLHttpRequest` | 文件上传进度 | ⭐⭐ |
| `AbortController` | 取消请求 | ⭐⭐ |
| `Page Visibility API` | 页面可见性 | ⭐⭐ |
| `ResizeObserver` | 元素大小变化监听 | ⭐⭐ |
| `MutationObserver` | DOM 变化监听 | ⭐⭐⭐ |
| `localStorage` | 本地存储 | ⭐ |
| `getBoundingClientRect()` | 元素位置信息 | ⭐⭐ |

### React Hooks
| Hook | 用途 | 难度 |
|------|------|------|
| `useState` | 状态管理 | ⭐ |
| `useEffect` | 副作用 | ⭐⭐ |
| `useRef` | 获取 DOM 引用 | ⭐⭐ |
| `useCallback` | 防止回调函数重新创建 | ⭐⭐⭐ |
| `useMemo` | 缓存计算结果 | ⭐⭐⭐ |
| `useContext` | 跨层级传递数据 | ⭐⭐ |

---

## 面试技巧

### 第一题（UI 实现）- 15-20 分钟
- ✅ 先确认需求（宽度、高度、响应式）
- ✅ 画出草图或找参考设计
- ✅ 选择合适的布局方案（Flexbox/Grid）
- ✅ 实现基础样式
- ✅ 添加细节（阴影、过渡、动画）

### 第二题（功能实现）- 30-40 分钟
- ✅ 了解复杂场景和边界情况
- ✅ 设计数据结构和状态管理
- ✅ 先实现核心逻辑
- ✅ 处理错误和异常
- ✅ 优化性能（防抖、节流、虚拟化）
- ✅ 添加无障碍支持

### 第三题（算法实现）- 20-30 分钟
- ✅ 理解题目，列举示例
- ✅ 推导解题思路
- ✅ 选择合适的数据结构
- ✅ 编写代码
- ✅ 分析时间/空间复杂度
- ✅ 优化解法

---

## 资源链接汇总

### 题库平台
- **[LeetCode 中文版](https://leetcode.cn/)** - 算法题库
- **[GreatFrontEnd](https://www.greatfrontend.com/)** - 前端面试题库（付费）
- **[Frontend Mentor](https://www.frontendmentor.io/)** - UI 实现挑战
- **[Big Frontend Dev](https://bigfrontend.dev/)** - 前端编码题库

### 学习资源
- **[Patterns.dev](https://www.patterns.dev/)** - 前端设计模式
- **[Web Dev](https://web.dev/)** - Google Web 开发指南
- **[MDN Web Docs](https://developer.mozilla.org/)** - Web API 文档
- **[JavaScript.info](https://javascript.info/)** - JavaScript 教程

### 工具
- **[CodePen](https://codepen.io/)** - 在线代码编辑器
- **[Figma](https://figma.com)** - UI 设计工具
- **[Chrome DevTools](https://developer.chrome.com/docs/devtools/)** - 调试工具

---

## 最后的建议

1. **循序渐进** - 从简单的题目开始，逐步提高难度
2. **深度理解** - 不仅要实现功能，还要理解背后的原理
3. **代码质量** - 注意变量命名、代码结构、注释
4. **性能优化** - 考虑防抖、节流、虚拟化等优化技术
5. **无障碍访问** - 添加 ARIA 属性，支持键盘导航
6. **错误处理** - 处理网络错误、边界情况、异常输入
7. **反复练习** - 同一道题目可以多次实现，每次都有新的收获

---

## 套题 16：TODO List

### 第一题：UI 实现
**题目：** 实现下图的待办事项列表界面

```
┌─────────────────────────────────────┐
│           My TODO List              │
├─────────────────────────────────────┤
│ ☐ Finish project documentation     │
│ ☑ Review pull requests             │
│ ☐ Prepare for team meeting         │
│ ☒ Update dependencies              │
├─────────────────────────────────────┤
│ [+] Add new task...                 │
├─────────────────────────────────────┤
│   2 of 4 tasks completed            │
│   ██████████░░░░░░░░░░░░░░░░░ 50%   │
└─────────────────────────────────────┘
```

**UI 考点：**
- 复选框状态（未完成☐/进行中☑/已完成☒）
- 任务项布局（checkbox + 文字 + 删除按钮）
- 添加新任务的输入框
- 进度条和统计信息
- 不同状态的任务样式（删除线、透明度）
- 批量操作按钮（全选、清除已完成）

**参考设计：** Todoist、Microsoft To Do、Apple Reminders

**真实题目链接：**
- **[GreatFrontEnd - Todo List](https://www.greatfrontend.com/questions/user-interface/todo-list)**
- **[Frontend Mentor - Todo app](https://www.frontendmentor.io/challenges/todo-app-GUg1hl1n_1)**

---

### 第二题：功能实现
**题目：** 实现待办事项列表的交互功能

**功能考点：**
1. ⭐ **CRUD 操作** - 添加、编辑、删除、标记完成状态
2. ⭐ **状态管理** - 使用 useState 或 useReducer 管理任务列表
3. ⭐ **本地持久化** - localStorage 自动保存和恢复
4. **过滤功能** - 显示全部/进行中/已完成任务
5. **拖拽排序** - 重新排列任务优先级
6. **搜索功能** - 根据任务内容过滤
7. **批量操作** - 全选、批量删除、批量标记完成
8. **快捷键支持** - Enter 添加任务，Delete 删除任务

---

### 第三题：算法

**LeetCode 题目（贴合 TODO List 真实场景）：**

1. **[239. Sliding Window Maximum](https://leetcode.cn/problems/sliding-window-maximum/)** ⭐⭐⭐
   - **真实场景**：显示最近N个任务中优先级最高的 - 快速找到需要关注的重要任务
   - **算法考点**：单调队列、滑动窗口、优先级队列
   - **实际应用**：在任务列表中快速定位"今日重要任务"，显示最近5个任务中优先级最高的

2. **[146. LRU Cache](https://leetcode.cn/problems/lru-cache/)** ⭐⭐⭐
   - **真实场景**：任务历史记录管理 - 限制显示的任务历史数量，移除最久未访问的任务
   - **算法考点**：哈希表 + 双向链表、缓存淘汰策略
   - **实际应用**：最近使用的任务置顶，超出显示数量限制时移除最久未访问的任务

3. **[346. Moving Average from Data Stream](https://leetcode.cn/problems/moving-average-from-data-stream/)** ⭐⭐
   - **真实场景**：任务完成率统计 - 计算最近一段时间内任务完成的平均速度
   - **算法考点**：滑动窗口、队列、数据流处理
   - **实际应用**：显示"最近7天平均每天完成3.2个任务"，帮助用户评估工作效率

**推荐必做：** 239（优先级队列核心）+ 146（缓存管理核心）

---

祝你面试顺利！💪
