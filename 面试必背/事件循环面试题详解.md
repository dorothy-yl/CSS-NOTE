# 事件循环（Event Loop）面试题详解

## 快速导航

| 章节 | 重要级别 | 核心内容 | 记忆口诀 |
|------|----------|----------|----------|
| [一、基础概念](#一基础概念) | ⭐⭐⭐⭐⭐ 🔥 ⚠️ | 事件循环机制、执行流程 | 同步先行、微任务紧随、宏任务轮询 |
| [二、宏任务与微任务](#二宏任务与微任务) | ⭐⭐⭐⭐⭐ 🔥 ⚠️ | 任务分类、执行优先级 | 宏观调度、微观处理 |
| [三、Promise执行顺序](#三promise执行顺序) | ⭐⭐⭐⭐⭐ 🔥 ⚠️ | Promise执行机制 | 构造同步、then异步、微任务队列 |
| [四、async/await机制](#四asyncawait与事件循环) | ⭐⭐⭐⭐⭐ 🔥 ⚠️ | async/await原理 | 语法糖、Promise封装、await后续微任务 |
| [五、Node vs 浏览器](#五nodejs与浏览器事件循环) | ⭐⭐⭐⭐ | 环境差异 | 浏览器清空微任务、Node逐个宏任务 |
| [六、单线程机制](#六javascript单线程机制) | ⭐⭐⭐⭐ | JavaScript单线程 | 单线程模型、多线程浏览器 |
| [七、实际应用](#七实际应用场景) | ⭐⭐⭐ | 应用场景 | 分片执行、避免阻塞 |
| [八、常见陷阱](#八常见面试陷阱) | ⭐⭐⭐⭐⭐ 🔥 | 面试陷阱题 | 仔细分析、步骤拆解 |
| [九、性能优化](#九性能优化) | ⭐⭐⭐ | 优化技巧 | RAF动画、微任务优先 |
| [十、核心速记](#十核心知识点速记) | ⭐⭐⭐⭐⭐ 🔥 ⚠️ | 快速复习 | 必背重点 |

---

## 一、基础概念

### ⭐⭐⭐⭐⭐ 🔥 ⚠️ 1. 什么是事件循环？【核心必背】

**记忆口诀：同步先行、微任务紧随、宏任务轮询**

**答案：**
事件循环是JavaScript处理异步操作的机制，它确保JavaScript单线程能够处理非阻塞的异步操作。

**核心组件：**
- **调用栈（Call Stack）**：执行同步代码的地方，遵循LIFO（后进先出）原则
- **宏任务队列（Macrotask Queue）**：存放setTimeout、setInterval等宏任务
- **微任务队列（Microtask Queue）**：存放Promise、MutationObserver等微任务
- **事件循环**：不断检查调用栈和任务队列的机制

**工作原理（三步口诀）：**
```
第一步：同步先行 - 执行调用栈中的同步代码
第二步：微任务紧随 - 调用栈清空后，清空所有微任务队列
第三步：宏任务轮询 - 执行一个宏任务，然后回到第二步
```

**执行流程图：**
```
┌───────────────────────────┐
│  1. 执行同步代码          │
│  (调用栈中的代码)          │
└───────────┬───────────────┘
            ↓
┌───────────────────────────┐
│  2. 清空微任务队列        │ ← 口诀：微任务紧随
│  (Promise.then/catch)      │   (清空所有微任务)
└───────────┬───────────────┘
            ↓
┌───────────────────────────┐
│  3. 执行一个宏任务        │ ← 口诀：宏任务轮询
│  (setTimeout/setInterval)  │   (只执行一个)
└───────────┬───────────────┘
            ↓
    回到步骤2 (循环)
```

---

## 二、宏任务与微任务

### ⭐⭐⭐⭐⭐ 🔥 ⚠️ 2. 宏任务和微任务的区别？【核心必背】

**记忆口诀：宏观调度、微观处理**

#### 宏任务 vs 微任务对比表

| 对比维度 | 宏任务（Macrotask） | 微任务（Microtask） |
|---------|-------------------|-------------------|
| **执行时机** | 每次事件循环执行**一个** | 每次清空**整个队列** |
| **执行顺序** | 较晚执行 | 优先执行 |
| **常见API** | setTimeout, setInterval, setImmediate, I/O, UI渲染, script标签 | Promise.then/catch/finally, queueMicrotask, MutationObserver, process.nextTick |
| **执行特点** | 宏观调度，粒度较大 | 微观处理，细粒度高 |
| **队列关系** | 每轮只执行一个宏任务 | 一次性清空所有微任务 |
| **应用场景** | 定时器、事件回调、I/O操作 | Promise链、DOM变化监听 |

**口诀解释：**
- **宏观调度**：宏任务像是大的调度单位，每轮事件循环只处理一个
- **微观处理**：微任务像是小的处理单位，一次性全部处理完

**执行优先级（重要）：**
```
同步代码 > 微任务 > 宏任务
```

### ⭐⭐⭐⭐ 3. 为什么要区分宏任务和微任务？【高频考点】

**详细解释：**

1. **更精细的任务调度**
   - 微任务优先级高于宏任务，确保某些关键操作能及时执行
   - 在每个宏任务执行完后，会清空所有微任务队列

2. **避免视觉延迟**
   - 微任务在渲染前执行，可以在一次事件循环中完成状态更新
   - Promise、MutationObserver等微任务能保证在下次渲染前完成

3. **保证执行顺序的可预测性**
   - 固定的执行顺序：宏任务 → 清空微任务队列 → 渲染
   - 避免了异步操作的竞态条件

4. **性能优化**
   - 将相关的操作放在微任务中批量处理
   - 减少不必要的渲染次数

**执行时机对比：**
```javascript
// 宏任务 - 下一个事件循环
setTimeout(() => {
  document.getElementById('div').style.color = 'red';
  // 可能会有一帧的延迟
}, 0);

// 微任务 - 当前事件循环末尾
Promise.resolve().then(() => {
  document.getElementById('div').style.color = 'blue';
  // 在当前帧渲染前执行
});
```

**面试背诵版：**

区分宏微任务主要有四个原因：
1. 更精细的任务调度 - 微任务优先级更高，确保关键操作及时执行
2. 避免视觉延迟 - 微任务在渲染前执行，减少页面闪烁
3. 保证执行顺序可预测 - 固定的事件循环机制
4. 性能优化 - 批量处理相关操作，减少渲染次数

---

## 三、Promise执行顺序

### ⭐⭐⭐⭐⭐ 🔥 ⚠️ 4. Promise执行顺序分析【核心必背】

**记忆口诀：构造同步、then异步、微任务队列**

#### Promise执行顺序图解

```
Promise执行顺序三步法：

第一步：构造同步
  ├─ new Promise(executor) 中的代码是同步执行的
  └─ executor函数立即执行

第二步：then异步
  ├─ .then()、.catch()、.finally() 都是异步的
  └─ 会被添加到微任务队列

第三步：微任务队列
  ├─ 在当前同步代码执行完后执行
  └─ 在宏任务之前执行
```

#### 经典题目1：基础执行顺序

**分析口诀：同步先行、微任务紧随、宏任务轮询**

```javascript
console.log('1'); // 同步代码

setTimeout(() => {
  console.log('2'); // 宏任务
}, 0);

Promise.resolve().then(() => {
  console.log('3'); // 微任务
});

console.log('4'); // 同步代码

// 执行步骤分析（使用口诀）：
// 第一步：同步先行 → 输出 1, 4
// 第二步：微任务紧随 → 输出 3
// 第三步：宏任务轮询 → 输出 2

// 最终输出：1, 4, 3, 2
```

#### 经典题目2：复杂执行顺序

**分析方法（五步法）：**
```
1. 标记所有同步代码
2. 标记所有微任务
3. 标记所有宏任务
4. 按口诀顺序执行
5. 注意：每个宏任务后清空微任务
```

```javascript
console.log('start'); // 同步1

setTimeout(() => {
  console.log('timeout1'); // 宏任务1
  Promise.resolve().then(() => {
    console.log('promise1'); // 微任务2（宏任务1产生）
  });
}, 0);

setTimeout(() => {
  console.log('timeout2'); // 宏任务2
  Promise.resolve().then(() => {
    console.log('promise2'); // 微任务3（宏任务2产生）
  });
}, 0);

Promise.resolve().then(() => {
  console.log('promise3'); // 微任务1
});

console.log('end'); // 同步2

// 执行步骤分析（使用五步法）：

// 第一轮事件循环：
// 1. 同步先行：start, end
// 2. 微任务紧随：promise3
// 3. 宏任务轮询：timeout1（执行第一个宏任务）

// 第二轮事件循环：
// 1. 同步代码：无
// 2. 微任务紧随：promise1（清空上一个宏任务产生的微任务）
// 3. 宏任务轮询：timeout2（执行第二个宏任务）

// 第三轮事件循环：
// 1. 同步代码：无
// 2. 微任务紧随：promise2
// 3. 宏任务轮询：无

// 最终输出：start, end, promise3, timeout1, promise1, timeout2, promise2
```

#### 经典题目3：Promise链式调用

```javascript
Promise.resolve()
  .then(() => {
    console.log('1'); // 微任务1
    return Promise.resolve(); // 注意：这里会产生额外的微任务
  })
  .then(() => {
    console.log('2'); // 微任务3（需要等待上面的Promise resolve）
  });

Promise.resolve()
  .then(() => {
    console.log('3'); // 微任务2
  })
  .then(() => {
    console.log('4'); // 微任务4
  });

// 执行分析：
// 微任务队列变化：
// 初始：[微任务1, 微任务2]
// 执行微任务1后：[微任务2, 返回的Promise]
// 执行微任务2后：[返回的Promise, 微任务4]
// 等待Promise resolve后：[微任务4, 微任务3]

// 最终输出：1, 3, 4, 2
```

---

## 四、async/await与事件循环

### ⭐⭐⭐⭐⭐ 🔥 ⚠️ 5. async/await执行机制【核心必背】

**记忆口诀：语法糖、Promise封装、await后续微任务**

#### async/await执行顺序图解

```
async/await转换规则：

async函数转换：
  async function fn() { }
  ↓ 等价于 ↓
  function fn() { return new Promise(...) }

await转换：
  await expression;
  后续代码;
  ↓ 等价于 ↓
  Promise.resolve(expression).then(() => {
    后续代码;
  });
```

#### 经典题目：async/await执行顺序

**分析方法：将async/await转换为Promise**

```javascript
async function async1() {
  console.log('async1 start'); // 同步1
  await async2(); // 这里会等待
  console.log('async1 end'); // 微任务2（await后续代码）
}

async function async2() {
  console.log('async2'); // 同步3
}

console.log('script start'); // 同步0

setTimeout(() => {
  console.log('setTimeout'); // 宏任务1
}, 0);

async1(); // 调用async1

new Promise(resolve => {
  console.log('promise1'); // 同步2
  resolve();
}).then(() => {
  console.log('promise2'); // 微任务1
});

console.log('script end'); // 同步4

// 转换后的代码（帮助理解）：
// async1() 相当于：
function async1() {
  console.log('async1 start');
  return Promise.resolve(async2()).then(() => {
    console.log('async1 end');
  });
}

// 执行步骤分析（使用口诀）：

// 第一步：同步先行
// 输出：script start, async1 start, async2, promise1, script end

// 第二步：微任务紧随
// 微任务队列：[async1 end, promise2]
// 输出：async1 end, promise2

// 第三步：宏任务轮询
// 输出：setTimeout

// 最终输出：
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

#### 关键点总结

| 概念 | 说明 | 记忆要点 |
|------|------|----------|
| async函数 | 返回Promise对象 | 语法糖、自动包装 |
| await表达式 | 等待Promise解析 | 暂停执行、后续微任务 |
| await后续代码 | 相当于.then()回调 | 微任务队列 |
| 执行顺序 | await前同步，后异步 | 分界线思维 |

---

## 五、Node.js与浏览器事件循环

### ⭐⭐⭐⭐ 6. Node.js和浏览器的事件循环区别【高频考点】

**记忆口诀：浏览器清空微任务、Node逐个宏任务；Node六阶段、timers最先、close最后**

#### 浏览器 vs Node.js 事件循环对比表

| 对比维度 | 浏览器 | Node.js |
|---------|--------|---------|
| **宏任务队列** | 单一队列 | 6个阶段的不同队列 |
| **执行策略** | 每个宏任务后清空所有微任务 | 每个阶段后清空微任务（Node 11+） |
| **微任务优先级** | Promise.then > queueMicrotask | process.nextTick > Promise.then |
| **特有API** | requestAnimationFrame, requestIdleCallback | process.nextTick, setImmediate |
| **执行粒度** | 一个宏任务 → 清空微任务 | 一个阶段 → 清空微任务 |
| **特点** | 简单直观 | 更复杂、分阶段 |

#### Node.js事件循环6个阶段

**记忆口诀：timers最先、close最后**

```
   ┌───────────────────────────┐
┌─>│  1. timers 阶段           │ ← 执行setTimeout/setInterval
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │  2. pending callbacks      │ ← 执行延迟到下一个循环的I/O回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │  3. idle, prepare          │ ← 仅内部使用
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │  4. poll 阶段             │ ← 获取新I/O事件，执行I/O回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │  5. check 阶段            │ ← 执行setImmediate
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──│  6. close callbacks       │ ← 执行close事件回调
   └───────────────────────────┘
```

**阶段详解：**
1. **timers**：执行setTimeout和setInterval回调
2. **pending callbacks**：执行延迟到下一个循环迭代的I/O回调
3. **idle, prepare**：内部使用
4. **poll**：获取新的I/O事件，执行相关回调（重点阶段）
5. **check**：执行setImmediate回调
6. **close callbacks**：执行关闭事件的回调（如socket.on('close')）

#### Node.js微任务优先级

```
process.nextTick > Promise.then > queueMicrotask
```

**示例：**
```javascript
// Node.js中的执行顺序
console.log('start');

setTimeout(() => console.log('setTimeout'), 0); // timers阶段
setImmediate(() => console.log('setImmediate')); // check阶段

process.nextTick(() => console.log('nextTick')); // 最高优先级微任务
Promise.resolve().then(() => console.log('promise')); // 微任务

console.log('end');

// 输出：
// start
// end
// nextTick (process.nextTick优先级最高)
// promise (Promise微任务)
// setTimeout (timers阶段，可能与setImmediate顺序不定)
// setImmediate (check阶段)
```

#### setTimeout vs setImmediate

**重要特性：**
```javascript
// 在主模块中，顺序不确定（取决于性能）
setTimeout(() => console.log('timeout'), 0);
setImmediate(() => console.log('immediate'));

// 在I/O回调中，setImmediate总是先执行
const fs = require('fs');
fs.readFile(__filename, () => {
  setTimeout(() => console.log('timeout'), 0);
  setImmediate(() => console.log('immediate'));
});
// 输出：immediate, timeout
```

---

## 六、JavaScript单线程机制

### ⭐⭐⭐⭐ 7. 如何理解"JavaScript是单线程的"？【高频考点】

**记忆口诀：单线程模型、多线程浏览器**

**答案：**
JavaScript是单线程的，但浏览器是多线程的：

#### JavaScript线程模型

```
JavaScript执行环境：

┌─────────────────────────────────────┐
│   浏览器（多线程）                   │
│  ┌───────────────────────────────┐  │
│  │ JavaScript引擎线程（单线程）   │  │ ← 主线程
│  └───────────────────────────────┘  │
│  ┌───────────────────────────────┐  │
│  │ GUI渲染线程                   │  │
│  └───────────────────────────────┘  │
│  ┌───────────────────────────────┐  │
│  │ 事件触发线程                   │  │
│  └───────────────────────────────┘  │
│  ┌───────────────────────────────┐  │
│  │ 定时器线程                     │  │
│  └───────────────────────────────┘  │
│  ┌───────────────────────────────┐  │
│  │ 异步HTTP请求线程               │  │
│  └───────────────────────────────┘  │
│  ┌───────────────────────────────┐  │
│  │ WebWorker线程                 │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

**为什么是单线程：**
1. **避免DOM操作冲突**：多线程同时操作DOM会导致竞态条件
2. **简化编程模型**：不需要考虑线程同步问题
3. **提高执行效率**：避免线程切换开销

**单线程的解决方案：**
- 事件循环机制处理异步操作
- 非阻塞I/O操作
- WebWorker处理CPU密集型任务

---

## 七、实际应用场景

### ⭐⭐⭐ 8. 事件循环在实际开发中的应用

**场景1：避免阻塞UI（分片执行）**
```javascript
// 错误做法：会阻塞UI
function heavyTask() {
  for (let i = 0; i < 1000000; i++) {
    // 大量计算
  }
}

// 正确做法：使用setTimeout分片执行
function heavyTaskOptimized() {
  let i = 0;
  function chunk() {
    const start = Date.now();
    // 每次执行不超过5ms
    while (i < 1000000 && Date.now() - start < 5) {
      // 处理一小部分数据
      i++;
    }
    if (i < 1000000) {
      setTimeout(chunk, 0); // 让出执行权，避免阻塞
    }
  }
  chunk();
}
```

**场景2：Promise链式调用**
```javascript
// 理解Promise在事件循环中的执行
Promise.resolve()
  .then(() => {
    console.log('1');
    return Promise.resolve();
  })
  .then(() => {
    console.log('2');
  });

setTimeout(() => {
  console.log('3');
}, 0);

console.log('4');

// 输出：4, 1, 2, 3
```

**场景3：async/await错误处理**
```javascript
async function fetchData() {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error:', error);
    // 错误处理在微任务队列中执行
  }
}
```

---

## 八、常见面试陷阱

### ⭐⭐⭐⭐⭐ 🔥 9. 事件循环的常见陷阱题目【核心必背】

**分析方法口诀：仔细分析、步骤拆解**

#### 陷阱1：setTimeout的延迟时间

```javascript
console.log('start');
setTimeout(() => console.log('timeout'), 0);
console.log('end');

// 输出：start, end, timeout
// 陷阱：即使延迟为0，setTimeout也是宏任务，会在微任务之后执行
// 记住：setTimeout(fn, 0) ≠ 立即执行
```

#### 陷阱2：Promise.resolve()的立即执行

```javascript
console.log('1');
Promise.resolve().then(() => console.log('2'));
console.log('3');

// 输出：1, 3, 2
// 陷阱：Promise.resolve()立即resolve，但.then()是微任务
// 记住：Promise构造函数同步，.then()异步
```

#### 陷阱3：async函数中的await

```javascript
async function test() {
  console.log('1');
  await console.log('2'); // 这里的console.log是同步执行的
  console.log('3');
}

console.log('4');
test();
console.log('5');

// 输出：4, 1, 2, 5, 3
// 陷阱：await console.log('2') 本身是同步执行
// await后面的代码（console.log('3')）才是微任务
```

#### 陷阱4：Promise构造函数执行时机

```javascript
console.log('1');

new Promise((resolve) => {
  console.log('2'); // 构造函数中的代码是同步的
  resolve();
  console.log('3'); // resolve()后的代码仍会同步执行
}).then(() => {
  console.log('4'); // .then()是微任务
});

console.log('5');

// 输出：1, 2, 3, 5, 4
// 陷阱：resolve()只是改变状态，不会阻止后续同步代码执行
```

#### 陷阱5：多层嵌套的Promise

```javascript
Promise.resolve().then(() => {
  console.log('1');
  Promise.resolve().then(() => {
    console.log('2');
  });
}).then(() => {
  console.log('3');
});

Promise.resolve().then(() => {
  console.log('4');
});

// 输出：1, 4, 2, 3
// 分析：
// 微任务队列变化：
// 初始：[微任务1, 微任务4]
// 执行微任务1后：[微任务4, 微任务2, 微任务3(pending)]
// 执行微任务4后：[微任务2, 微任务3(pending)]
// 执行微任务2后：[微任务3(resolved)]
// 执行微任务3后：[]
```

---

## 九、性能优化

### ⭐⭐⭐ 10. 如何利用事件循环优化性能？

**1. 使用requestAnimationFrame优化动画**
```javascript
function animate() {
  // 动画逻辑
  requestAnimationFrame(animate);
}
animate();
// 优点：与浏览器刷新率同步，避免不必要的渲染
```

**2. 使用MessageChannel实现任务调度**
```javascript
const channel = new MessageChannel();
const port1 = channel.port1;
const port2 = channel.port2;

port2.onmessage = function(event) {
  // 处理任务
};

function scheduleTask(task) {
  port1.postMessage(task);
}
// 优点：比setTimeout更精确，不受最小延迟限制
```

**3. 使用queueMicrotask处理微任务**
```javascript
function processData() {
  // 处理数据
  queueMicrotask(() => {
    // 微任务处理
  });
}
// 优点：显式创建微任务，语义清晰
```

**4. 使用WebWorker处理CPU密集型任务**
```javascript
// 主线程
const worker = new Worker('worker.js');
worker.postMessage(data);
worker.onmessage = (e) => {
  console.log('Result:', e.data);
};

// worker.js
self.onmessage = (e) => {
  // 执行密集计算
  const result = heavyComputation(e.data);
  self.postMessage(result);
};
// 优点：避免阻塞主线程
```

---

## 十、核心知识点速记

### ⭐⭐⭐⭐⭐ 🔥 ⚠️ 必背核心口诀

#### 1. 事件循环三步法
```
第一步：同步先行 - 执行所有同步代码
第二步：微任务紧随 - 清空所有微任务队列
第三步：宏任务轮询 - 执行一个宏任务，回到第二步
```

#### 2. 任务分类记忆
```
宏任务：setTimeout, setInterval, setImmediate, I/O, UI渲染
微任务：Promise.then, queueMicrotask, MutationObserver, process.nextTick
记忆：宏观调度、微观处理
```

#### 3. 执行优先级
```
同步代码 > 微任务 > 宏任务
Node.js: process.nextTick > Promise.then > setTimeout/setImmediate
```

#### 4. Promise执行规则
```
构造同步 - new Promise(executor)中的代码同步执行
then异步 - .then()/.catch()/.finally()是微任务
微任务队列 - 在同步代码后、宏任务前执行
```

#### 5. async/await转换
```
async function → 返回Promise
await expression → Promise.resolve(expression).then(...)
await后续代码 → 相当于.then()回调（微任务）
```

#### 6. Node.js六阶段
```
timers → pending callbacks → idle,prepare → poll → check → close
记忆：timers最先、close最后
特点：每个阶段后清空微任务（Node 11+）
```

#### 7. 浏览器 vs Node
```
浏览器：每个宏任务后清空所有微任务
Node.js：每个阶段后清空微任务
Node.js特有：process.nextTick优先级最高
```

---

## 十一、经典面试题汇总

### ⭐⭐⭐⭐⭐ 🔥 必练题目（带详细分析）

#### 题目1：综合执行顺序

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  Promise.resolve().then(() => {
    console.log('3');
  });
}, 0);

new Promise((resolve) => {
  console.log('4');
  resolve();
}).then(() => {
  console.log('5');
}).then(() => {
  console.log('6');
});

setTimeout(() => {
  console.log('7');
  Promise.resolve().then(() => {
    console.log('8');
  });
}, 0);

console.log('9');

// 分析步骤（使用口诀）：
// 1. 同步先行：1, 4, 9
// 2. 微任务紧随：5, 6
// 3. 宏任务轮询：2
// 4. 微任务紧随：3
// 5. 宏任务轮询：7
// 6. 微任务紧随：8

// 答案：1, 4, 9, 5, 6, 2, 3, 7, 8
```

#### 题目2：async/await复杂顺序

```javascript
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
  return 'async1 return';
}

async function async2() {
  console.log('async2');
  return 'async2 return';
}

console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

async1().then(res => {
  console.log(res);
});

new Promise(resolve => {
  console.log('promise1');
  resolve();
}).then(() => {
  console.log('promise2');
}).then(() => {
  console.log('promise3');
});

console.log('script end');

// 分析步骤：
// 1. 同步代码：script start, async1 start, async2, promise1, script end
// 2. 微任务队列：[async1 end, promise2]
//    执行：async1 end, promise2
// 3. 微任务队列：[async1 return, promise3]
//    执行：async1 return, promise3
// 4. 宏任务：setTimeout

// 答案：
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// async1 return
// promise3
// setTimeout
```

#### 题目3：Promise链式调用陷阱

```javascript
Promise.resolve()
  .then(() => {
    console.log('1');
    return Promise.resolve('2');
  })
  .then(res => {
    console.log(res);
  });

Promise.resolve()
  .then(() => {
    console.log('3');
  })
  .then(() => {
    console.log('4');
  })
  .then(() => {
    console.log('5');
  });

// 分析要点：
// return Promise.resolve() 会产生额外的微任务
// 微任务队列执行过程：
// 初始：[微任务1, 微任务3]
// 执行微任务1后：[微任务3, Promise.resolve('2')]
// 执行微任务3后：[Promise.resolve('2'), 微任务4]
// Promise.resolve('2')后：[微任务4, 微任务2]
// 执行微任务4后：[微任务2, 微任务5]
// 执行微任务2后：[微任务5]
// 执行微任务5后：[]

// 答案：1, 3, 4, 2, 5
```

#### 题目4：Node.js事件循环

```javascript
console.log('start');

setTimeout(() => {
  console.log('timer1');
  Promise.resolve().then(() => {
    console.log('promise1');
  });
}, 0);

setTimeout(() => {
  console.log('timer2');
  Promise.resolve().then(() => {
    console.log('promise2');
  });
}, 0);

Promise.resolve().then(() => {
  console.log('promise3');
});

process.nextTick(() => {
  console.log('nextTick');
});

console.log('end');

// Node.js环境分析：
// 1. 同步代码：start, end
// 2. process.nextTick：nextTick（最高优先级）
// 3. 微任务：promise3
// 4. timers阶段：timer1
// 5. 微任务：promise1
// 6. timers阶段：timer2
// 7. 微任务：promise2

// 答案：start, end, nextTick, promise3, timer1, promise1, timer2, promise2
```

#### 题目5：混合陷阱题

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  new Promise(resolve => {
    console.log('3');
    resolve();
  }).then(() => {
    console.log('4');
  });
}, 0);

new Promise(resolve => {
  console.log('5');
  resolve();
}).then(() => {
  console.log('6');
  setTimeout(() => {
    console.log('7');
  }, 0);
}).then(() => {
  console.log('8');
});

console.log('9');

// 分析步骤：
// 第一轮：
// - 同步：1, 5, 9
// - 微任务：6
// - 微任务（6产生）：8

// 第二轮：
// - 宏任务：2, 3（同步）
// - 微任务：4

// 第三轮：
// - 宏任务：7

// 答案：1, 5, 9, 6, 8, 2, 3, 4, 7
```

---

## 十二、答题模板和技巧

### ⭐⭐⭐⭐⭐ 🔥 面试答题模板

#### 模板1：事件循环基础问题

```
问：什么是事件循环？

答题框架：
1. 定义：事件循环是JavaScript处理异步操作的机制
2. 核心组件：调用栈、宏任务队列、微任务队列
3. 执行流程：同步先行、微任务紧随、宏任务轮询
4. 实际意义：确保单线程能处理非阻塞异步操作
```

#### 模板2：宏任务和微任务区别

```
问：宏任务和微任务有什么区别？

答题框架：
1. 定义区分：
   - 宏任务：setTimeout、setInterval、I/O等
   - 微任务：Promise.then、queueMicrotask等

2. 执行差异：
   - 宏任务：每轮执行一个
   - 微任务：一次性清空整个队列

3. 优先级：微任务 > 宏任务

4. 应用场景：
   - 宏任务：定时器、事件回调
   - 微任务：Promise链、状态更新

5. 实际意义：更精细的任务调度、避免视觉延迟
```

#### 模板3：代码执行顺序分析

```
分析方法（五步法）：

第一步：标记同步代码
- 找出所有直接执行的代码
- 包括Promise构造函数、async函数的await之前部分

第二步：标记微任务
- Promise.then/catch/finally
- queueMicrotask
- process.nextTick（Node.js）

第三步：标记宏任务
- setTimeout/setInterval
- setImmediate（Node.js）

第四步：应用口诀执行
- 同步先行
- 微任务紧随
- 宏任务轮询

第五步：注意特殊情况
- await后续代码是微任务
- 宏任务中产生的微任务要在下一轮清空
- Promise构造函数是同步的
```

### 答题技巧

#### 技巧1：使用口诀记忆
```
基础口诀：同步先行、微任务紧随、宏任务轮询
分类口诀：宏观调度、微观处理
Promise口诀：构造同步、then异步、微任务队列
async/await口诀：语法糖、Promise封装、await后续微任务
```

#### 技巧2：画图分析
```
遇到复杂题目，画出三列表格：
| 同步代码 | 微任务队列 | 宏任务队列 |
|---------|-----------|-----------|
| ...     | ...       | ...       |
```

#### 技巧3：分轮次分析
```
第一轮事件循环：
- 同步代码：...
- 微任务：...
- 宏任务：...

第二轮事件循环：
- 同步代码：...
- 微任务：...
- 宏任务：...
```

#### 技巧4：转换思维
```
遇到async/await，转换为Promise：
async function fn() {
  await expression;
  后续代码;
}
↓
function fn() {
  return Promise.resolve(expression).then(() => {
    后续代码;
  });
}
```

---

## 十三、总结

### ⭐⭐⭐⭐⭐ 🔥 核心要点

**必背知识点：**
1. **执行顺序**：同步代码 → 微任务 → 宏任务
2. **微任务优先级**：微任务 > 宏任务
3. **Promise规则**：构造同步、then异步
4. **async/await**：本质是Promise，遵循微任务规则
5. **单线程**：JavaScript主线程单线程，但浏览器多线程
6. **事件循环**：不断检查调用栈和任务队列的机制
7. **Node.js特点**：六个阶段、process.nextTick优先级最高

**必记口诀：**
```
事件循环三步法：同步先行、微任务紧随、宏任务轮询
任务分类口诀：宏观调度、微观处理
Promise口诀：构造同步、then异步、微任务队列
async/await口诀：语法糖、Promise封装、await后续微任务
Node.js口诀：六个阶段、timers最先、close最后
环境差异口诀：浏览器清空微任务、Node逐个宏任务
```

**面试重点：**
- 理解事件循环的执行机制
- 掌握宏任务和微任务的区别
- 能够分析复杂代码的执行顺序
- 了解Node.js和浏览器事件循环的差异
- 掌握实际应用场景和性能优化技巧

**答题思路：**
1. 先说定义和核心概念
2. 再说执行流程和规则
3. 最后举例说明实际应用

---

### 快速复习检查清单

```
□ 能默写事件循环三步法
□ 能列出宏任务和微任务的常见API
□ 能解释为什么要区分宏微任务
□ 能分析Promise执行顺序
□ 能转换async/await为Promise
□ 能说出Node.js六个阶段
□ 能对比浏览器和Node.js差异
□ 能做对经典面试题（80%正确率）
□ 能用口诀快速分析代码
□ 能应用到实际开发场景
```

**最后提醒：**
- 多练习经典题目，培养分析思路
- 使用口诀帮助记忆，而不是死记硬背
- 理解原理比记住结果更重要
- 面试时可以边画图边分析
- 遇到不确定的题目，用分轮次方法逐步拆解

祝你面试顺利！🎯