# 初级前端三天复习计划 - 第三天（完整版）

> 📅 **学习时间**：第三天 | **目标**：CSS收尾+Vue收尾+JS收尾+HTTP+AJAX+综合复习 | **建议时长**：8小时

## 📚 今日学习内容

| 模块 | 核心知识点 | 重要程度 | 预计时长 |
|------|-----------|---------|----------|
| **CSS收尾** | CSS单位、继承属性 | ⭐⭐⭐⭐ | 30分钟 |
| **Vue收尾** | v-if vs v-show、nextTick、路由传参 | ⭐⭐⭐⭐⭐ | 1小时 |
| **JavaScript收尾** | 数组方法、Promise、async/await | ⭐⭐⭐⭐⭐ | 2小时 |
| **HTTP和AJAX** | HTTP协议、状态码、缓存、跨域、AJAX | ⭐⭐⭐⭐⭐ | 2.5小时 |
| **综合复习** | 20道必答题 | ⭐⭐⭐⭐⭐ | 2小时 |

---

# 第一部分：CSS收尾

## 一、CSS单位 ⭐⭐⭐⭐⭐

### 常用单位对比

| 单位 | 类型 | 参考基准 | 响应式 | 应用场景 |
|------|------|----------|--------|----------|
| **px** | 绝对 | 固定像素 | ❌ | 边框、固定尺寸 |
| **rem** | 相对 | 根元素font-size | ✅ | 响应式布局 |
| **em** | 相对 | 父元素font-size | ✅ | 组件内部 |
| **%** | 相对 | 父元素尺寸 | ✅ | 宽高比例 |
| **vw/vh** | 相对 | 视口宽高 | ✅ | 全屏布局 |

### 详细说明

#### 1) px（像素）
```css
.box {
  width: 200px;     /* 固定200像素 */
  font-size: 16px;
}
```
- 绝对单位，显示器上的物理像素
- 每个像素大小固定
- 不会随屏幕尺寸变化

#### 2) rem（root em）
```css
html {
  font-size: 16px;  /* 根元素字体大小 */
}

.box {
  width: 10rem;     /* 10 * 16px = 160px */
  font-size: 1.5rem;  /* 1.5 * 16px = 24px */
}
```
- 相对于根元素(html)的font-size
- 修改html的font-size，所有rem单位的元素都会等比缩放
- 适合做响应式布局

**常用技巧：1rem = 10px**
```css
html {
  font-size: 62.5%;  /* 16px * 62.5% = 10px */
}

/* 现在 1rem = 10px，方便计算 */
.box {
  width: 20rem;  /* 200px */
  padding: 1.5rem;  /* 15px */
}
```

#### 3) em
```css
.parent {
  font-size: 20px;
}

.child {
  font-size: 1.5em;  /* 1.5 * 20px = 30px */
}
```
- 相对于父元素的font-size
- 会产生层层嵌套的倍数关系

**记忆口诀：**
```
px绝对固定、rem相对根元素
em相对父元素、vw/vh相对视口
```

---

## 二、CSS继承属性 ⭐⭐⭐

### 可继承属性

#### 1) 字体属性
- `font-family` - 字体系列
- `font-size` - 字体大小
- `font-weight` - 字体粗细
- `font-style` - 字体样式
- `font` - 字体简写

#### 2) 文本属性
- `color` - 文本颜色
- `line-height` - 行高
- `text-align` - 文本对齐
- `text-indent` - 文本缩进
- `letter-spacing` - 字符间距
- `word-spacing` - 单词间距

#### 3) 元素可见性
- `visibility` - 可见性

#### 4) 列表样式
- `list-style` - 列表样式
- `list-style-type` - 列表项标记
- `list-style-position` - 列表项位置

### 不可继承属性

- `display` - 显示类型
- `width`、`height` - 宽高
- `margin`、`padding` - 外边距、内边距
- `border` - 边框
- `position` - 定位
- `float` - 浮动
- `background` - 背景

**记忆口诀：**
```
字体文本可继承、颜色行高也能传
盒模型布局不继承、宽高边距各自算
```

---

# 第二部分：Vue收尾

## 一、v-if vs v-show ⭐⭐⭐⭐⭐

| 特性 | v-if | v-show |
|------|------|--------|
| DOM操作 | 销毁/重建 | 切换display |
| 初始成本 | 低 | 高 |
| 切换成本 | 高 | 低 |
| 使用场景 | 条件很少改变 | 频繁切换 |

```vue
<!-- v-if：条件不满足时不渲染 -->
<div v-if="isShow">内容</div>

<!-- v-show：始终渲染，只是切换display -->
<div v-show="isShow">内容</div>
```

**记忆口诀：**
```
if销毁show隐藏
if初始低show切换低
```

---

## 二、nextTick ⭐⭐⭐⭐⭐

**作用：** 在下次DOM更新循环结束后执行回调

**原理：**
- Vue数据更新是异步的
- 多次修改合并为一次更新
- 使用微任务（Promise.then）实现

```javascript
async function updateAndScroll() {
  message.value = 'Updated'
  await nextTick()
  // DOM已更新，可以安全操作DOM
  scrollToBottom()
}
```

**记忆口诀：**
```
微任务异步更新DOM
等待更新完成后执行
```

---

## 三、路由传参 ⭐⭐⭐⭐

| 特性 | query | params |
|------|-------|--------|
| URL显示 | ?id=123 | /user/123 |
| 路由配置 | 不需要 | 需配置:id |
| 传递方式 | path或name | 仅name |
| 使用场景 | 可选参数 | 必要参数 |

```javascript
// query - 显示在URL
router.push({ path: '/user', query: { id: 123 } })
const id = route.query.id

// params - 隐藏在路径
router.push({ name: 'User', params: { id: 123 } })
const id = route.params.id
```

**记忆口诀：**
```
query显示params隐藏
query不需配置params需配置
```

---

# 第三部分：JavaScript收尾

## 一、数组常用方法 ⭐⭐⭐⭐⭐

### 改变原数组的方法

```javascript
const arr = [1, 2, 3, 4, 5];

// push - 末尾添加
arr.push(6);        // [1, 2, 3, 4, 5, 6]

// pop - 末尾删除
arr.pop();          // [1, 2, 3, 4, 5]

// unshift - 开头添加
arr.unshift(0);     // [0, 1, 2, 3, 4, 5]

// shift - 开头删除
arr.shift();        // [1, 2, 3, 4, 5]

// splice - 删除/插入/替换
arr.splice(1, 2);   // [1, 4, 5] - 从索引1删除2个
arr.splice(1, 0, 2, 3); // [1, 2, 3, 4, 5] - 在索引1插入

// sort - 排序
arr.sort((a, b) => a - b);  // 升序

// reverse - 反转
arr.reverse();
```

### 不改变原数组的方法

```javascript
const arr = [1, 2, 3, 4, 5];

// map - 映射（返回新数组）
const doubled = arr.map(x => x * 2);  // [2, 4, 6, 8, 10]

// filter - 过滤
const evens = arr.filter(x => x % 2 === 0);  // [2, 4]

// reduce - 累加
const sum = arr.reduce((acc, cur) => acc + cur, 0);  // 15

// forEach - 遍历（无返回值）
arr.forEach(x => console.log(x));

// find - 查找第一个符合条件的元素
const found = arr.find(x => x > 3);  // 4

// findIndex - 查找索引
const index = arr.findIndex(x => x > 3);  // 3

// some - 是否有元素符合条件
const hasEven = arr.some(x => x % 2 === 0);  // true

// every - 是否所有元素符合条件
const allPositive = arr.every(x => x > 0);  // true

// slice - 切片
const sliced = arr.slice(1, 3);  // [2, 3]

// concat - 连接
const arr2 = [6, 7];
const combined = arr.concat(arr2);  // [1, 2, 3, 4, 5, 6, 7]

// join - 转字符串
const str = arr.join('-');  // '1-2-3-4-5'
```

**记忆口诀：**
```
push/pop末尾、unshift/shift开头
splice万能、sort排序reverse反转
map映射filter过滤、reduce累加forEach遍历
find查找some有没、every全部slice切片
```

---

## 二、Promise ⭐⭐⭐⭐⭐

### 三种状态
- pending（进行中）
- fulfilled（已成功）
- rejected（已失败）

### 基本使用

```javascript
// 创建Promise
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = true;
    if (success) {
      resolve('成功数据');
    } else {
      reject('失败原因');
    }
  }, 1000);
});

// 使用Promise
promise
  .then(data => {
    console.log('成功:', data);
    return data + ' 处理后';
  })
  .then(data => {
    console.log('链式:', data);
  })
  .catch(error => {
    console.error('失败:', error);
  })
  .finally(() => {
    console.log('无论成败都执行');
  });
```

### Promise常用方法

```javascript
// Promise.all - 所有成功才成功
Promise.all([p1, p2, p3])
  .then(results => console.log('都成功', results))
  .catch(error => console.log('有失败', error));

// Promise.race - 第一个完成
Promise.race([p1, p2])
  .then(result => console.log('最快', result));

// Promise.allSettled - 等待所有完成
Promise.allSettled([p1, p2])
  .then(results => console.log('所有都完成', results));

// Promise.resolve/reject - 快速创建
const resolved = Promise.resolve('成功');
const rejected = Promise.reject('失败');
```

---

## 三、async/await ⭐⭐⭐⭐⭐

```javascript
// async函数返回Promise
async function getData() {
  return '数据';
}

// await等待Promise完成
async function fetchData() {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('错误:', error);
  }
}

// 并行执行
async function fetchMultiple() {
  // 串行（慢）
  const data1 = await fetch('/api/1');
  const data2 = await fetch('/api/2');

  // 并行（快）
  const [data1, data2] = await Promise.all([
    fetch('/api/1'),
    fetch('/api/2')
  ]);
}
```

**记忆口诀：**
```
async返回Promise、await等待完成
try-catch捕获错误、并行用Promise.all
```

---

# 第四部分：HTTP和AJAX

## 一、HTTP vs HTTPS ⭐⭐⭐⭐⭐

| 对比项 | HTTP | HTTPS |
|--------|------|-------|
| 端口 | 80 | 443 |
| 安全性 | 明文传输 | SSL/TLS加密 |
| 证书 | 不需要 | 需要CA证书 |
| 速度 | 较快 | 较慢（加密解密） |

**记忆口诀：**
```
端口80和443、明文加密有区别
HTTP不安全、HTTPS要证书
```

---

## 二、GET vs POST ⭐⭐⭐⭐⭐

| 区别 | GET | POST |
|------|-----|------|
| 参数位置 | URL中 | 请求体中 |
| 数据大小 | 有限制（2KB） | 理论无限制 |
| 安全性 | 参数暴露 | 相对安全 |
| 缓存 | 可缓存 | 不可缓存 |
| 幂等性 | 幂等 | 非幂等 |
| 使用场景 | 查询数据 | 提交数据 |

```javascript
// GET
fetch('/api/users?id=1&name=张三')

// POST
fetch('/api/users', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ id: 1, name: '张三' })
})
```

**记忆口诀：**
```
GET显露POST隐藏（数据位置）
GET有限POST无限（数据大小）
GET可缓POST不缓（缓存特性）
```

---

## 三、HTTP状态码 ⭐⭐⭐⭐⭐

**2xx 成功：**
- 200 OK - 请求成功
- 201 Created - 创建成功
- 204 No Content - 成功但无返回

**3xx 重定向：**
- 301 Moved Permanently - 永久重定向
- 302 Found - 临时重定向
- 304 Not Modified - 资源未修改（缓存）

**4xx 客户端错误：**
- 400 Bad Request - 请求语法错误
- 401 Unauthorized - 未认证
- 403 Forbidden - 无权限
- 404 Not Found - 资源不存在

**5xx 服务器错误：**
- 500 Internal Server Error - 服务器内部错误
- 502 Bad Gateway - 网关错误
- 503 Service Unavailable - 服务不可用

**记忆口诀：**
```
1信息2成功3重定向
4客户错误5服务器错误
```

---

## 四、HTTP缓存 ⭐⭐⭐⭐⭐

### 缓存机制完整对比

| 对比项 | 强缓存 | 协商缓存 |
|--------|--------|----------|
| **是否发请求** | ❌ 不发请求 | ✅ 发请求验证 |
| **状态码** | 200 (from cache) | 304 Not Modified |
| **响应头** | Cache-Control / Expires | Last-Modified / ETag |
| **请求头** | 无 | If-Modified-Since / If-None-Match |
| **带宽消耗** | 0 | 少（只有header） |
| **速度** | 最快 | 较快 |
| **适用场景** | 不常变化的资源 | 可能变化的资源 |

### 1. 强缓存详解

**定义：** 浏览器直接从本地缓存获取资源，**不发送请求到服务器**。

#### Cache-Control（推荐使用）⭐⭐⭐⭐⭐
```javascript
// 常用指令
res.setHeader('Cache-Control', 'max-age=3600');           // 缓存1小时
res.setHeader('Cache-Control', 'max-age=31536000');       // 缓存1年
res.setHeader('Cache-Control', 'no-cache');               // 强制协商缓存
res.setHeader('Cache-Control', 'no-store');               // 完全不缓存
res.setHeader('Cache-Control', 'public, max-age=3600');   // 公共缓存
res.setHeader('Cache-Control', 'private, max-age=300');   // 私有缓存
```

**Cache-Control指令说明：**
- `max-age=<秒>` - 资源最大有效时间（相对时间）
- `no-cache` - 每次使用前必须验证（强制协商缓存）
- `no-store` - 禁止缓存，每次都重新请求
- `public` - 可被任何缓存（CDN、代理服务器）
- `private` - 只能被浏览器缓存
- `immutable` - 资源永远不会变（适合带hash的文件）

#### Expires（已过时）
```javascript
// 绝对时间，依赖客户端时间
res.setHeader('Expires', 'Wed, 21 Oct 2025 07:28:00 GMT');
```

**注意：** Cache-Control优先级高于Expires，推荐使用Cache-Control。

---

### 2. 协商缓存详解

**定义：** 浏览器发送请求到服务器验证资源是否过期，如果未过期返回304，否则返回新资源。

#### Last-Modified / If-Modified-Since（基于时间）

```javascript
// 服务器第一次响应
res.setHeader('Last-Modified', 'Wed, 21 Oct 2024 07:28:00 GMT');
res.setHeader('Cache-Control', 'no-cache'); // 强制协商缓存

// 浏览器第二次请求时会带上
req.headers['if-modified-since'] // 'Wed, 21 Oct 2024 07:28:00 GMT'

// 服务器判断
if (req.headers['if-modified-since'] === fileLastModified) {
  res.status(304).end(); // 未修改，返回304
} else {
  res.send(newContent); // 已修改，返回新内容
}
```

**优点：** 轻量，不需要计算
**缺点：**
- 精度只到秒，1秒内多次修改检测不到
- 只看时间，不看内容是否真的变了

#### ETag / If-None-Match（基于内容哈希）⭐⭐⭐⭐⭐

```javascript
// 服务器第一次响应（生成内容hash）
const crypto = require('crypto');
const content = fs.readFileSync('./file.js');
const hash = crypto.createHash('md5').update(content).digest('hex');
res.setHeader('ETag', `"${hash}"`);

// 浏览器第二次请求时会带上
req.headers['if-none-match'] // '"abc123def456..."'

// 服务器判断
if (req.headers['if-none-match'] === currentETag) {
  res.status(304).end(); // 内容未变，返回304
} else {
  res.send(newContent); // 内容已变，返回新内容
}
```

**优点：**
- 精确度高，只要内容变了就能检测到
- 不依赖时间
**缺点：** 需要计算hash，性能开销较大

#### ETag vs Last-Modified对比

| 对比项 | Last-Modified | ETag |
|--------|--------------|------|
| **基于** | 文件修改时间 | 文件内容哈希 |
| **精确度** | 秒级 | 非常精确 |
| **性能** | 轻量 | 需要计算hash |
| **优先级** | 低 | 高（优先判断） |
| **问题** | 1秒内多次修改检测不到 | 计算hash耗性能 |

---

### 3. 缓存策略最佳实践

```javascript
// HTML文件：协商缓存（保证获取最新）
app.get('/*.html', (req, res) => {
  res.set({
    'Cache-Control': 'no-cache',
    'ETag': calculateETag(content)
  });
  res.send(content);
});

// CSS/JS（带hash）：强缓存1年
// 如：app.a1b2c3d4.js
app.get('/static/*.js', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=31536000, immutable'
  });
  res.send(content);
});

// 图片：强缓存30天
app.get('/images/*', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=2592000'
  });
  res.send(image);
});

// API数据：不缓存
app.get('/api/*', (req, res) => {
  res.set({
    'Cache-Control': 'no-store'
  });
  res.json(data);
});
```

**记忆口诀：**
```
强缓存不发请求直接用、协商缓存发请求验证
强缓存200 from cache、协商缓存304未修改
ETag看内容更精确、Last-Modified看时间
```

---

## 五、跨域解决方案 ⭐⭐⭐⭐⭐

### 1. CORS（推荐）⭐⭐⭐⭐⭐
```javascript
// 服务器端设置
res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000');
res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE');
res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
```

### 2. JSONP（兼容老浏览器）
```javascript
function jsonp(url, callback) {
  const script = document.createElement('script');
  const callbackName = 'callback_' + Date.now();

  window[callbackName] = function(data) {
    callback(data);
    document.body.removeChild(script);
    delete window[callbackName];
  };

  script.src = `${url}?callback=${callbackName}`;
  document.body.appendChild(script);
}
```

### 3. 代理服务器
```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
}
```

**记忆口诀：**
```
CORS首选、JSONP兼容、代理万能
```

---

## 六、性能优化高级 ⭐⭐⭐⭐⭐

### 1. 虚拟滚动原理

**口诀：只渲染可见、大幅减少DOM**

#### 原理说明
```
10000条数据，只渲染可见的20条
通过计算scrollTop，动态更新可见区域
```

#### 核心步骤
1. 计算可见区域（根据scrollTop）
2. 只渲染可见元素（如20个）
3. 用padding撑起总高度
4. 监听scroll更新可见区域

**效果：** 10000条数据从渲染10000个DOM降到20个

#### 简化实现思路
```vue
<template>
  <div class="virtual-list" @scroll="handleScroll">
    <!-- 占位高度 -->
    <div :style="{ height: totalHeight + 'px' }"></div>

    <!-- 可见内容 -->
    <div :style="{ transform: `translateY(${offset}px)` }">
      <div v-for="item in visibleData" :key="item.id">
        {{ item.text }}
      </div>
    </div>
  </div>
</template>

<script setup>
// 每项高度50px，可见20项
// 根据scrollTop计算startIndex
// visibleData = allData.slice(startIndex, startIndex + 20)
</script>
```

---

### 2. Webpack基础优化

**口诀：代码分割、按需加载、压缩**

#### 1) 路由懒加载
```javascript
// ❌ 不好：一次加载所有
import Home from './Home.vue';
import About from './About.vue';

// ✅ 好：按需加载
const Home = () => import('./Home.vue');
const About = () => import('./About.vue');
```

**效果：** 首屏从1MB降到300KB

#### 2) 代码分割（splitChunks）
```javascript
// webpack.config.js
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendor: {
        test: /node_modules/,
        name: 'vendors',
        priority: 10
      }
    }
  }
}
```

**效果：** 第三方库单独打包，可长期缓存

#### 3) Gzip压缩
```javascript
// 服务器开启Gzip
gzip on;
gzip_types text/css application/javascript;
```

**效果：** 文件体积减少70-90%

---

### 3. 性能监控指标

**口诀：FCP、LCP、FID**

| 指标 | 含义 | 目标值 |
|------|------|--------|
| **FCP** | 首次内容绘制 | <1.8s |
| **LCP** | 最大内容绘制 | <2.5s |
| **FID** | 首次输入延迟 | <100ms |

**监控工具：**
- Chrome DevTools Performance
- Lighthouse性能评分
- Web Vitals库

---

**今日性能优化总结：**
- ✅ 虚拟滚动：只渲染可见区域
- ✅ Webpack优化：代码分割、懒加载、压缩
- ✅ 性能监控：FCP/LCP/FID指标

---

## 七、AJAX基础 ⭐⭐⭐⭐

### XMLHttpRequest五种状态

| 值 | 状态 | 说明 |
|----|------|------|
| 0 | UNSENT | 未调用open |
| 1 | OPENED | 已调用open |
| 2 | HEADERS_RECEIVED | 已接收响应头 |
| 3 | LOADING | 下载中 |
| 4 | DONE | 完成 |

### 完整代码示例

```javascript
// 1. 创建
const xhr = new XMLHttpRequest();

// 2. 配置
xhr.open('GET', '/api/data', true);

// 3. 设置请求头（可选）
xhr.setRequestHeader('Content-Type', 'application/json');

// 4. 监听状态变化
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log('成功:', xhr.response);
  }
};

// 5. 发送
xhr.send();

// POST请求示例
const xhrPost = new XMLHttpRequest();
xhrPost.open('POST', '/api/data', true);
xhrPost.setRequestHeader('Content-Type', 'application/json');
xhrPost.send(JSON.stringify({ name: 'test' }));
```

**记忆口诀：**
```
未开头载完（0未送、1已开、2头收、3载中、4完成）
创开发收（创建、打开、发送、接收）
```

---

## 七、Fetch API ⭐⭐⭐⭐

### 基本使用
```javascript
// 基本使用
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));

// async/await
async function getData() {
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}
```

### Fetch vs XHR

| 特性 | Fetch | XMLHttpRequest |
|------|-------|----------------|
| 返回值 | Promise | 回调 |
| 语法 | 简洁 | 复杂 |
| 进度监控 | 不支持 | 支持 |

---

# 第五部分：三天综合复习

## 20道必答题清单

### CSS（4题）

**1. 标准盒模型和IE盒模型的区别？**
<details>
<summary>点击查看答案</summary>

**区别：**
- **标准盒模型**：width只包含content
- **IE盒模型**：width包含content + padding + border

**代码：**
```css
/* 标准盒模型 */
.box {
  box-sizing: content-box;
  width: 200px;
  padding: 20px;
  border: 10px;
  /* 实际占用宽度 = 200 + 20*2 + 10*2 = 260px */
}

/* IE盒模型（推荐） */
.box {
  box-sizing: border-box;
  width: 200px;
  padding: 20px;
  border: 10px;
  /* 实际占用宽度 = 200px */
}
```
</details>

**2. CSS选择器优先级如何计算？**
<details>
<summary>点击查看答案</summary>

**优先级：** !important > 行内样式(1000) > ID(100) > 类/伪类/属性(10) > 标签(1) > 通配符(0)

**权重计算：**
```css
/* 权重 = 100 + 10 + 1 = 111 */
#header .nav li { color: red; }

/* 权重 = 10 + 10 + 1 = 21 */
.container .nav li { color: blue; }

/* 最终显示红色 */
```

**特殊规则：** 权重相同时，后定义覆盖先定义
</details>

**3. inline、block、inline-block的区别？**
<details>
<summary>点击查看答案</summary>

| 特性 | inline | block | inline-block |
|------|--------|-------|--------------|
| 独占一行 | ❌ | ✅ | ❌ |
| 可设宽高 | ❌ | ✅ | ✅ |
| 使用场景 | span、a | div、p | img、button |

**代码：**
```css
/* inline - 不能设宽高 */
span { width: 100px; /* ❌ 无效 */ }

/* block - 可以设宽高 */
div { width: 200px; /* ✅ 有效 */ }

/* inline-block - 可以设宽高且不换行 */
span {
  display: inline-block;
  width: 120px; /* ✅ 有效 */
}
```
</details>

**4. px和rem的区别？**
<details>
<summary>点击查看答案</summary>

- **px**：绝对单位，固定像素，不响应式
- **rem**：相对单位，相对根元素font-size，响应式

**代码：**
```css
html {
  font-size: 62.5%;  /* 16px * 62.5% = 10px */
}

.box {
  width: 20rem;  /* 20 * 10px = 200px */
}
```

**使用场景：** rem适合响应式布局，px适合固定尺寸
</details>

---

### Vue（5题）

**5. Vue2和Vue3响应式原理的区别？**
<details>
<summary>点击查看答案</summary>

| 特性 | Vue2 | Vue3 |
|------|------|------|
| 实现方式 | Object.defineProperty | Proxy |
| 性能 | 需递归遍历 | 性能更好 |
| 新增属性 | ❌ 无法监听 | ✅ 可以监听 |
| 数组 | ❌ 需特殊处理 | ✅ 直接监听 |

**Vue2缺陷：**
- 无法监听新增/删除属性
- 无法监听数组变化

**Vue3优势：**
- Proxy直接代理整个对象
- 可监听动态属性和数组
- 性能更好
</details>

**6. ref和reactive的区别？**
<details>
<summary>点击查看答案</summary>

| 特性 | ref | reactive |
|------|-----|----------|
| 数据类型 | 基本类型+对象 | 仅对象 |
| 访问方式 | 需.value | 直接访问 |
| 重新赋值 | 可以 | 不可以 |

**代码：**
```javascript
// ref - 需要.value
const count = ref(0)
count.value++

// reactive - 不需要.value
const state = reactive({ count: 0 })
state.count++
```
</details>

**7. computed和watch的区别？**
<details>
<summary>点击查看答案</summary>

| 特性 | computed | watch |
|------|----------|-------|
| 缓存 | 有缓存 | 无缓存 |
| 返回值 | 必须有 | 无 |
| 异步 | 不支持 | 支持 |
| 使用场景 | 派生数据 | 副作用操作 |

**代码：**
```javascript
// computed - 有缓存
const doubled = computed(() => count.value * 2)

// watch - 支持异步
watch(count, async (newVal) => {
  const data = await fetchData(newVal)
})
```
</details>

**8. Vue组件通信有哪些方式？**
<details>
<summary>点击查看答案</summary>

**三种主要方式：**
1. **props + emit**：父子通信
2. **provide + inject**：跨级通信
3. **v-model**：双向绑定

**代码：**
```javascript
// 1. props/emit
// 父组件
<Child :msg="message" @update="handleUpdate" />

// 子组件
const props = defineProps(['msg'])
const emit = defineEmits(['update'])
emit('update', newValue)

// 2. provide/inject
// 祖先
provide('theme', 'dark')
// 后代
const theme = inject('theme')

// 3. v-model
<Child v-model="value" />
```
</details>

**9. v-if和v-show的区别？**
<details>
<summary>点击查看答案</summary>

| 特性 | v-if | v-show |
|------|------|--------|
| DOM操作 | 销毁/重建 | 切换display |
| 初始成本 | 低 | 高 |
| 切换成本 | 高 | 低 |
| 使用场景 | 条件很少改变 | 频繁切换 |

**原理：**
- v-if：条件不满足时不渲染DOM
- v-show：始终渲染，只是切换display:none
</details>

---

### JavaScript（6题）

**10. JavaScript有哪些数据类型？**
<details>
<summary>点击查看答案</summary>

**8种数据类型：**
- **基本类型（7种）**：Number、String、Boolean、Undefined、Null、Symbol、BigInt
- **引用类型（1种）**：Object（包括Array、Function、Date等）

**检测方法：**
```javascript
typeof 123           // 'number'
typeof 'str'         // 'string'
typeof null          // 'object' ⚠️ 历史遗留
typeof []            // 'object'
Array.isArray([])    // true
Object.prototype.toString.call([])  // '[object Array]'
```
</details>

**11. var、let、const的区别？**
<details>
<summary>点击查看答案</summary>

| 特性 | var | let | const |
|------|-----|-----|-------|
| 作用域 | 函数作用域 | 块级作用域 | 块级作用域 |
| 变量提升 | 有 | 有暂时性死区 | 有暂时性死区 |
| 重复声明 | 允许 | 不允许 | 不允许 |
| 重新赋值 | 允许 | 允许 | 不允许 |

**代码：**
```javascript
// var - 函数作用域
if (true) {
  var a = 1;
}
console.log(a);  // 1

// let - 块级作用域
if (true) {
  let b = 2;
}
console.log(b);  // ❌ 报错

// const - 不可重新赋值
const c = 3;
c = 4;  // ❌ 报错
```
</details>

**12. this的指向规则是什么？**
<details>
<summary>点击查看答案</summary>

**五种规则（优先级从高到低）：**
1. **new绑定**：指向新创建的实例
2. **显式绑定**：call/apply/bind改变指向
3. **隐式绑定**：作为对象方法，指向调用对象
4. **默认绑定**：指向window或undefined
5. **箭头函数**：继承外层作用域的this

**代码：**
```javascript
// 1. new绑定
function Person(name) {
  this.name = name;
}
const p = new Person('张三');  // this指向p

// 2. 显式绑定
const obj = { name: 'obj' };
fn.call(obj);  // this指向obj

// 3. 隐式绑定
obj.fn();  // this指向obj

// 4. 箭头函数
const obj = {
  fn: () => {
    console.log(this);  // 继承外层
  }
};
```
</details>

**13. 什么是闭包？有什么作用？**
<details>
<summary>点击查看答案</summary>

**定义：** 函数能够访问其外部函数作用域中的变量，即使外部函数已执行完毕

**作用：**
1. 创建私有变量
2. 延长变量生命周期

**代码：**
```javascript
function createCounter() {
  let count = 0;  // 私有变量

  return {
    increment() {
      count++;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment();  // 1
counter.increment();  // 2
console.log(counter.count);  // undefined（无法直接访问）
```
</details>

**14. Promise是什么？如何使用？**
<details>
<summary>点击查看答案</summary>

**定义：** Promise是异步编程的解决方案

**三种状态：**
- pending（进行中）
- fulfilled（已成功）
- rejected（已失败）

**代码：**
```javascript
// 创建
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('成功数据');
  }, 1000);
});

// 使用
promise
  .then(data => console.log('成功:', data))
  .catch(error => console.error('失败:', error))
  .finally(() => console.log('无论成败'));

// async/await
async function getData() {
  try {
    const data = await promise;
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}
```
</details>

**15. 数组常用方法有哪些？**
<details>
<summary>点击查看答案</summary>

**改变原数组：**
- push、pop（末尾）
- unshift、shift（开头）
- splice（删除/插入/替换）
- sort、reverse

**不改变原数组：**
- map（映射）
- filter（过滤）
- reduce（累加）
- find、some、every
- slice、concat、join

**代码：**
```javascript
const arr = [1, 2, 3, 4, 5];

arr.map(x => x * 2);  // [2, 4, 6, 8, 10]
arr.filter(x => x > 3);  // [4, 5]
arr.reduce((acc, cur) => acc + cur, 0);  // 15
arr.find(x => x > 3);  // 4
```
</details>

---

### 事件机制（2题）

**16. 什么是事件冒泡和捕获？**
<details>
<summary>点击查看答案</summary>

**事件流三阶段：** 捕获（外→内）→ 目标 → 冒泡（内→外）

**代码：**
```javascript
// 捕获阶段（true）
parent.addEventListener('click', () => {
  console.log('父捕获');
}, true);

// 冒泡阶段（false，默认）
child.addEventListener('click', () => {
  console.log('子冒泡');
}, false);

// 点击子元素：父捕获 → 子冒泡
```

**阻止传播：**
```javascript
e.stopPropagation();  // 阻止冒泡
e.preventDefault();   // 阻止默认行为
```
</details>

**17. 防抖和节流的区别？**
<details>
<summary>点击查看答案</summary>

| 特性 | 防抖 | 节流 |
|------|------|------|
| 执行时机 | 停止触发后 | 固定间隔 |
| 应用场景 | 搜索框、resize | 滚动、移动 |

**防抖：**
```javascript
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

**节流：**
```javascript
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}
```
</details>

---

### HTTP（3题）

**18. HTTP和HTTPS的区别？**
<details>
<summary>点击查看答案</summary>

| 对比项 | HTTP | HTTPS |
|--------|------|-------|
| 端口 | 80 | 443 |
| 安全性 | 明文传输 | SSL/TLS加密 |
| 证书 | 不需要 | 需要CA证书 |
| 速度 | 较快 | 较慢（加密） |

**核心：** HTTPS = HTTP + SSL/TLS
</details>

**19. GET和POST的区别？**
<details>
<summary>点击查看答案</summary>

| 区别 | GET | POST |
|------|-----|------|
| 参数位置 | URL中 | 请求体中 |
| 数据大小 | 有限制（2KB） | 理论无限制 |
| 缓存 | 可缓存 | 不可缓存 |
| 幂等性 | 幂等 | 非幂等 |
| 使用场景 | 查询数据 | 提交数据 |

**代码：**
```javascript
// GET
fetch('/api/users?id=1')

// POST
fetch('/api/users', {
  method: 'POST',
  body: JSON.stringify({ name: '张三' })
})
```
</details>

**20. 如何解决跨域问题？**
<details>
<summary>点击查看答案</summary>

**三种主要方案：**

1. **CORS（推荐）**
```javascript
// 服务器设置
res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader('Access-Control-Allow-Methods', 'GET,POST');
```

2. **JSONP（兼容老浏览器）**
```javascript
// 利用script标签不跨域
function jsonp(url, callback) {
  const script = document.createElement('script');
  script.src = `${url}?callback=${callback}`;
  document.body.appendChild(script);
}
```

3. **代理服务器**
```javascript
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true
      }
    }
  }
}
```
</details>

---

# 三天学习总结

## 📊 知识点分布

| 技术栈 | 核心知识点 | 掌握程度要求 |
|--------|-----------|-------------|
| **CSS** | 盒模型、选择器、display、单位、继承 | ⭐⭐⭐⭐⭐ |
| **Vue** | 响应式、ref/reactive、computed/watch、通信、生命周期、指令、路由 | ⭐⭐⭐⭐⭐ |
| **JavaScript** | 数据类型、var/let/const、this、闭包、数组、Promise | ⭐⭐⭐⭐⭐ |
| **事件机制** | 事件流、事件委托、addEventListener、防抖节流 | ⭐⭐⭐⭐⭐ |
| **HTTP** | HTTP/HTTPS、GET/POST、状态码、缓存、跨域 | ⭐⭐⭐⭐⭐ |
| **AJAX** | XMLHttpRequest、Fetch、跨域解决 | ⭐⭐⭐⭐ |

---

## 🎯 学习成果检验

完成三天学习后，你应该能够：

### ✅ 基础概念
- 流畅解释盒模型、选择器优先级、display属性
- 说清楚Vue响应式原理和核心API
- 理解JavaScript数据类型和作用域
- 掌握事件流和事件委托

### ✅ 实际应用
- 使用border-box设置盒模型
- 正确使用ref/reactive/computed/watch
- 处理this指向和闭包问题
- 实现防抖节流优化性能

### ✅ 网络通信
- 区分HTTP和HTTPS、GET和POST
- 理解强缓存和协商缓存
- 使用CORS解决跨域问题
- 使用Fetch发送AJAX请求

### ✅ 手写代码
- 手写防抖和节流函数
- 手写闭包实现私有变量
- 使用Promise和async/await处理异步
- 实现简单的AJAX请求

---

## 💡 后续学习建议

### 继续深入的方向
1. **CSS进阶**：Flex布局、Grid布局、CSS动画
2. **Vue进阶**：Pinia状态管理、组件设计、性能优化
3. **JavaScript进阶**：原型链、继承、设计模式
4. **工程化**：Webpack、Vite、TypeScript
5. **框架对比**：React、Angular

### 实战项目建议
- Todo List应用（综合运用Vue+AJAX）
- 博客系统（路由+状态管理）
- 响应式网站（CSS布局+移动端适配）

---

**🎉 三天学习完成！你已经掌握了初级前端工程师的核心知识！继续加油！💪**
