# 初级前端三天复习计划 - 第一天（完整版）

> 📅 **学习时间**：第一天 | **目标**：掌握CSS、Vue、JavaScript、事件机制基础 | **建议时长**：6-8小时

## 📚 今日学习内容

| 模块 | 核心知识点 | 重要程度 | 预计时长 |
|------|-----------|---------|----------|
| **CSS核心** | 盒模型、选择器优先级 | ⭐⭐⭐⭐⭐ | 1.5小时 |
| **Vue基础** | 响应式原理、ref vs reactive、computed vs watch | ⭐⭐⭐⭐⭐ | 2小时 |
| **JavaScript基础** | 数据类型、类型检测、var/let/const | ⭐⭐⭐⭐⭐ | 2小时 |
| **事件机制** | 事件流、事件委托、事件对象 | ⭐⭐⭐⭐⭐ | 1.5小时 |
| **练习题** | 综合练习与巩固 | ⭐⭐⭐⭐⭐ | 1小时 |

---

# 第一部分：CSS核心知识（详细完整）

## 一、CSS盒模型

### 1. 什么是CSS盒模型？⭐⭐⭐⭐⭐ 🔥 ⚠️

**定义：**
- 在HTML页面中，所有元素都可以看成是一个**矩形盒子**
- 盒子由**内容(content)、内边距(padding)、边框(border)、外边距(margin)**四部分组成

**盒子组成部分：**
| 部分 | 说明 | CSS属性 |
|------|------|---------|
| **content** | 内容区域 | width、height |
| **padding** | 内边距，内容与边框之间的距离 | padding |
| **border** | 边框 | border |
| **margin** | 外边距，盒子与其他盒子之间的距离 | margin |

**视觉示意：**
```
┌─────────────── margin ───────────────┐
│  ┌─────────── border ───────────┐   │
│  │  ┌─────── padding ────────┐  │   │
│  │  │                         │  │   │
│  │  │       content           │  │   │
│  │  │                         │  │   │
│  │  └─────────────────────────┘  │   │
│  └───────────────────────────────┘   │
└──────────────────────────────────────┘
```

**记忆口诀：**
```
内容content为核心、padding内边距、border边框、margin外边距
从里到外：content → padding → border → margin
```

---

### 2. 标准盒模型和IE盒模型的区别？⭐⭐⭐⭐⭐ 🔥 ⚠️

**核心区别：**
width/height的计算方式不同

#### 标准盒模型（W3C盒模型）
- **width/height** 只包含 **content**
- 元素实际占用宽度 = `margin + border + padding + content`
- CSS设置：`box-sizing: content-box`（默认值）

```css
.box {
  width: 200px;
  padding: 20px;
  border: 10px solid;
  margin: 10px;
  box-sizing: content-box;  /* 标准盒模型 */
}
/* 实际占用宽度 = 10 + 10 + 20 + 200 + 20 + 10 + 10 = 280px */
/* content宽度 = 200px */
```

#### IE盒模型（怪异盒模型）
- **width/height** 包含 **content + padding + border**
- 元素实际占用宽度 = `margin + width`
- CSS设置：`box-sizing: border-box`

```css
.box {
  width: 200px;
  padding: 20px;
  border: 10px solid;
  margin: 10px;
  box-sizing: border-box;  /* IE盒模型 */
}
/* 实际占用宽度 = 10 + 200 + 10 = 220px */
/* content宽度 = 200 - 20*2 - 10*2 = 140px */
```

**对比表格：**
| 特性 | 标准盒模型 | IE盒模型 |
|------|-----------|----------|
| **width包含** | 只有content | content + padding + border |
| **box-sizing** | content-box | border-box |
| **内容宽度计算** | width = content | width - padding - border = content |
| **实际占用宽度** | margin + border + padding + width | margin + width |
| **推荐使用** | 默认行为 | ✅ 更直观，推荐使用 |

**记忆口诀：**
```
标准盒模型：width只是content
IE盒模型：width包含padding和border（更直观）
box-sizing控制：content-box(标准) 或 border-box(IE)
```

**最佳实践：**
```css
/* 推荐全局设置为IE盒模型，更符合直觉 */
* {
  box-sizing: border-box;
}
```

---

## 二、CSS选择器优先级

### 3. CSS选择器的优先级规则是什么？⭐⭐⭐⭐⭐ 🔥 ⚠️

**CSS的三大特性：**
1. **继承性**：子元素可以继承父元素的某些样式
2. **层叠性**：多个样式可以作用于同一个元素
3. **优先级**：当多个样式冲突时，根据权重决定显示哪个

**优先级从高到低：**
```
!important > 行内样式 > ID选择器 > 类/伪类/属性选择器 > 标签选择器 > 通配符
```

**权重计算表格：**
| 选择器类型 | 权重 | 示例 |
|-----------|------|------|
| **!important** | ∞（最高） | `color: red !important;` |
| **行内样式** | 1000 | `<div style="color: red">` |
| **ID选择器** | 100 | `#header` |
| **类选择器** | 10 | `.title` |
| **伪类选择器** | 10 | `:hover` |
| **属性选择器** | 10 | `[type="text"]` |
| **标签选择器** | 1 | `div` |
| **伪元素** | 1 | `::before` |
| **通配符** | 0 | `*` |

**权重计算示例：**
```css
/* 权重 = 100 + 10 + 1 = 111 */
#header .nav li { color: red; }

/* 权重 = 10 + 10 + 1 = 21 */
.container .nav li { color: blue; }

/* 权重 = 1 + 1 + 1 = 3 */
div ul li { color: green; }

/* 最终显示红色，因为第一个选择器权重最高 */
```

**更多权重计算示例：**
```css
/* 示例1：权重 = 100 + 10 = 110 */
#app .container { color: red; }

/* 示例2：权重 = 100 + 100 + 10 = 210 */
#header #nav .item { color: blue; }

/* 示例3：权重 = 10 + 10 + 10 + 1 = 31 */
.nav .menu .item a { color: green; }

/* 示例4：权重 = 1 + 1 + 1 + 1 = 4 */
div ul li a { color: yellow; }

/* 示例5：行内样式权重 = 1000 */
<div style="color: purple">最高优先级（除了!important）</div>

/* 示例6：!important最高 */
p { color: orange !important; }  /* 无论其他选择器权重多高，这个都会生效 */
```

**特殊规则：**
1. **!important** 优先级最高，但尽量避免使用
2. 权重相同时，后定义的覆盖先定义的
3. 继承的样式权重为0
4. 直接作用于元素的样式优先于继承的样式

**记忆口诀：**
```
!important最霸道
行内样式权重千
ID一百类十个
标签一分通配零
```

---

# 第二部分：Vue基础（详细完整）

## 一、Vue响应式原理

### Vue2 vs Vue3 响应式原理对比 ⭐⭐⭐⭐⭐ 🔥

**口诀：依赖收集触发更新、Proxy替Object**

#### Vue2：Object.defineProperty

**工作原理：**
- 遍历data的所有属性，使用`Object.defineProperty`转为getter/setter
- getter负责依赖收集（记录哪些地方用到了这个数据）
- setter负责触发更新（数据变化时通知所有使用者）

**实现示例：**
```javascript
// Vue2 响应式原理简化版
function defineReactive(obj, key, val) {
  // 依赖收集器
  const dep = [];

  Object.defineProperty(obj, key, {
    get() {
      console.log(`读取 ${key}: ${val}`);
      // 收集依赖
      if (currentWatcher) {
        dep.push(currentWatcher);
      }
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      console.log(`设置 ${key}: ${newVal}`);
      val = newVal;
      // 触发更新
      dep.forEach(watcher => watcher.update());
    }
  });
}

// 使用
const data = {};
defineReactive(data, 'count', 0);
data.count; // 读取 count: 0
data.count = 1; // 设置 count: 1
```

**Vue2 优点：**
- 兼容性好，支持IE9+
- 实现相对简单

**Vue2 缺点：**
- ❌ 无法监听对象属性的新增和删除
- ❌ 无法监听数组索引和length的变化
- ❌ 需要递归遍历所有属性，初始化性能开销大
- ❌ 需要使用`Vue.set`、`Vue.delete`等特殊API

```javascript
// Vue2 的限制示例
const vm = new Vue({
  data: {
    obj: { name: '张三' },
    arr: [1, 2, 3]
  }
});

// ❌ 无法监听新增属性
vm.obj.age = 20; // 不会触发更新

// ✅ 需要使用 Vue.set
Vue.set(vm.obj, 'age', 20); // 可以触发更新

// ❌ 无法监听数组索引变化
vm.arr[0] = 100; // 不会触发更新

// ✅ 需要使用数组变异方法
vm.arr.splice(0, 1, 100); // 可以触发更新
```

---

#### Vue3：Proxy

**工作原理：**
- 使用`Proxy`直接代理整个对象
- 可以拦截对象的所有操作（读取、设置、删除等）
- 懒代理：只有访问到的属性才会被代理

**实现示例：**
```javascript
// Vue3 响应式原理简化版
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      console.log(`读取 ${key}`);
      const result = Reflect.get(target, key, receiver);
      // 收集依赖
      track(target, key);
      // 如果是对象，递归代理（懒代理）
      if (typeof result === 'object' && result !== null) {
        return reactive(result);
      }
      return result;
    },
    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);
      if (oldValue !== value) {
        console.log(`设置 ${key}: ${value}`);
        // 触发更新
        trigger(target, key);
      }
      return result;
    },
    deleteProperty(target, key) {
      console.log(`删除 ${key}`);
      const result = Reflect.deleteProperty(target, key);
      // 触发更新
      trigger(target, key);
      return result;
    }
  });
}

// 使用
const state = reactive({ count: 0 });
state.count; // 读取 count
state.count = 1; // 设置 count: 1
```

**Vue3 优点：**
- ✅ 可以监听动态属性的新增和删除
- ✅ 可以监听数组索引和length的变化
- ✅ 性能更好，不需要初始递归遍历所有属性
- ✅ 支持Map、Set、WeakMap、WeakSet等数据结构

**Vue3 缺点：**
- ❌ 不支持IE11（但Vue3不再支持IE）

```javascript
// Vue3 的优势示例
import { reactive } from 'vue';

const state = reactive({
  obj: { name: '张三' },
  arr: [1, 2, 3]
});

// ✅ 可以直接新增属性
state.obj.age = 20; // 自动触发更新

// ✅ 可以直接修改数组索引
state.arr[0] = 100; // 自动触发更新

// ✅ 可以直接修改length
state.arr.length = 0; // 自动触发更新

// ✅ 可以删除属性
delete state.obj.name; // 自动触发更新
```

---

**完整对比表格：**

| 特性 | Vue2 (Object.defineProperty) | Vue3 (Proxy) |
|------|------------------------------|--------------|
| **监听新增属性** | ❌ 无法监听，需要`Vue.set` | ✅ 可以监听 |
| **监听删除属性** | ❌ 无法监听，需要`Vue.delete` | ✅ 可以监听 |
| **监听数组索引** | ❌ 无法监听 | ✅ 可以监听 |
| **监听数组length** | ❌ 无法监听 | ✅ 可以监听 |
| **初始化性能** | ❌ 需递归遍历所有属性 | ✅ 懒代理，按需代理 |
| **浏览器兼容性** | ✅ 支持IE9+ | ❌ 不支持IE11 |
| **支持数据结构** | 对象和数组 | 对象、数组、Map、Set等 |
| **API复杂度** | 需要特殊API | 统一API |

**记忆口诀：**
```
Vue2用defineProperty，遍历属性建getter/setter
无法监听新增删除，数组索引也不行
Vue3用Proxy代理，拦截所有操作
动态属性全监听，性能更好更灵活
```

---

## 二、ref vs reactive

### ref vs reactive 详细对比 ⭐⭐⭐⭐

**口诀：ref需value，reactive不需**

**完整对比表格：**

| 特性 | ref | reactive |
|------|-----|----------|
| **支持数据类型** | 基本类型 + 对象类型 | 仅对象类型（对象、数组） |
| **访问方式** | 需要`.value`（模板中自动解包） | 直接访问属性 |
| **重新赋值** | ✅ 可以整体替换 | ❌ 不可整体替换，会失去响应式 |
| **解构** | ❌ 解构会失去响应式，需`toRefs` | ❌ 解构会失去响应式，需`toRefs` |
| **模板中使用** | 自动解包，不需要`.value` | 直接使用 |
| **响应式原理** | 内部使用`reactive`包装 | 直接使用`Proxy` |
| **使用场景** | 单个值、基本类型、需要替换整个对象 | 复杂对象、不需要整体替换 |

---

### ref 详细说明

**基本用法：**
```javascript
import { ref } from 'vue';

// 1. 基本类型
const count = ref(0);
console.log(count.value); // 0，需要.value访问
count.value++; // 修改需要.value

// 2. 对象类型
const user = ref({ name: '张三', age: 20 });
console.log(user.value.name); // '张三'，需要.value
user.value.age++; // 修改属性

// 3. 数组
const list = ref([1, 2, 3]);
list.value.push(4); // 需要.value
console.log(list.value[0]); // 1

// 4. 整体替换（ref的优势）
const data = ref({ name: '张三' });
data.value = { name: '李四' }; // ✅ 可以整体替换
```

**模板中使用（自动解包）：**
```vue
<template>
  <!-- ref在模板中自动解包，不需要.value -->
  <div>{{ count }}</div>
  <button @click="count++">增加</button>

  <div>{{ user.name }}</div>
  <button @click="user.age++">年龄+1</button>
</template>

<script setup>
import { ref } from 'vue';

const count = ref(0);
const user = ref({ name: '张三', age: 20 });
</script>
```

**ref 使用场景：**
1. 单个基本类型值
2. 需要整体替换对象的场景
3. 表单输入绑定
4. 需要传递给子组件的单个值

---

### reactive 详细说明

**基本用法：**
```javascript
import { reactive } from 'vue';

// 1. 对象
const state = reactive({
  count: 0,
  user: {
    name: '张三',
    age: 20
  }
});

// 直接访问，不需要.value
console.log(state.count); // 0
state.count++; // 直接修改
console.log(state.user.name); // '张三'

// 2. 数组
const list = reactive([1, 2, 3]);
list.push(4); // 直接操作
console.log(list[0]); // 1

// ❌ 不能整体替换（会失去响应式）
let state2 = reactive({ count: 0 });
state2 = { count: 1 }; // ❌ 错误！失去响应式

// ✅ 正确做法：修改属性
state2.count = 1; // ✅ 正确
```

**模板中使用：**
```vue
<template>
  <!-- reactive 直接使用属性 -->
  <div>{{ state.count }}</div>
  <button @click="state.count++">增加</button>

  <div>{{ state.user.name }}</div>
  <button @click="state.user.age++">年龄+1</button>
</template>

<script setup>
import { reactive } from 'vue';

const state = reactive({
  count: 0,
  user: { name: '张三', age: 20 }
});
</script>
```

**reactive 使用场景：**
1. 复杂对象状态
2. 多个相关状态的组合
3. 不需要整体替换的场景

---

### 解构问题与 toRefs

**问题：解构会失去响应式**
```javascript
import { reactive, ref } from 'vue';

// ❌ 错误：解构reactive会失去响应式
const state = reactive({ count: 0, name: '张三' });
let { count, name } = state; // 失去响应式
count++; // 不会触发更新

// ❌ 错误：解构ref会失去响应式
const count2 = ref(0);
let { value } = count2; // 失去响应式
value++; // 不会触发更新
```

**解决方案：使用 toRefs**
```javascript
import { reactive, toRefs } from 'vue';

const state = reactive({
  count: 0,
  name: '张三'
});

// ✅ 正确：使用toRefs转换
const { count, name } = toRefs(state);

// 现在count和name都是ref，需要.value
console.log(count.value); // 0
count.value++; // 可以触发更新

// 在模板中自动解包
```

**toRefs 完整示例：**
```vue
<template>
  <!-- 解构后的变量可以直接使用 -->
  <div>{{ count }}</div>
  <div>{{ name }}</div>
  <button @click="count++">增加</button>
  <button @click="name = '李四'">改名</button>
</template>

<script setup>
import { reactive, toRefs } from 'vue';

const state = reactive({
  count: 0,
  name: '张三',
  age: 20
});

// 使用toRefs解构，保持响应式
const { count, name } = toRefs(state);

// 或者导出整个state
// defineExpose({ state });
</script>
```

**记忆口诀：**
```
ref基本加对象，访问都要.value
reactive仅对象，直接访问属性
ref可以整体换，reactive只改属性
解构失去响应性，toRefs来帮忙
```

---

## 三、computed vs watch

### computed vs watch 详细对比 ⭐⭐⭐⭐

**口诀：计算缓存侦听副作用**

**完整对比表格：**

| 特性 | computed | watch |
|------|----------|-------|
| **是否有缓存** | ✅ 有缓存，依赖不变不重新计算 | ❌ 无缓存，每次都执行 |
| **返回值** | ✅ 必须有返回值 | ❌ 无返回值 |
| **异步操作** | ❌ 不支持异步 | ✅ 支持异步 |
| **使用场景** | 计算派生数据、模板中使用 | 监听数据变化、执行副作用操作 |
| **多个数据依赖** | ✅ 自动追踪所有依赖 | 需要明确指定监听源 |
| **立即执行** | ✅ 创建时立即计算 | ❌ 默认不立即执行（可配置） |
| **性能** | 更好（有缓存） | 相对较差（无缓存） |

---

### computed 详细说明

**基本用法：**
```javascript
import { ref, computed } from 'vue';

const count = ref(0);

// 只读计算属性
const doubled = computed(() => {
  console.log('computed执行');
  return count.value * 2;
});

console.log(doubled.value); // 0，输出'computed执行'
console.log(doubled.value); // 0，不输出（使用缓存）

count.value = 1;
console.log(doubled.value); // 2，输出'computed执行'（依赖变化，重新计算）
console.log(doubled.value); // 2，不输出（使用缓存）
```

**可写计算属性：**
```javascript
import { ref, computed } from 'vue';

const firstName = ref('张');
const lastName = ref('三');

// 可写计算属性
const fullName = computed({
  get() {
    return firstName.value + lastName.value;
  },
  set(newValue) {
    // 假设输入格式：'李四'
    firstName.value = newValue[0];
    lastName.value = newValue.slice(1);
  }
});

console.log(fullName.value); // '张三'
fullName.value = '李四';
console.log(firstName.value); // '李'
console.log(lastName.value); // '四'
```

**多依赖计算：**
```javascript
import { ref, computed } from 'vue';

const price = ref(100);
const quantity = ref(2);
const taxRate = ref(0.1);

// 自动追踪所有依赖
const total = computed(() => {
  return price.value * quantity.value * (1 + taxRate.value);
});

console.log(total.value); // 220
price.value = 200;
console.log(total.value); // 440（自动重新计算）
```

**computed 使用场景：**
1. 数据格式化（日期、金额等）
2. 数据过滤和排序
3. 多个数据的计算结果
4. 需要在模板中多次使用的计算结果

**完整示例：**
```vue
<template>
  <div>
    <p>原价：{{ price }}</p>
    <p>数量：{{ quantity }}</p>
    <p>折扣后价格：{{ discountedPrice }}</p>
    <p>总价：{{ totalPrice }}</p>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';

const price = ref(100);
const quantity = ref(2);
const discount = ref(0.8);

// 计算折扣价格
const discountedPrice = computed(() => {
  return price.value * discount.value;
});

// 计算总价
const totalPrice = computed(() => {
  return discountedPrice.value * quantity.value;
});
</script>
```

---

### watch 详细说明

**基本用法：**
```javascript
import { ref, watch } from 'vue';

const count = ref(0);

// 监听单个ref
watch(count, (newValue, oldValue) => {
  console.log(`count changed from ${oldValue} to ${newValue}`);
});

count.value = 1; // 输出：count changed from 0 to 1
```

**监听多个数据源：**
```javascript
import { ref, watch } from 'vue';

const firstName = ref('张');
const lastName = ref('三');

// 监听多个ref
watch([firstName, lastName], ([newFirst, newLast], [oldFirst, oldLast]) => {
  console.log(`姓名从 ${oldFirst}${oldLast} 变为 ${newFirst}${newLast}`);
});

firstName.value = '李'; // 输出：姓名从 张三 变为 李三
```

**监听reactive对象：**
```javascript
import { reactive, watch } from 'vue';

const state = reactive({
  count: 0,
  user: {
    name: '张三'
  }
});

// 监听整个reactive对象（自动深度监听）
watch(state, (newValue, oldValue) => {
  console.log('state changed', newValue);
});

// 监听对象的某个属性（使用getter函数）
watch(
  () => state.count,
  (newValue, oldValue) => {
    console.log(`count changed from ${oldValue} to ${newValue}`);
  }
);

// 监听嵌套属性
watch(
  () => state.user.name,
  (newValue, oldValue) => {
    console.log(`name changed from ${oldValue} to ${newValue}`);
  }
);
```

**watch 选项参数详解：**

#### 1. immediate - 立即执行
```javascript
import { ref, watch } from 'vue';

const count = ref(0);

watch(
  count,
  (newValue, oldValue) => {
    console.log(`count: ${newValue}`);
  },
  { immediate: true } // 立即执行一次
);
// 立即输出：count: 0

count.value = 1;
// 输出：count: 1
```

#### 2. deep - 深度监听
```javascript
import { ref, watch } from 'vue';

const user = ref({
  name: '张三',
  info: {
    age: 20
  }
});

// 不使用deep，监听不到嵌套属性变化
watch(user, (newValue) => {
  console.log('user changed', newValue);
});

user.value.info.age = 21; // 不会触发

// 使用deep，可以监听到嵌套属性变化
watch(
  user,
  (newValue) => {
    console.log('user changed (deep)', newValue);
  },
  { deep: true }
);

user.value.info.age = 22; // 会触发
```

#### 3. flush - 控制回调执行时机
```javascript
import { ref, watch } from 'vue';

const count = ref(0);

// flush: 'pre' - 组件更新前执行（默认）
watch(
  count,
  () => {
    console.log('pre: DOM可能还未更新');
  },
  { flush: 'pre' }
);

// flush: 'post' - 组件更新后执行
watch(
  count,
  () => {
    console.log('post: DOM已经更新');
  },
  { flush: 'post' }
);

// flush: 'sync' - 同步执行（不推荐，性能问题）
watch(
  count,
  () => {
    console.log('sync: 立即同步执行');
  },
  { flush: 'sync' }
);
```

#### 4. once - 只触发一次（Vue 3.4+）
```javascript
import { ref, watch } from 'vue';

const count = ref(0);

watch(
  count,
  () => {
    console.log('只执行一次');
  },
  { once: true }
);

count.value = 1; // 输出：只执行一次
count.value = 2; // 不输出
```

**watch 完整配置示例：**
```javascript
import { ref, watch } from 'vue';

const user = ref({
  name: '张三',
  age: 20
});

watch(
  user,
  (newValue, oldValue) => {
    console.log('user changed', newValue);
  },
  {
    immediate: true,  // 立即执行一次
    deep: true,       // 深度监听
    flush: 'post',    // DOM更新后执行
    // once: true     // 只触发一次（Vue 3.4+）
  }
);
```

---

### watchEffect 详细说明

**基本用法：**
```javascript
import { ref, watchEffect } from 'vue';

const count = ref(0);
const doubled = ref(0);

// 自动追踪依赖，立即执行
watchEffect(() => {
  console.log(`count: ${count.value}`);
  doubled.value = count.value * 2;
});
// 立即输出：count: 0

count.value = 1;
// 输出：count: 1
```

**watchEffect vs watch：**

| 特性 | watchEffect | watch |
|------|-------------|-------|
| **依赖追踪** | 自动追踪（类似computed） | 需要明确指定 |
| **立即执行** | ✅ 立即执行 | ❌ 默认不立即（可配置） |
| **访问旧值** | ❌ 无法访问旧值 | ✅ 可以访问新旧值 |
| **使用场景** | 简单副作用、自动依赖追踪 | 需要旧值、明确监听源 |

**完整对比示例：**
```javascript
import { ref, watch, watchEffect } from 'vue';

const count = ref(0);
const doubled = ref(0);

// 方式1：使用watch
watch(count, (newValue, oldValue) => {
  console.log(`从 ${oldValue} 变为 ${newValue}`);
  doubled.value = newValue * 2;
});

// 方式2：使用watchEffect
watchEffect(() => {
  // 自动追踪count
  console.log(`当前值: ${count.value}`);
  doubled.value = count.value * 2;
});
```

**停止监听：**
```javascript
import { ref, watch, watchEffect } from 'vue';

const count = ref(0);

// watch和watchEffect都返回停止函数
const stopWatch = watch(count, () => {
  console.log('watching');
});

const stopWatchEffect = watchEffect(() => {
  console.log('effect');
});

// 停止监听
stopWatch();
stopWatchEffect();

count.value = 1; // 不会触发任何输出
```

---

### 使用场景总结

**使用 computed：**
- ✅ 需要根据其他数据计算得到新数据
- ✅ 需要在模板中多次使用计算结果
- ✅ 需要缓存计算结果（性能优化）
- ✅ 计算逻辑是同步的

**使用 watch：**
- ✅ 需要在数据变化时执行异步操作
- ✅ 需要在数据变化时执行开销较大的操作
- ✅ 需要访问变化前后的值
- ✅ 需要明确指定监听哪些数据

**使用 watchEffect：**
- ✅ 简单的副作用操作
- ✅ 不需要访问旧值
- ✅ 需要立即执行
- ✅ 希望自动追踪依赖（不想手动指定）

**完整实战示例：**
```vue
<template>
  <div>
    <!-- computed：数据展示 -->
    <p>总价：{{ totalPrice }}</p>

    <!-- watch：表单验证 -->
    <input v-model="email" placeholder="输入邮箱">
    <p v-if="emailError">{{ emailError }}</p>

    <!-- watchEffect：日志记录 -->
    <p>操作次数：{{ operationCount }}</p>
  </div>
</template>

<script setup>
import { ref, computed, watch, watchEffect } from 'vue';

// computed 场景：计算总价
const price = ref(100);
const quantity = ref(2);
const totalPrice = computed(() => price.value * quantity.value);

// watch 场景：异步验证邮箱
const email = ref('');
const emailError = ref('');

watch(email, async (newEmail) => {
  if (!newEmail) {
    emailError.value = '';
    return;
  }

  // 异步验证
  const isValid = await validateEmail(newEmail);
  emailError.value = isValid ? '' : '邮箱格式不正确';
});

// watchEffect 场景：记录操作
const operationCount = ref(0);
watchEffect(() => {
  console.log(`总价: ${totalPrice.value}, 邮箱: ${email.value}`);
  operationCount.value++;
});

// 模拟异步验证
async function validateEmail(email) {
  await new Promise(resolve => setTimeout(resolve, 300));
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}
</script>
```

**记忆口诀：**
```
computed计算派生，有缓存依赖变才算
watch监听变化，异步操作最擅长
watchEffect自动追踪，立即执行不要旧值
```

---

# 第三部分：JavaScript基础（详细完整）

## 一、数据类型

### JavaScript 8种数据类型 ⭐⭐⭐⭐

**完整列表：**

JavaScript有8种数据类型，分为两大类：

**基本数据类型（7种）：**
1. **Number** - 数字
2. **String** - 字符串
3. **Boolean** - 布尔值
4. **Undefined** - 未定义
5. **Null** - 空值
6. **Symbol** - 独一无二的值（ES6）
7. **BigInt** - 大整数（ES2020）

**引用数据类型（1种）：**
8. **Object** - 对象（包括Array、Function、Date、RegExp等）

**详细说明：**

```javascript
// 1. Number - 数字（包括整数和浮点数）
let age = 25;
let price = 99.99;
let negative = -10;
let infinity = Infinity;
let notANumber = NaN;

// 2. String - 字符串
let name = '张三';
let message = "Hello";
let template = `姓名：${name}`; // 模板字符串

// 3. Boolean - 布尔值
let isActive = true;
let isDeleted = false;

// 4. Undefined - 未定义
let value; // 声明但未赋值
console.log(value); // undefined

// 5. Null - 空值
let data = null; // 明确表示"空"

// 6. Symbol - 独一无二的值
let id1 = Symbol('id');
let id2 = Symbol('id');
console.log(id1 === id2); // false

// 7. BigInt - 大整数
let bigNumber = 9007199254740991n;
let bigNumber2 = BigInt(9007199254740991);

// 8. Object - 对象
let obj = { name: '张三' };
let arr = [1, 2, 3];
let fn = function() {};
let date = new Date();
let regex = /abc/;
```

**基本类型 vs 引用类型的区别：**

| 特性 | 基本类型 | 引用类型 |
|------|---------|---------|
| **存储位置** | 栈内存 | 堆内存（栈中存地址） |
| **赋值方式** | 值拷贝 | 地址拷贝 |
| **比较方式** | 值比较 | 地址比较 |
| **是否可变** | 不可变 | 可变 |

```javascript
// 基本类型 - 值拷贝
let a = 10;
let b = a;
b = 20;
console.log(a); // 10（a不受影响）

// 引用类型 - 地址拷贝
let obj1 = { name: '张三' };
let obj2 = obj1;
obj2.name = '李四';
console.log(obj1.name); // '李四'（obj1受影响）
```

**记忆口诀：**
```
数字字符布尔空，未定符号大整型（7个基本）
对象引用是一家（1个引用）
```

或更顺口的：
```
数（Number）串（String）布（Boolean）空（Null）未（Undefined）
符（Symbol）号大（BigInt）整，对（Object）象一家亲
```

---

## 二、类型检测

### 四种类型检测方法 ⭐⭐⭐⭐

**口诀：typeof快速看基本，instanceof查原型链，toString最准确，Array专门判数组**

---

### 1. typeof - 快速检测基本类型

**语法：**
```javascript
typeof operand
```

**完整示例（所有类型）：**
```javascript
// 基本类型
console.log(typeof 123);           // 'number'
console.log(typeof 'str');         // 'string'
console.log(typeof true);          // 'boolean'
console.log(typeof undefined);     // 'undefined'
console.log(typeof Symbol());      // 'symbol'
console.log(typeof 123n);          // 'bigint'

// 引用类型
console.log(typeof {});            // 'object'
console.log(typeof []);            // 'object' ⚠️
console.log(typeof function(){}); // 'function'
console.log(typeof new Date());    // 'object'
console.log(typeof /regex/);       // 'object'

// 特殊情况
console.log(typeof null);          // 'object' ⚠️ 历史遗留问题
console.log(typeof NaN);           // 'number'
```

**typeof 的特点：**
- ✅ 快速、简单
- ✅ 适合检测基本类型
- ❌ 无法区分数组、对象、null
- ❌ `typeof null === 'object'` （历史bug）

---

### 2. instanceof - 检测原型链

**语法：**
```javascript
object instanceof Constructor
```

**完整示例：**
```javascript
// 数组
const arr = [];
console.log(arr instanceof Array);   // true
console.log(arr instanceof Object);  // true（数组也是对象）

// 对象
const obj = {};
console.log(obj instanceof Object);  // true
console.log(obj instanceof Array);   // false

// 函数
const fn = function() {};
console.log(fn instanceof Function); // true
console.log(fn instanceof Object);   // true

// 日期
const date = new Date();
console.log(date instanceof Date);   // true
console.log(date instanceof Object); // true

// 正则
const regex = /abc/;
console.log(regex instanceof RegExp); // true

// 基本类型
console.log(123 instanceof Number);      // false（基本类型不是对象）
console.log('str' instanceof String);    // false
console.log(true instanceof Boolean);    // false

// 包装对象
console.log(new Number(123) instanceof Number); // true
```

**instanceof 的特点：**
- ✅ 可以检测对象类型
- ✅ 可以检测继承关系
- ❌ 无法检测基本类型
- ❌ 跨iframe时可能失效

**手写 instanceof：**
```javascript
function myInstanceof(obj, Constructor) {
  // 基本类型直接返回false
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }

  // 获取对象的原型
  let proto = Object.getPrototypeOf(obj);

  // 获取构造函数的prototype
  const prototype = Constructor.prototype;

  // 循环遍历原型链
  while (proto) {
    if (proto === prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  return false;
}

// 测试
console.log(myInstanceof([], Array));        // true
console.log(myInstanceof([], Object));       // true
console.log(myInstanceof({}, Array));        // false
console.log(myInstanceof(123, Number));      // false
```

---

### 3. Object.prototype.toString.call() - 最准确的方法

**语法：**
```javascript
Object.prototype.toString.call(value)
```

**完整示例（所有类型）：**
```javascript
// 基本类型
console.log(Object.prototype.toString.call(123));       // '[object Number]'
console.log(Object.prototype.toString.call('str'));     // '[object String]'
console.log(Object.prototype.toString.call(true));      // '[object Boolean]'
console.log(Object.prototype.toString.call(undefined)); // '[object Undefined]'
console.log(Object.prototype.toString.call(null));      // '[object Null]'
console.log(Object.prototype.toString.call(Symbol()));  // '[object Symbol]'
console.log(Object.prototype.toString.call(123n));      // '[object BigInt]'

// 引用类型
console.log(Object.prototype.toString.call({}));        // '[object Object]'
console.log(Object.prototype.toString.call([]));        // '[object Array]'
console.log(Object.prototype.toString.call(function(){})); // '[object Function]'
console.log(Object.prototype.toString.call(new Date())); // '[object Date]'
console.log(Object.prototype.toString.call(/regex/));   // '[object RegExp]'
console.log(Object.prototype.toString.call(new Error())); // '[object Error]'
console.log(Object.prototype.toString.call(Math));      // '[object Math]'
console.log(Object.prototype.toString.call(JSON));      // '[object JSON]'

// 特殊对象
console.log(Object.prototype.toString.call(new Map()));    // '[object Map]'
console.log(Object.prototype.toString.call(new Set()));    // '[object Set]'
console.log(Object.prototype.toString.call(new WeakMap())); // '[object WeakMap]'
console.log(Object.prototype.toString.call(new WeakSet())); // '[object WeakSet]'
console.log(Object.prototype.toString.call(Promise.resolve())); // '[object Promise]'
```

**封装类型检测函数：**
```javascript
// 获取类型
function getType(value) {
  const type = Object.prototype.toString.call(value);
  return type.slice(8, -1).toLowerCase(); // 提取类型名
}

// 测试
console.log(getType(123));         // 'number'
console.log(getType('str'));       // 'string'
console.log(getType([]));          // 'array'
console.log(getType({}));          // 'object'
console.log(getType(null));        // 'null'
console.log(getType(undefined));   // 'undefined'
console.log(getType(new Date()));  // 'date'

// 判断具体类型
function isArray(value) {
  return getType(value) === 'array';
}

function isObject(value) {
  return getType(value) === 'object';
}

function isFunction(value) {
  return getType(value) === 'function';
}
```

**toString 的特点：**
- ✅ 最准确、最通用
- ✅ 可以检测所有类型
- ✅ 可以区分null和undefined
- ❌ 写法较长

---

### 4. Array.isArray() - 专门判断数组

**语法：**
```javascript
Array.isArray(value)
```

**完整示例：**
```javascript
// 数组
console.log(Array.isArray([]));              // true
console.log(Array.isArray([1, 2, 3]));       // true
console.log(Array.isArray(new Array()));     // true

// 类数组对象
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
console.log(Array.isArray(arrayLike));       // false

// 其他类型
console.log(Array.isArray({}));              // false
console.log(Array.isArray('array'));         // false
console.log(Array.isArray(123));             // false
console.log(Array.isArray(null));            // false
console.log(Array.isArray(undefined));       // false

// arguments对象
function test() {
  console.log(Array.isArray(arguments));     // false
}
test();
```

**Array.isArray 的特点：**
- ✅ 专门用于判断数组
- ✅ 语义清晰
- ✅ 跨iframe有效（比instanceof可靠）

---

### 四种方法对比表格

| 方法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **typeof** | 快速简单、性能好 | 无法区分对象类型、null返回object | 检测基本类型 |
| **instanceof** | 可以检测对象类型、检测继承 | 无法检测基本类型、跨iframe失效 | 检测对象实例类型 |
| **toString.call()** | 最准确、可检测所有类型 | 写法较长 | 需要准确判断类型时 |
| **Array.isArray()** | 语义清晰、跨iframe有效 | 只能判断数组 | 专门判断数组 |

**实战对比示例：**
```javascript
const arr = [];

// 方法1：typeof
console.log(typeof arr);                      // 'object' ❌ 无法判断是数组

// 方法2：instanceof
console.log(arr instanceof Array);            // true ✅

// 方法3：toString.call()
console.log(Object.prototype.toString.call(arr)); // '[object Array]' ✅

// 方法4：Array.isArray()
console.log(Array.isArray(arr));              // true ✅ 最推荐
```

**记忆口诀：**
```
typeof快速看基本，null和数组要小心
instanceof查原型，基本类型不适用
toString最准确，所有类型都能判
Array.isArray()，专门判断数组最可靠
```

---

## 三、var、let、const

### var、let、const 详细对比 ⭐⭐⭐⭐

**完整对比表格：**

| 特性 | var | let | const |
|------|-----|-----|-------|
| **作用域** | 函数作用域 | 块级作用域 | 块级作用域 |
| **变量提升** | ✅ 提升，初始值undefined | ❌ 不提升（有暂时性死区） | ❌ 不提升（有暂时性死区） |
| **重复声明** | ✅ 允许 | ❌ 不允许 | ❌ 不允许 |
| **重新赋值** | ✅ 允许 | ✅ 允许 | ❌ 不允许 |
| **暂时性死区** | ❌ 无 | ✅ 有 | ✅ 有 |
| **全局对象属性** | ✅ 是（window.xxx） | ❌ 否 | ❌ 否 |
| **循环中使用** | ❌ 共享变量 | ✅ 独立作用域 | ✅ 独立作用域 |

---

### 1. var - 函数作用域

**基本特性：**
```javascript
// 1. 变量提升
console.log(a); // undefined（不报错）
var a = 1;
// 相当于：
// var a;
// console.log(a);
// a = 1;

// 2. 重复声明
var b = 1;
var b = 2; // 不报错
console.log(b); // 2

// 3. 函数作用域
function test() {
  var c = 3;
  console.log(c); // 3
}
test();
console.log(c); // ReferenceError: c is not defined

// 4. 没有块级作用域
if (true) {
  var d = 4;
}
console.log(d); // 4（可以访问）

for (var i = 0; i < 3; i++) {
  // ...
}
console.log(i); // 3（可以访问）

// 5. 全局作用域下，var声明的变量会成为window属性
var e = 5;
console.log(window.e); // 5
```

**var 的问题示例：**
```javascript
// 问题1：循环中的var
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 3, 3, 3（都是3）
  }, 1000);
}

// 问题2：污染全局作用域
var name = '张三';
console.log(window.name); // '张三'（污染了window对象）

// 问题3：没有块级作用域导致的问题
if (false) {
  var temp = 'test';
}
console.log(temp); // undefined（变量提升，但没有执行赋值）
```

---

### 2. let - 块级作用域

**基本特性：**
```javascript
// 1. 块级作用域
{
  let a = 1;
  console.log(a); // 1
}
console.log(a); // ReferenceError: a is not defined

// 2. 不允许重复声明
let b = 1;
let b = 2; // SyntaxError: Identifier 'b' has already been declared

// 3. 不存在变量提升（暂时性死区）
console.log(c); // ReferenceError: Cannot access 'c' before initialization
let c = 3;

// 4. 暂时性死区（TDZ - Temporal Dead Zone）
var d = 1;
{
  console.log(d); // ReferenceError（块级作用域内有let声明d）
  let d = 2;
}

// 5. 不会成为全局对象的属性
let e = 5;
console.log(window.e); // undefined
```

**let 解决var的问题：**
```javascript
// 解决循环问题
for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 0, 1, 2（每次循环都有独立的i）
  }, 1000);
}

// 块级作用域
if (true) {
  let temp = 'test';
  console.log(temp); // 'test'
}
console.log(temp); // ReferenceError

// for循环的块级作用域
for (let i = 0; i < 3; i++) {
  let i = 'abc'; // 内层作用域，不影响外层的i
  console.log(i); // 'abc', 'abc', 'abc'
}
```

**暂时性死区详解：**
```javascript
// 示例1：块级作用域内的暂时性死区
let x = 10;
{
  console.log(x); // ReferenceError（不会访问外层的x）
  let x = 20;
}

// 示例2：函数参数的暂时性死区
function test(x = y, y = 2) { // ReferenceError
  return [x, y];
}
test();

// 正确写法
function test2(y = 2, x = y) {
  return [x, y];
}
test2(); // [2, 2]

// 示例3：typeof的暂时性死区
typeof x; // ReferenceError
let x;

// 对比：未声明的变量
typeof undeclaredVar; // 'undefined'（不报错）
```

---

### 3. const - 常量声明

**基本特性：**
```javascript
// 1. 必须初始化
const a; // SyntaxError: Missing initializer in const declaration
const a = 1; // 正确

// 2. 不能重新赋值
const b = 2;
b = 3; // TypeError: Assignment to constant variable

// 3. 块级作用域
{
  const c = 3;
  console.log(c); // 3
}
console.log(c); // ReferenceError

// 4. 不允许重复声明
const d = 4;
const d = 5; // SyntaxError

// 5. 暂时性死区
console.log(e); // ReferenceError
const e = 5;
```

**const 对象属性可以修改：**
```javascript
// const声明的对象，引用不能改变，但属性可以修改
const obj = {
  name: '张三',
  age: 20
};

// ✅ 可以修改属性
obj.name = '李四';
obj.age = 21;
console.log(obj); // { name: '李四', age: 21 }

// ❌ 不能重新赋值
obj = { name: '王五' }; // TypeError

// const声明的数组
const arr = [1, 2, 3];

// ✅ 可以修改元素
arr[0] = 10;
arr.push(4);
console.log(arr); // [10, 2, 3, 4]

// ❌ 不能重新赋值
arr = [5, 6, 7]; // TypeError

// 如果需要完全不可变，使用Object.freeze()
const frozenObj = Object.freeze({ name: '张三' });
frozenObj.name = '李四'; // 静默失败（严格模式下报错）
console.log(frozenObj.name); // '张三'
```

**const 深度冻结：**
```javascript
// Object.freeze()只是浅冻结
const obj = {
  name: '张三',
  info: {
    age: 20
  }
};

Object.freeze(obj);

obj.name = '李四'; // 无效
console.log(obj.name); // '张三'

obj.info.age = 21; // ✅ 有效（嵌套对象没有冻结）
console.log(obj.info.age); // 21

// 深度冻结实现
function deepFreeze(obj) {
  // 冻结对象本身
  Object.freeze(obj);

  // 递归冻结所有属性
  Object.keys(obj).forEach(key => {
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      deepFreeze(obj[key]);
    }
  });

  return obj;
}

const deepFrozenObj = deepFreeze({
  name: '张三',
  info: {
    age: 20
  }
});

deepFrozenObj.info.age = 21; // 无效
console.log(deepFrozenObj.info.age); // 20
```

---

### 使用场景和最佳实践

**推荐使用顺序：**
```
优先使用 const > 再用 let > 避免使用 var
```

**使用场景：**

1. **const**：
   - ✅ 常量值（π、配置项等）
   - ✅ 不需要重新赋值的变量
   - ✅ 函数声明
   - ✅ 导入的模块

```javascript
// 常量
const PI = 3.14159;
const MAX_SIZE = 100;

// 配置
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000
};

// 函数
const add = (a, b) => a + b;

// 导入
import React from 'react';
const Button = () => <button>Click</button>;
```

2. **let**：
   - ✅ 需要重新赋值的变量
   - ✅ 循环变量
   - ✅ 临时变量

```javascript
// 需要重新赋值
let count = 0;
count++;

// 循环
for (let i = 0; i < 10; i++) {
  console.log(i);
}

// 临时变量
let temp = arr[0];
arr[0] = arr[1];
arr[1] = temp;
```

3. **var**：
   - ❌ 避免使用（仅在需要兼容老代码时使用）

**最佳实践示例：**
```javascript
// ✅ 好的做法
const users = [
  { id: 1, name: '张三' },
  { id: 2, name: '李四' }
];

for (const user of users) {
  console.log(user.name); // const可以用于for...of
}

let total = 0;
for (let i = 0; i < users.length; i++) {
  total += users[i].id;
}

// ❌ 不好的做法
var users2 = []; // 应该用const
var total2 = 0;  // 应该用let
for (var i = 0; i < users2.length; i++) { // 应该用let
  // ...
}
```

**记忆口诀：**
```
var函数域、会提升、可重复、能重赋
let块级域、不提升、禁重复、能重赋
const块级域、不提升、禁重复、禁重赋
优先const、再用let、避免var
```

---

# 第四部分：事件机制基础（详细完整）

## 一、事件流三阶段

### 事件流三阶段详解 ⭐⭐⭐⭐⭐ 🔥

**核心概念：**
事件传播分三个阶段：**捕获阶段（外→内）→ 目标阶段 → 冒泡阶段（内→外）**

**视觉示意：**
```
捕获阶段 (Capture Phase)：外层 → 内层
    ↓
目标阶段 (Target Phase)：目标元素
    ↓
冒泡阶段 (Bubble Phase)：内层 → 外层
```

**完整示例：**
```html
<div id="outer">
  外层
  <div id="middle">
    中层
    <div id="inner">
      内层
    </div>
  </div>
</div>

<script>
const outer = document.getElementById('outer');
const middle = document.getElementById('middle');
const inner = document.getElementById('inner');

// 捕获阶段（第三个参数为true）
outer.addEventListener('click', () => {
  console.log('外层 - 捕获');
}, true);

middle.addEventListener('click', () => {
  console.log('中层 - 捕获');
}, true);

inner.addEventListener('click', () => {
  console.log('内层 - 捕获');
}, true);

// 冒泡阶段（第三个参数为false或省略）
outer.addEventListener('click', () => {
  console.log('外层 - 冒泡');
});

middle.addEventListener('click', () => {
  console.log('中层 - 冒泡');
});

inner.addEventListener('click', () => {
  console.log('内层 - 冒泡');
});

// 点击内层div，输出顺序：
// 外层 - 捕获
// 中层 - 捕获
// 内层 - 捕获
// 内层 - 冒泡
// 中层 - 冒泡
// 外层 - 冒泡
</script>
```

**执行顺序演示：**
```javascript
// 完整示例：演示三个阶段
document.addEventListener('click', () => {
  console.log('1. document - 捕获');
}, true);

document.body.addEventListener('click', () => {
  console.log('2. body - 捕获');
}, true);

const parent = document.getElementById('parent');
parent.addEventListener('click', () => {
  console.log('3. parent - 捕获');
}, true);

const child = document.getElementById('child');
child.addEventListener('click', () => {
  console.log('4. child - 目标');
});

parent.addEventListener('click', () => {
  console.log('5. parent - 冒泡');
});

document.body.addEventListener('click', () => {
  console.log('6. body - 冒泡');
});

document.addEventListener('click', () => {
  console.log('7. document - 冒泡');
});

// 点击child元素，完整输出：
// 1. document - 捕获
// 2. body - 捕获
// 3. parent - 捕获
// 4. child - 目标
// 5. parent - 冒泡
// 6. body - 冒泡
// 7. document - 冒泡
```

---

### 阻止事件传播

**三种阻止传播的方法：**

#### 1. stopPropagation() - 阻止事件传播

```javascript
element.addEventListener('click', (e) => {
  e.stopPropagation(); // 阻止事件继续传播（捕获或冒泡）
  console.log('事件停止传播');
});
```

**示例：阻止冒泡**
```html
<div id="parent" style="padding: 50px; background: blue;">
  父元素
  <div id="child" style="padding: 20px; background: red;">
    子元素
  </div>
</div>

<script>
const parent = document.getElementById('parent');
const child = document.getElementById('child');

parent.addEventListener('click', () => {
  console.log('父元素被点击');
});

child.addEventListener('click', (e) => {
  e.stopPropagation(); // 阻止冒泡到父元素
  console.log('子元素被点击');
});

// 点击子元素，只输出：子元素被点击
// 点击父元素，输出：父元素被点击
</script>
```

---

#### 2. preventDefault() - 阻止默认行为

```javascript
element.addEventListener('click', (e) => {
  e.preventDefault(); // 阻止元素的默认行为
  console.log('默认行为被阻止');
});
```

**常见应用场景：**
```javascript
// 1. 阻止链接跳转
document.querySelector('a').addEventListener('click', (e) => {
  e.preventDefault();
  console.log('阻止了链接跳转');
});

// 2. 阻止表单提交
document.querySelector('form').addEventListener('submit', (e) => {
  e.preventDefault();
  console.log('阻止了表单提交');
  // 执行自定义提交逻辑
});

// 3. 阻止右键菜单
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  console.log('阻止了右键菜单');
});

// 4. 阻止拖拽默认行为
element.addEventListener('dragover', (e) => {
  e.preventDefault();
});

element.addEventListener('drop', (e) => {
  e.preventDefault();
  console.log('处理文件拖放');
});
```

---

#### 3. stopImmediatePropagation() - 立即停止传播

```javascript
element.addEventListener('click', (e) => {
  e.stopImmediatePropagation(); // 阻止事件传播，且同级监听器也不执行
  console.log('立即停止传播');
});
```

**与 stopPropagation() 的区别：**
```javascript
const button = document.getElementById('btn');

// 监听器1
button.addEventListener('click', (e) => {
  console.log('监听器1');
  e.stopPropagation(); // 只阻止冒泡，同级监听器仍执行
});

// 监听器2
button.addEventListener('click', () => {
  console.log('监听器2'); // 会执行
});

// 点击按钮，输出：
// 监听器1
// 监听器2

// ========================================

// 监听器1
button.addEventListener('click', (e) => {
  console.log('监听器1');
  e.stopImmediatePropagation(); // 立即停止，同级监听器不执行
});

// 监听器2
button.addEventListener('click', () => {
  console.log('监听器2'); // 不会执行
});

// 点击按钮，只输出：
// 监听器1
```

---

**三种方法对比表格：**

| 方法 | 作用 | 是否阻止冒泡 | 是否阻止默认行为 | 是否阻止同级监听器 |
|------|------|------------|----------------|------------------|
| **stopPropagation()** | 阻止事件传播 | ✅ 是 | ❌ 否 | ❌ 否 |
| **preventDefault()** | 阻止默认行为 | ❌ 否 | ✅ 是 | ❌ 否 |
| **stopImmediatePropagation()** | 立即停止传播 | ✅ 是 | ❌ 否 | ✅ 是 |

**记忆口诀：**
```
stop阻冒泡、prevent阻默认、immediate最彻底
捕获从外到内、冒泡从内到外、目标阶段在中间
```

---

## 二、事件委托

### 事件委托详解 ⭐⭐⭐⭐⭐ 🔥

**核心原理：**
利用事件冒泡，在父元素绑定一个事件，通过 `event.target` 判断事件源

**三大优点：**
1. ✅ **减少内存消耗**：只绑定一个监听器，而不是每个子元素都绑定
2. ✅ **动态元素自动有事件**：新增的子元素自动继承事件
3. ✅ **代码简洁**：统一管理事件处理

---

### 简单示例

**不使用事件委托（❌ 不推荐）：**
```javascript
// 为每个按钮绑定事件
const buttons = document.querySelectorAll('.item');
buttons.forEach(button => {
  button.addEventListener('click', function() {
    console.log('点击了:', this.textContent);
  });
});

// 问题1：内存消耗大（100个按钮 = 100个监听器）
// 问题2：动态添加的按钮没有事件
const newButton = document.createElement('button');
newButton.className = 'item';
newButton.textContent = '新按钮';
document.body.appendChild(newButton);
// 新按钮点击没有反应！
```

**使用事件委托（✅ 推荐）：**
```javascript
// 只在父元素绑定一个事件
document.getElementById('list').addEventListener('click', (e) => {
  // 判断点击的是否是按钮
  if (e.target.matches('.item')) {
    console.log('点击了:', e.target.textContent);
  }
});

// 优点1：只有1个监听器，内存消耗小
// 优点2：动态添加的按钮自动有事件
const newButton = document.createElement('button');
newButton.className = 'item';
newButton.textContent = '新按钮';
document.getElementById('list').appendChild(newButton);
// 新按钮点击有反应！
```

---

### 复杂示例

**HTML结构：**
```html
<ul id="list">
  <li data-id="1">
    <span class="name">项目1</span>
    <button class="edit">编辑</button>
    <button class="delete">删除</button>
  </li>
  <li data-id="2">
    <span class="name">项目2</span>
    <button class="edit">编辑</button>
    <button class="delete">删除</button>
  </li>
</ul>
```

**事件委托处理：**
```javascript
const list = document.getElementById('list');

list.addEventListener('click', (e) => {
  const target = e.target;

  // 点击编辑按钮
  if (target.matches('.edit')) {
    const li = target.closest('li');
    const id = li.dataset.id;
    const name = li.querySelector('.name').textContent;
    console.log('编辑项目：', id, name);
  }

  // 点击删除按钮
  if (target.matches('.delete')) {
    const li = target.closest('li');
    const id = li.dataset.id;
    console.log('删除项目：', id);
    li.remove();
  }

  // 点击项目名称
  if (target.matches('.name')) {
    const li = target.closest('li');
    const id = li.dataset.id;
    console.log('点击项目：', id);
  }
});

// 动态添加新项目
function addItem(id, name) {
  const li = document.createElement('li');
  li.dataset.id = id;
  li.innerHTML = `
    <span class="name">${name}</span>
    <button class="edit">编辑</button>
    <button class="delete">删除</button>
  `;
  list.appendChild(li);
}

addItem(3, '项目3'); // 新增的项目自动有事件
```

---

### 完整实现（EventDelegate 类）

```javascript
class EventDelegate {
  /**
   * 事件委托类
   * @param {Element} parent - 父元素
   * @param {string} selector - 子元素选择器
   * @param {string} eventType - 事件类型
   * @param {Function} handler - 事件处理函数
   */
  constructor(parent, selector, eventType, handler) {
    this.parent = parent;
    this.selector = selector;
    this.eventType = eventType;
    this.handler = handler;

    // 绑定事件
    this.listener = (e) => {
      let target = e.target;

      // 向上查找匹配的元素
      while (target && target !== parent) {
        if (target.matches(selector)) {
          // 调用处理函数，this指向匹配的元素
          handler.call(target, e);
          break;
        }
        target = target.parentElement;
      }
    };

    parent.addEventListener(eventType, this.listener);
  }

  // 移除事件委托
  destroy() {
    this.parent.removeEventListener(this.eventType, this.listener);
  }
}

// 使用示例1：简单列表
const delegate1 = new EventDelegate(
  document.getElementById('list'),
  '.item',
  'click',
  function(e) {
    console.log('点击了:', this.textContent);
  }
);

// 使用示例2：复杂交互
const delegate2 = new EventDelegate(
  document.getElementById('todo-list'),
  '.todo-item',
  'click',
  function(e) {
    const target = e.target;

    // 点击复选框
    if (target.matches('.checkbox')) {
      this.classList.toggle('completed');
    }

    // 点击删除按钮
    if (target.matches('.delete')) {
      this.remove();
    }
  }
);

// 移除事件委托
// delegate1.destroy();
// delegate2.destroy();
```

---

### 事件委托的注意事项

**1. 不是所有事件都适合委托：**
```javascript
// ✅ 适合委托的事件（会冒泡）
// click、mousedown、mouseup、keydown、keyup、input、change、submit等

// ❌ 不适合委托的事件（不冒泡）
// focus、blur、scroll、load、mouseenter、mouseleave等

// focus/blur 的替代方案（使用捕获阶段或focusin/focusout）
parent.addEventListener('focus', handler, true); // 捕获阶段
parent.addEventListener('focusin', handler);     // focusin会冒泡
```

**2. 性能考虑：**
```javascript
// ❌ 不好：频繁的DOM查询
list.addEventListener('click', (e) => {
  if (e.target.matches('.item')) {
    const parent = e.target.parentElement;
    const siblings = parent.querySelectorAll('.item'); // 每次都查询
    // ...
  }
});

// ✅ 好：缓存查询结果
const list = document.getElementById('list');
list.addEventListener('click', (e) => {
  if (e.target.matches('.item')) {
    // 直接使用 list，不用重复查询
    // ...
  }
});
```

**3. 阻止冒泡的影响：**
```javascript
// 如果子元素阻止冒泡，事件委托会失效
const child = document.querySelector('.child');
child.addEventListener('click', (e) => {
  e.stopPropagation(); // 阻止冒泡
  console.log('子元素');
});

// 父元素的委托事件不会触发
parent.addEventListener('click', () => {
  console.log('父元素'); // 不会执行
});
```

**记忆口诀：**
```
事件委托利用冒泡，父元素代理子元素
减少内存动态绑，target判断是关键
向上查找用closest，matches判断选择器
```

---

## 三、事件对象

### target vs currentTarget ⭐⭐⭐⭐⭐ 🔥

**核心区别：**
- **target**：事件的真正触发者（事件源）
- **currentTarget**：事件监听器绑定的元素（等同于 this）

**完整示例：**
```html
<div id="parent" style="padding: 50px; background: lightblue;">
  父元素
  <button id="child">子按钮</button>
</div>

<script>
const parent = document.getElementById('parent');
const child = document.getElementById('child');

parent.addEventListener('click', function(e) {
  console.log('=== 点击事件 ===');
  console.log('e.target:', e.target);               // 真正点击的元素
  console.log('e.currentTarget:', e.currentTarget); // 绑定监听器的元素
  console.log('this:', this);                       // 等同于currentTarget
  console.log('相等:', e.currentTarget === this);   // true
});

// 点击子按钮，输出：
// e.target: <button id="child">子按钮</button>
// e.currentTarget: <div id="parent">...</div>
// this: <div id="parent">...</div>
// 相等: true

// 点击父元素（空白区域），输出：
// e.target: <div id="parent">...</div>
// e.currentTarget: <div id="parent">...</div>
// this: <div id="parent">...</div>
// 相等: true
</script>
```

---

### 详细对比

**对比表格：**

| 属性 | target | currentTarget |
|------|--------|---------------|
| **指向** | 事件的真正触发者 | 事件监听器绑定的元素 |
| **是否变化** | ✅ 会变化（冒泡过程中） | ❌ 不变（始终是绑定元素） |
| **等同于** | 事件源 | this（普通函数中） |
| **使用场景** | 判断具体点击了哪个元素 | 获取绑定监听器的元素 |

---

### 事件委托中的应用

```javascript
document.getElementById('list').addEventListener('click', function(e) {
  console.log('点击的元素（target）:', e.target.tagName);
  console.log('绑定事件的元素（currentTarget）:', e.currentTarget.id);
  console.log('this:', this.id);

  // 判断点击的是否是按钮
  if (e.target.matches('button')) {
    console.log('点击了按钮:', e.target.textContent);
  }
});

// 点击按钮，输出：
// 点击的元素（target）: BUTTON
// 绑定事件的元素（currentTarget）: list
// this: list
// 点击了按钮: xxx
```

---

### 箭头函数中的 this

```javascript
const parent = document.getElementById('parent');

// 普通函数：this === currentTarget
parent.addEventListener('click', function(e) {
  console.log(this === e.currentTarget); // true
  console.log(this.id); // 'parent'
});

// 箭头函数：this 不指向 currentTarget
parent.addEventListener('click', (e) => {
  console.log(this === e.currentTarget); // false
  console.log(this); // window（或外层作用域的this）
  console.log(e.currentTarget.id); // 'parent'（使用currentTarget）
});
```

---

### 常用事件对象属性

**完整列表：**
```javascript
element.addEventListener('click', (event) => {
  // === 事件目标 ===
  event.target           // 事件源（真正触发事件的元素）
  event.currentTarget    // 绑定事件的元素（等同于this）

  // === 事件类型 ===
  event.type             // 事件类型：'click'、'keydown'等
  event.bubbles          // 是否冒泡：true/false
  event.cancelable       // 是否可取消默认行为：true/false

  // === 鼠标事件 ===
  event.clientX          // 相对于视口的X坐标
  event.clientY          // 相对于视口的Y坐标
  event.pageX            // 相对于页面的X坐标
  event.pageY            // 相对于页面的Y坐标
  event.offsetX          // 相对于目标元素的X坐标
  event.offsetY          // 相对于目标元素的Y坐标
  event.screenX          // 相对于屏幕的X坐标
  event.screenY          // 相对于屏幕的Y坐标
  event.button           // 按下的鼠标按钮：0左键、1中键、2右键

  // === 键盘事件 ===
  event.key              // 按键值：'Enter'、'Escape'、'a'等
  event.code             // 按键代码：'KeyA'、'Enter'等
  event.keyCode          // 按键码（已废弃，用key代替）
  event.ctrlKey          // 是否按下Ctrl
  event.shiftKey         // 是否按下Shift
  event.altKey           // 是否按下Alt
  event.metaKey          // 是否按下Meta（Mac的Command键）

  // === 事件控制 ===
  event.preventDefault()           // 阻止默认行为
  event.stopPropagation()          // 阻止事件传播
  event.stopImmediatePropagation() // 立即停止传播

  // === 其他 ===
  event.timeStamp        // 事件创建时的时间戳
  event.isTrusted        // 是否为用户操作触发（true）或脚本触发（false）
  event.detail           // 事件的详细信息（如点击次数）
});
```

---

### 实战示例

**示例1：获取鼠标坐标**
```javascript
document.addEventListener('click', (e) => {
  console.log({
    '相对视口': `(${e.clientX}, ${e.clientY})`,
    '相对页面': `(${e.pageX}, ${e.pageY})`,
    '相对元素': `(${e.offsetX}, ${e.offsetY})`,
    '相对屏幕': `(${e.screenX}, ${e.screenY})`
  });
});
```

**示例2：键盘快捷键**
```javascript
document.addEventListener('keydown', (e) => {
  // Ctrl + S：保存
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    console.log('保存');
  }

  // Ctrl + Shift + F：格式化
  if (e.ctrlKey && e.shiftKey && e.key === 'f') {
    e.preventDefault();
    console.log('格式化');
  }

  // Esc：关闭
  if (e.key === 'Escape') {
    console.log('关闭');
  }
});
```

**示例3：双击检测**
```javascript
let clickCount = 0;
let timer = null;

element.addEventListener('click', (e) => {
  clickCount++;

  if (clickCount === 1) {
    timer = setTimeout(() => {
      console.log('单击');
      clickCount = 0;
    }, 300);
  } else if (clickCount === 2) {
    clearTimeout(timer);
    console.log('双击');
    clickCount = 0;
  }
});
```

**记忆口诀：**
```
target是源头，currentTarget是绑定
this等于currentTarget，箭头函数要注意
clientXY相对视口，pageXY相对页面
key获取按键，ctrlKey判断组合键
```

---

# 今日练习题

## CSS 练习题（2题）

### 题目1：请写出以下元素的实际宽度
```css
/* 标准盒模型 */
.box1 {
  width: 200px;
  padding: 20px;
  border: 10px solid;
  margin: 10px;
  box-sizing: content-box;
}

/* IE盒模型 */
.box2 {
  width: 200px;
  padding: 20px;
  border: 10px solid;
  margin: 10px;
  box-sizing: border-box;
}
```

**答案：**
- box1 实际占用宽度 = 10 + 10 + 20 + 200 + 20 + 10 + 10 = 280px
  - content宽度 = 200px
- box2 实际占用宽度 = 10 + 200 + 10 = 220px
  - content宽度 = 200 - 20*2 - 10*2 = 140px

---

### 题目2：请计算以下选择器的权重，并说明哪个样式会生效
```css
#header .nav li { color: red; }        /* 选择器1 */
.container .nav li { color: blue; }    /* 选择器2 */
div ul li { color: green; }            /* 选择器3 */
li { color: yellow !important; }       /* 选择器4 */
```

**答案：**
- 选择器1 权重：100 + 10 + 1 = 111
- 选择器2 权重：10 + 10 + 1 = 21
- 选择器3 权重：1 + 1 + 1 = 3
- 选择器4 权重：∞（!important最高）

**最终生效：选择器4 的 yellow**，因为 !important 优先级最高

---

## Vue 练习题（3题）

### 题目1：ref 和 reactive 有什么区别？以下代码输出什么？
```javascript
import { ref, reactive } from 'vue';

const count1 = ref(0);
const count2 = reactive({ value: 0 });

console.log(count1.value);     // ?
console.log(count2.value);     // ?

count1.value = 1;
count2 = { value: 1 };

console.log(count1.value);     // ?
console.log(count2.value);     // ?
```

**答案：**
```javascript
console.log(count1.value);     // 0
console.log(count2.value);     // 0

count1.value = 1;              // ✅ 正确
count2 = { value: 1 };         // ❌ 错误！失去响应式

console.log(count1.value);     // 1
console.log(count2.value);     // 0（count2重新赋值失去响应式）
```

**正确做法：**
```javascript
count2.value = 1;  // ✅ 修改属性
```

---

### 题目2：Vue2 和 Vue3 响应式原理有什么区别？
**答案：**

| 特性 | Vue2 | Vue3 |
|------|------|------|
| **实现方式** | Object.defineProperty | Proxy |
| **监听新增属性** | ❌ 无法监听 | ✅ 可以监听 |
| **监听数组索引** | ❌ 无法监听 | ✅ 可以监听 |
| **性能** | 需递归遍历所有属性 | 懒代理，按需代理 |

---

### 题目3：computed 和 watch 有什么区别？
**答案：**

| 特性 | computed | watch |
|------|----------|-------|
| **缓存** | ✅ 有缓存 | ❌ 无缓存 |
| **返回值** | ✅ 必须有 | ❌ 无 |
| **异步** | ❌ 不支持 | ✅ 支持 |
| **使用场景** | 计算派生数据 | 执行副作用操作 |

---

## JavaScript 练习题（2题）

### 题目1：请写出以下代码的输出
```javascript
console.log(typeof null);
console.log(typeof []);
console.log(typeof function(){});

console.log([] instanceof Array);
console.log({} instanceof Object);

console.log(Object.prototype.toString.call(null));
console.log(Object.prototype.toString.call([]));
```

**答案：**
```javascript
console.log(typeof null);          // 'object'（历史bug）
console.log(typeof []);            // 'object'
console.log(typeof function(){});  // 'function'

console.log([] instanceof Array);  // true
console.log({} instanceof Object); // true

console.log(Object.prototype.toString.call(null));  // '[object Null]'
console.log(Object.prototype.toString.call([]));    // '[object Array]'
```

---

### 题目2：var、let、const 有什么区别？
**答案：**

| 特性 | var | let | const |
|------|-----|-----|-------|
| **作用域** | 函数作用域 | 块级作用域 | 块级作用域 |
| **变量提升** | ✅ 提升 | ❌ 不提升（暂时性死区） | ❌ 不提升（暂时性死区） |
| **重复声明** | ✅ 允许 | ❌ 不允许 | ❌ 不允许 |
| **重新赋值** | ✅ 允许 | ✅ 允许 | ❌ 不允许 |

---

## 事件机制练习题（2题）

### 题目1：事件流有哪三个阶段？执行顺序是什么？
**答案：**

事件流三个阶段：
1. **捕获阶段**（Capture Phase）：从外层到内层（document → 目标元素）
2. **目标阶段**（Target Phase）：到达目标元素
3. **冒泡阶段**（Bubble Phase）：从内层到外层（目标元素 → document）

**执行顺序：**
```
捕获阶段 → 目标阶段 → 冒泡阶段
```

---

### 题目2：target 和 currentTarget 有什么区别？
**答案：**

| 属性 | target | currentTarget |
|------|--------|---------------|
| **指向** | 事件的真正触发者（事件源） | 事件监听器绑定的元素 |
| **等同于** | 无 | this（普通函数中） |
| **使用场景** | 判断具体点击了哪个元素 | 获取绑定监听器的元素 |

**示例：**
```javascript
parent.addEventListener('click', function(e) {
  console.log(e.target);        // 点击的具体元素（可能是子元素）
  console.log(e.currentTarget); // parent（绑定事件的元素）
  console.log(this);            // parent（等同于currentTarget）
});
```

---

# 今日总结

## 核心知识点回顾

### CSS 核心口诀
```
标准盒模型：width只是content
IE盒模型：width包含padding和border

!important最霸道
行内样式权重千
ID一百类十个
标签一分通配零
```

### Vue 核心口诀
```
Vue2用defineProperty，Vue3用Proxy代理
ref需value，reactive不需
computed计算缓存，watch侦听副作用
```

### JavaScript 核心口诀
```
数串布空未，符号大整，对象一家亲

typeof快速看基本，instanceof查原型链
toString最准确，Array专门判数组

var函数域、let/const块级域
优先const、再用let、避免var
```

### 事件机制核心口诀
```
捕获从外到内、冒泡从内到外、目标阶段在中间
stop阻冒泡、prevent阻默认、immediate最彻底
事件委托利用冒泡，父元素代理子元素
target是源头，currentTarget是绑定
```

---

## 明日预告 - 第二天学习内容

### 第二天将学习：
1. **CSS布局**：Flex布局、Grid布局、定位
2. **Vue进阶**：生命周期、组件通信、路由
3. **JavaScript进阶**：this指向、闭包、原型链
4. **异步编程**：Promise、async/await、事件循环

### 学习建议：
1. 今天的内容要完全理解，不要急于进入明天
2. 多做练习题，巩固今天的知识点
3. 把所有记忆口诀背下来
4. 尝试用自己的话解释今天的概念

---

**祝你学习顺利！加油！💪**