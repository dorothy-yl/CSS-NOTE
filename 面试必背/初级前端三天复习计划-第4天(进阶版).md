# 初级前端三天复习计划 - 第四天（进阶版）

> 📅 **学习时间**：第四天（进阶学习） | **目标**：深入理解核心原理 | **建议时长**：6-8小时
> ⚠️ **难度说明**：本文档包含较深入的底层原理，建议在掌握前三天基础后学习

## 📚 今日学习内容

| 模块 | 核心知识点 | 重要程度 | 预计时长 |
|------|-----------|---------|----------|
| **Vue响应式原理** | Object.defineProperty、Proxy底层实现 | ⭐⭐⭐⭐⭐ | 2.5小时 |
| **JavaScript进阶** | call/apply/bind实现、闭包高级应用 | ⭐⭐⭐⭐⭐ | 2.5小时 |
| **Promise深入** | 链式调用、执行顺序分析 | ⭐⭐⭐⭐⭐ | 2小时 |
| **事件机制进阶** | passive优化、keep-alive钩子 | ⭐⭐⭐⭐ | 1小时 |

---

# 第一部分：Vue响应式原理深入

## 一、Vue2响应式原理底层实现 ⭐⭐⭐⭐⭐

### 1. Object.defineProperty完整实现

**核心原理：** 数据劫持 + 发布订阅模式

```javascript
// 1. 依赖收集器（Dep）
class Dep {
  constructor() {
    this.subscribers = []; // 订阅者列表
  }

  // 添加订阅者
  addSub(watcher) {
    this.subscribers.push(watcher);
  }

  // 通知所有订阅者更新
  notify() {
    this.subscribers.forEach(watcher => watcher.update());
  }

  // 依赖收集
  depend() {
    if (Dep.target) {
      this.addSub(Dep.target);
    }
  }
}

// 当前正在收集依赖的Watcher
Dep.target = null;

// 2. 观察者（Watcher）
class Watcher {
  constructor(vm, key, updateFn) {
    this.vm = vm;
    this.key = key;
    this.updateFn = updateFn;

    // 首次读取，触发依赖收集
    Dep.target = this;
    this.value = vm[key]; // 触发getter
    Dep.target = null;
  }

  update() {
    const newValue = this.vm[this.key];
    if (newValue !== this.value) {
      this.value = newValue;
      this.updateFn(newValue);
    }
  }
}

// 3. 响应式转换
function defineReactive(obj, key, val) {
  const dep = new Dep(); // 每个属性都有自己的dep

  // 递归处理嵌套对象
  if (typeof val === 'object' && val !== null) {
    observe(val);
  }

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      console.log(`读取 ${key}: ${val}`);
      // 依赖收集
      dep.depend();
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      console.log(`设置 ${key}: ${val} -> ${newVal}`);
      val = newVal;

      // 新值是对象，需要继续观察
      if (typeof newVal === 'object' && newVal !== null) {
        observe(newVal);
      }

      // 通知所有订阅者
      dep.notify();
    }
  });
}

// 4. 观察对象
function observe(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return;
  }

  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key]);
  });
}

// 5. Vue实例简化版
class Vue {
  constructor(options) {
    this.$data = options.data;

    // 数据代理：vm.xxx -> vm.$data.xxx
    Object.keys(this.$data).forEach(key => {
      Object.defineProperty(this, key, {
        get() {
          return this.$data[key];
        },
        set(newVal) {
          this.$data[key] = newVal;
        }
      });
    });

    // 观察数据
    observe(this.$data);
  }
}

// 使用示例
const vm = new Vue({
  data: {
    count: 0,
    user: {
      name: '张三',
      age: 20
    }
  }
});

// 创建Watcher观察count变化
new Watcher(vm, 'count', (newValue) => {
  console.log(`count更新为: ${newValue}`);
});

vm.count = 1; // 输出：设置 count: 0 -> 1，count更新为: 1
vm.count = 2; // 输出：设置 count: 1 -> 2，count更新为: 2
```

### 2. Vue2响应式的局限性

```javascript
const vm = new Vue({
  data: {
    obj: { name: '张三' },
    arr: [1, 2, 3]
  }
});

// ❌ 问题1：无法监听新增属性
vm.obj.age = 20; // 不会触发更新
console.log(vm.obj.age); // 20，但视图不更新

// ✅ 解决方案：使用Vue.set
Vue.set(vm.obj, 'age', 20);
// 或
vm.$set(vm.obj, 'age', 20);

// ❌ 问题2：无法监听数组索引变化
vm.arr[0] = 100; // 不会触发更新

// ✅ 解决方案：使用数组变异方法
vm.arr.splice(0, 1, 100); // 触发更新
vm.arr.push(4); // 触发更新

// ❌ 问题3：无法监听数组length变化
vm.arr.length = 0; // 不会触发更新

// ✅ 解决方案：使用splice
vm.arr.splice(0); // 清空数组并触发更新
```

**Vue2数组处理方案：**
```javascript
// Vue2重写了数组的7个变异方法
const arrayMethods = Object.create(Array.prototype);
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

methodsToPatch.forEach(method => {
  const original = Array.prototype[method];

  Object.defineProperty(arrayMethods, method, {
    value: function(...args) {
      // 调用原始方法
      const result = original.apply(this, args);

      // 触发更新
      const ob = this.__ob__;
      let inserted;

      // 新增的元素需要继续观察
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break;
        case 'splice':
          inserted = args.slice(2);
          break;
      }

      if (inserted) ob.observeArray(inserted);

      // 通知更新
      ob.dep.notify();

      return result;
    }
  });
});
```

---

## 二、Vue3响应式原理底层实现 ⭐⭐⭐⭐⭐

### 1. Proxy完整实现

```javascript
// 1. 依赖映射表
const targetMap = new WeakMap();

// 2. 当前活跃的effect
let activeEffect = null;

// 3. 依赖收集
function track(target, key) {
  if (!activeEffect) return;

  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }

  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }

  dep.add(activeEffect);
}

// 4. 触发更新
function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;

  const dep = depsMap.get(key);
  if (dep) {
    dep.forEach(effect => effect());
  }
}

// 5. 响应式转换
function reactive(target) {
  if (typeof target !== 'object' || target === null) {
    return target;
  }

  return new Proxy(target, {
    get(target, key, receiver) {
      console.log(`读取 ${key}`);
      const result = Reflect.get(target, key, receiver);

      // 依赖收集
      track(target, key);

      // 懒代理：只有访问到的嵌套对象才会被代理
      if (typeof result === 'object' && result !== null) {
        return reactive(result);
      }

      return result;
    },

    set(target, key, value, receiver) {
      const oldValue = target[key];
      const result = Reflect.set(target, key, value, receiver);

      // 值变化才触发更新
      if (oldValue !== value) {
        console.log(`设置 ${key}: ${oldValue} -> ${value}`);
        trigger(target, key);
      }

      return result;
    },

    deleteProperty(target, key) {
      const hadKey = Object.prototype.hasOwnProperty.call(target, key);
      const result = Reflect.deleteProperty(target, key);

      if (hadKey && result) {
        console.log(`删除 ${key}`);
        trigger(target, key);
      }

      return result;
    }
  });
}

// 6. 副作用函数
function effect(fn) {
  activeEffect = fn;
  fn(); // 立即执行，触发依赖收集
  activeEffect = null;
}

// 使用示例
const state = reactive({
  count: 0,
  user: {
    name: '张三',
    age: 20
  },
  arr: [1, 2, 3]
});

// 创建副作用
effect(() => {
  console.log(`count的值是: ${state.count}`);
});
// 输出：读取 count，count的值是: 0

state.count = 1;
// 输出：设置 count: 0 -> 1，读取 count，count的值是: 1

// ✅ 优势1：可以监听新增属性
state.user.gender = '男'; // 自动触发更新

// ✅ 优势2：可以监听数组索引变化
state.arr[0] = 100; // 自动触发更新

// ✅ 优势3：可以监听数组length变化
state.arr.length = 0; // 自动触发更新

// ✅ 优势4：可以监听删除操作
delete state.user.age; // 自动触发更新
```

### 2. ref的实现原理

```javascript
function ref(value) {
  return {
    _isRef: true,
    _value: value,

    get value() {
      track(this, 'value');
      return this._value;
    },

    set value(newValue) {
      if (newValue !== this._value) {
        this._value = newValue;
        trigger(this, 'value');
      }
    }
  };
}

// 使用
const count = ref(0);

effect(() => {
  console.log(`count: ${count.value}`);
});

count.value = 1; // 触发更新
```

---

# 第二部分：JavaScript进阶深入

## 一、call/apply/bind实现原理 ⭐⭐⭐⭐⭐

### 1. 手写call

```javascript
Function.prototype.myCall = function(context, ...args) {
  // 1. 处理context（null/undefined指向window）
  context = context || window;

  // 2. 将函数设置为context的属性
  const fnSymbol = Symbol('fn'); // 使用Symbol避免属性名冲突
  context[fnSymbol] = this;

  // 3. 调用函数
  const result = context[fnSymbol](...args);

  // 4. 删除临时属性
  delete context[fnSymbol];

  // 5. 返回结果
  return result;
};

// 测试
function greet(greeting, punctuation) {
  console.log(`${greeting}, 我是${this.name}${punctuation}`);
}

const user = { name: '张三' };

greet.myCall(user, '你好', '!');
// 输出：你好, 我是张三!
```

### 2. 手写apply

```javascript
Function.prototype.myApply = function(context, argsArray) {
  // 1. 处理context
  context = context || window;

  // 2. 处理参数（apply接收数组）
  argsArray = argsArray || [];

  // 3. 将函数设置为context的属性
  const fnSymbol = Symbol('fn');
  context[fnSymbol] = this;

  // 4. 调用函数（展开数组）
  const result = context[fnSymbol](...argsArray);

  // 5. 删除临时属性
  delete context[fnSymbol];

  // 6. 返回结果
  return result;
};

// 测试
const numbers = [5, 6, 2, 3, 7];
const max = Math.max.myApply(null, numbers);
console.log(max); // 7
```

### 3. 手写bind

```javascript
Function.prototype.myBind = function(context, ...bindArgs) {
  const fn = this;

  // 返回新函数
  return function(...callArgs) {
    // 合并参数：bind时的参数 + 调用时的参数
    return fn.apply(context, [...bindArgs, ...callArgs]);
  };
};

// 测试
const user = {
  name: '张三',
  greet(greeting, time) {
    console.log(`${greeting}, ${this.name}! 现在是${time}`);
  }
};

const boundGreet = user.greet.myBind(user, '早上好');
boundGreet('8点');
// 输出：早上好, 张三! 现在是8点
```

### 4. 支持new的bind实现（完整版）

```javascript
Function.prototype.myBind = function(context, ...bindArgs) {
  const fn = this;

  const boundFunction = function(...callArgs) {
    // 判断是否通过new调用
    // 如果是new调用，this指向新创建的实例
    // 否则，this指向绑定的context
    return fn.apply(
      this instanceof boundFunction ? this : context,
      [...bindArgs, ...callArgs]
    );
  };

  // 继承原函数的原型
  boundFunction.prototype = Object.create(fn.prototype);

  return boundFunction;
};

// 测试new的情况
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const BoundPerson = Person.myBind(null, '张三');
const person = new BoundPerson(20);
console.log(person.name); // 张三
console.log(person.age);  // 20
```

---

## 二、闭包高级应用 ⭐⭐⭐⭐⭐

### 1. 模块化模式

```javascript
const CounterModule = (function() {
  // 私有变量
  let count = 0;
  let history = [];

  // 私有方法
  function log(action, value) {
    history.push({ action, value, time: Date.now() });
  }

  // 公开API
  return {
    increment() {
      count++;
      log('increment', count);
      return count;
    },

    decrement() {
      count--;
      log('decrement', count);
      return count;
    },

    getCount() {
      return count;
    },

    getHistory() {
      return [...history]; // 返回副本，防止外部修改
    },

    reset() {
      count = 0;
      history = [];
      log('reset', 0);
    }
  };
})();

// 使用
console.log(CounterModule.increment()); // 1
console.log(CounterModule.increment()); // 2
console.log(CounterModule.decrement()); // 1
console.log(CounterModule.getHistory());
// [
//   { action: 'increment', value: 1, time: ... },
//   { action: 'increment', value: 2, time: ... },
//   { action: 'decrement', value: 1, time: ... }
// ]

// ❌ 无法直接访问私有变量
console.log(CounterModule.count); // undefined
```

### 2. 函数柯里化（Curry）

```javascript
// 通用柯里化函数
function curry(fn) {
  return function curried(...args) {
    // 参数够了，执行原函数
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }

    // 参数不够，返回新函数继续收集参数
    return function(...nextArgs) {
      return curried.apply(this, [...args, ...nextArgs]);
    };
  };
}

// 示例1：简单的加法函数
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3));       // 6
console.log(curriedAdd(1, 2)(3));       // 6
console.log(curriedAdd(1)(2, 3));       // 6
console.log(curriedAdd(1, 2, 3));       // 6

// 示例2：实际应用 - 日志函数
function log(level, time, message) {
  console.log(`[${level}] ${time}: ${message}`);
}

const curriedLog = curry(log);

// 创建专门的日志函数
const errorLog = curriedLog('ERROR');
const errorLogToday = errorLog(new Date().toISOString());

errorLogToday('数据库连接失败');
errorLogToday('服务器崩溃');
// 输出：
// [ERROR] 2024-01-01T12:00:00.000Z: 数据库连接失败
// [ERROR] 2024-01-01T12:00:00.000Z: 服务器崩溃
```

### 3. 函数记忆（Memoization）

```javascript
function memoize(fn) {
  const cache = new Map();

  return function(...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      console.log('从缓存读取');
      return cache.get(key);
    }

    console.log('计算新结果');
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 示例：斐波那契数列
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);

console.log(memoizedFib(40)); // 第一次：计算新结果，耗时较长
console.log(memoizedFib(40)); // 第二次：从缓存读取，瞬间返回
```

---

# 第三部分：Promise深入理解

## 一、Promise链式调用执行顺序 ⭐⭐⭐⭐⭐

### 1. 基础执行顺序

```javascript
console.log('1');

new Promise((resolve, reject) => {
  console.log('2'); // Promise构造函数是同步的
  resolve('成功');
  console.log('3'); // resolve后的代码仍会执行
}).then(res => {
  console.log('4'); // then是微任务
});

console.log('5');

// 输出顺序：1 -> 2 -> 3 -> 5 -> 4
```

### 2. 多层then链式调用

```javascript
Promise.resolve()
  .then(() => {
    console.log('1');
    return Promise.resolve('2');
  })
  .then(res => {
    console.log(res);
  });

Promise.resolve()
  .then(() => {
    console.log('3');
  })
  .then(() => {
    console.log('4');
  })
  .then(() => {
    console.log('5');
  });

// 输出顺序：1 -> 3 -> 4 -> 5 -> 2
// 原因：return Promise.resolve()会多一个微任务
```

**详细分析：**
```javascript
// 第一轮微任务
Promise.resolve().then() // 微任务1
Promise.resolve().then() // 微任务2

// 执行微任务1：输出'1'，return Promise.resolve('2')
// 这里会产生一个新的微任务（等待Promise完成）

// 执行微任务2：输出'3'，注册下一个then

// 第二轮微任务
// Promise.resolve('2')完成，但还需要一个微任务来处理
.then(() => console.log('4'))

// 第三轮微任务
.then(() => console.log('5'))

// 第四轮微任务
.then(res => console.log(res)) // 输出'2'
```

### 3. async/await执行顺序

```javascript
async function async1() {
  console.log('1');
  await async2();
  console.log('2'); // await后面的代码相当于放在then里
}

async function async2() {
  console.log('3');
}

console.log('4');

setTimeout(() => {
  console.log('5');
}, 0);

async1();

new Promise(resolve => {
  console.log('6');
  resolve();
}).then(() => {
  console.log('7');
});

console.log('8');

// 输出顺序：4 -> 1 -> 3 -> 6 -> 8 -> 2 -> 7 -> 5
```

**详细分析：**
```javascript
// 同步代码执行
console.log('4');           // 输出：4
setTimeout(...);            // 宏任务，加入队列
async1();                   // 进入async1
  console.log('1');         // 输出：1
  await async2();           // 进入async2
    console.log('3');       // 输出：3
  // await后面的代码变成微任务
new Promise(...)
  console.log('6');         // 输出：6
  resolve();                // then回调变成微任务
console.log('8');           // 输出：8

// 微任务队列：[async1的await后续, then回调]
// 执行微任务
console.log('2');           // 输出：2
console.log('7');           // 输出：7

// 宏任务
console.log('5');           // 输出：5
```

---

## 二、async/await串行vs并行 ⭐⭐⭐⭐⭐

### 1. 串行执行（慢）

```javascript
async function fetchDataSerial() {
  console.time('串行');

  // 请求按顺序执行，总耗时 = 各请求耗时之和
  const user = await fetchUser();    // 1秒
  const posts = await fetchPosts();  // 2秒
  const comments = await fetchComments(); // 1秒

  console.timeEnd('串行'); // 约4秒

  return { user, posts, comments };
}

// 模拟请求
function fetchUser() {
  return new Promise(resolve => {
    setTimeout(() => resolve({ name: '张三' }), 1000);
  });
}

function fetchPosts() {
  return new Promise(resolve => {
    setTimeout(() => resolve([1, 2, 3]), 2000);
  });
}

function fetchComments() {
  return new Promise(resolve => {
    setTimeout(() => resolve(['好评', '差评']), 1000);
  });
}
```

### 2. 并行执行（快）⭐⭐⭐⭐⭐

**方式1：Promise.all**
```javascript
async function fetchDataParallel1() {
  console.time('并行1');

  // 所有请求同时发出，总耗时 = 最慢请求的耗时
  const [user, posts, comments] = await Promise.all([
    fetchUser(),    // 1秒
    fetchPosts(),   // 2秒
    fetchComments() // 1秒
  ]);

  console.timeEnd('并行1'); // 约2秒

  return { user, posts, comments };
}
```

**方式2：同时发起，分别await**
```javascript
async function fetchDataParallel2() {
  console.time('并行2');

  // 同时发起请求（不await）
  const userPromise = fetchUser();
  const postsPromise = fetchPosts();
  const commentsPromise = fetchComments();

  // 再分别await（此时已经在并行执行了）
  const user = await userPromise;
  const posts = await postsPromise;
  const comments = await commentsPromise;

  console.timeEnd('并行2'); // 约2秒

  return { user, posts, comments };
}
```

### 3. 混合模式：部分串行，部分并行

```javascript
async function fetchDataMixed() {
  console.time('混合');

  // 第一步：先获取用户信息（必须先完成）
  const user = await fetchUser(); // 1秒

  // 第二步：根据用户信息，并行获取posts和comments
  const [posts, comments] = await Promise.all([
    fetchPosts(user.id),    // 2秒
    fetchComments(user.id)  // 1秒
  ]);

  console.timeEnd('混合'); // 约3秒（1 + 2）

  return { user, posts, comments };
}
```

---

# 第四部分：事件机制进阶

## 一、passive性能优化 ⭐⭐⭐⭐⭐

### 1. passive的作用

```javascript
// ❌ 问题：传统滚动监听会阻塞
element.addEventListener('scroll', (e) => {
  // 浏览器不知道这里会不会调用e.preventDefault()
  // 所以必须等待这个函数执行完
  // 导致滚动卡顿
  doSomething();
});

// ✅ 解决：使用passive告诉浏览器不会阻止默认行为
element.addEventListener('scroll', (e) => {
  // 浏览器可以立即执行滚动，不用等待
  doSomething();
}, { passive: true });

// ⚠️ 注意：passive为true时，e.preventDefault()会失效
element.addEventListener('touchstart', (e) => {
  e.preventDefault(); // ❌ 不起作用，会报警告
  doSomething();
}, { passive: true });
```

### 2. 性能对比测试

```javascript
// 测试1：不使用passive（卡顿）
let count1 = 0;
document.addEventListener('scroll', () => {
  count1++;
  // 模拟耗时操作
  for (let i = 0; i < 1000000; i++) {}
  console.log('不使用passive:', count1);
});

// 测试2：使用passive（流畅）
let count2 = 0;
document.addEventListener('scroll', () => {
  count2++;
  for (let i = 0; i < 1000000; i++) {}
  console.log('使用passive:', count2);
}, { passive: true });

// 快速滚动测试，使用passive的版本明显更流畅
```

---

## 二、keep-alive生命周期钩子 ⭐⭐⭐⭐

### 1. activated vs mounted

```vue
<script setup>
import { onMounted, onActivated, onDeactivated, ref } from 'vue';

const data = ref(null);
const scrollPosition = ref(0);

// 只在首次挂载时执行
onMounted(() => {
  console.log('组件首次挂载');
  fetchData();
});

// 每次激活时执行（包括首次）
onActivated(() => {
  console.log('组件被激活');

  // 恢复滚动位置
  window.scrollTo(0, scrollPosition.value);

  // 刷新数据
  refreshData();
});

// 每次停用时执行
onDeactivated(() => {
  console.log('组件被停用');

  // 保存滚动位置
  scrollPosition.value = window.scrollY;

  // 取消未完成的请求
  cancelPendingRequests();
});

function fetchData() {
  // 首次加载数据
}

function refreshData() {
  // 刷新数据（可能不是首次）
}

function cancelPendingRequests() {
  // 取消正在进行的请求
}
</script>
```

### 2. 实战：列表页缓存

```vue
<!-- 父组件 -->
<template>
  <keep-alive>
    <component :is="currentView"></component>
  </keep-alive>
</template>

<!-- 列表组件 -->
<script setup>
import { ref, onActivated, onDeactivated } from 'vue';

const list = ref([]);
const page = ref(1);
const scrollTop = ref(0);

// 首次进入或从详情页返回时触发
onActivated(() => {
  console.log('列表页激活');

  // 恢复滚动位置
  nextTick(() => {
    const container = document.querySelector('.list-container');
    if (container) {
      container.scrollTop = scrollTop.value;
    }
  });

  // 如果列表为空，加载数据
  if (list.value.length === 0) {
    loadList();
  }
});

// 跳转到详情页时触发
onDeactivated(() => {
  console.log('列表页停用');

  // 保存滚动位置
  const container = document.querySelector('.list-container');
  if (container) {
    scrollTop.value = container.scrollTop;
  }
});

function loadList() {
  // 加载列表数据
}
</script>
```

---

# 综合总结

## 📊 第四天学习内容回顾

| 主题 | 核心难点 | 掌握要求 |
|------|----------|----------|
| **Vue响应式** | Object.defineProperty vs Proxy实现原理 | 理解底层机制 |
| **JavaScript进阶** | 手写call/apply/bind、闭包高级应用 | 能手写实现 |
| **Promise深入** | 链式调用执行顺序、串行vs并行 | 能分析执行流程 |
| **事件机制** | passive优化、keep-alive钩子 | 理解性能优化 |

## 💡 学习建议

### 进阶路线
1. **掌握底层原理**：不只是会用，还要懂原理
2. **手写实现**：通过手写加深理解
3. **性能优化**：学会分析性能瓶颈
4. **实战应用**：在项目中应用这些知识

### 后续学习方向
- 事件循环（Event Loop）深入
- 虚拟DOM和diff算法
- Vuex/Pinia状态管理
- TypeScript进阶
- 工程化和构建工具

---

**🎉 四天学习完成！从基础到进阶，你已经具备了扎实的前端功底！继续深入学习，向中高级工程师迈进！💪**
