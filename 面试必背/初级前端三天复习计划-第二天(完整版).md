# 初级前端三天复习计划 - 第二天（完整版）

> 学习说明：本文档整合了CSS布局、Vue进阶、JavaScript核心和事件机制的完整详细内容，包含所有代码示例、表格、记忆口诀。适合初级前端工程师系统复习。

## 📚 今日学习内容

- **第一部分**：CSS布局（display属性、元素隐藏方法）
- **第二部分**：Vue进阶（组件通信、生命周期）
- **第三部分**：JavaScript进阶（this指向、作用域与闭包）
- **第四部分**：事件机制进阶（addEventListener详解、防抖节流）

---

# 第一部分：CSS布局（完整详细）

## 一、display属性

### 三大核心值完整对比

**重要性：⭐⭐⭐⭐⭐ 高频必考**

| 属性值 | inline（内联） | block（块级） | inline-block（内联块） |
|--------|----------------|---------------|----------------------|
| **独占一行** | ❌ 不独占 | ✅ 独占 | ❌ 不独占 |
| **width/height** | ❌ 不能设置 | ✅ 可以设置 | ✅ 可以设置 |
| **margin/padding** | 只有水平方向 | 所有方向 | 所有方向 |
| **默认宽度** | 由内容决定 | 父容器100% | 由内容决定 |
| **常见元素** | span、a、em | div、p、h1-h6 | img、input、button |

### 1) inline（内联元素）

**特点：**
- 元素在一行内显示，不会换行
- 不能设置width和height
- 只能设置水平方向的margin和padding
- 内容决定元素大小

**代码示例：**
```css
span {
  display: inline;
  width: 100px;    /* ❌ 无效 */
  height: 50px;    /* ❌ 无效 */
  margin-top: 10px; /* ❌ 无效 */
  margin-left: 10px; /* ✅ 有效 */
  padding-top: 10px; /* ❌ 无效（不影响布局） */
  padding-left: 10px; /* ✅ 有效 */
}
```

**常见应用：**
```html
<!-- 文本中的链接、强调文本 -->
<p>这是一段文字，包含<a href="#">链接</a>和<em>强调内容</em></p>
```

### 2) block（块级元素）

**特点：**
- 独占一行，会换行
- 可以设置width和height
- 可以设置所有方向的margin和padding
- 默认宽度是父容器的100%

**代码示例：**
```css
div {
  display: block;
  width: 200px;     /* ✅ 有效 */
  height: 100px;    /* ✅ 有效 */
  margin: 20px;     /* ✅ 所有方向都有效 */
  padding: 10px;    /* ✅ 所有方向都有效 */
}
```

**常见应用：**
```html
<!-- 页面布局的主要容器 -->
<div class="container">
  <h1>标题</h1>
  <p>段落内容</p>
</div>
```

### 3) inline-block（内联块级元素）⭐⭐⭐⭐⭐

**特点：**
- 结合了inline和block的特性
- 像inline一样在一行内显示，不会换行
- 像block一样可以设置width、height、margin、padding
- 常用于导航菜单、按钮组、图片列表等

**代码示例：**
```css
span {
  display: inline-block;
  width: 120px;     /* ✅ 有效 */
  height: 40px;     /* ✅ 有效 */
  margin: 10px;     /* ✅ 所有方向都有效 */
  padding: 5px;     /* ✅ 所有方向都有效 */
  vertical-align: middle; /* 可以设置垂直对齐 */
}
```

**实际应用示例：**
```html
<style>
  /* 示例1：固定宽度的表单标签 */
  .form-label {
    display: inline-block;
    width: 120px;
    text-align: right;
    margin-right: 10px;
  }

  /* 示例2：导航菜单 */
  .nav-item {
    display: inline-block;
    padding: 10px 20px;
    margin: 0 5px;
    background: #f0f0f0;
  }

  /* 示例3：按钮组 */
  .btn {
    display: inline-block;
    width: 100px;
    height: 40px;
    line-height: 40px;
    text-align: center;
    background: #007bff;
    color: white;
  }
</style>

<!-- 表单布局 -->
<div class="form-item">
  <span class="form-label">用户名:</span>
  <input type="text">
</div>
<div class="form-item">
  <span class="form-label">上次登录时间:</span>
  <span>2022-7-11</span>
</div>

<!-- 导航菜单 -->
<nav>
  <a class="nav-item" href="#">首页</a>
  <a class="nav-item" href="#">产品</a>
  <a class="nav-item" href="#">关于</a>
</nav>

<!-- 按钮组 -->
<div>
  <span class="btn">确定</span>
  <span class="btn">取消</span>
</div>
```

### 其他display值

```css
/* 不显示，不占空间 */
.hide {
  display: none;
}

/* 弹性布局 */
.flex-container {
  display: flex;
}

/* 网格布局 */
.grid-container {
  display: grid;
}

/* 表格布局 */
.table {
  display: table;
}

/* 表格行 */
.table-row {
  display: table-row;
}

/* 表格单元格 */
.table-cell {
  display: table-cell;
}
```

### 记忆口诀

```
inline行内不换行、宽高设置都无效
block块级独占行、宽高边距全能设
inline-block最灵活、行内显示可设宽高
```

---

## 二、元素隐藏方法

### 九种隐藏方法完整对比

**重要性：⭐⭐⭐⭐ 高频考点**

| 方法 | 是否占据空间 | 是否可交互 | 是否影响子元素 | 性能影响 | 应用场景 |
|------|-------------|-----------|---------------|----------|----------|
| **display: none** | ❌ 不占据 | ❌ 不可交互 | ✅ 影响 | 重排+重绘 | 完全隐藏 |
| **visibility: hidden** | ✅ 占据 | ❌ 不可交互 | ✅ 影响 | 仅重绘 | 保留布局空间 |
| **opacity: 0** | ✅ 占据 | ✅ 可交互 | ✅ 影响 | 可能触发合成 | 透明动画 |
| **position + left: -9999px** | ❌ 不占据 | ❌ 不可交互 | ✅ 影响 | 重排+重绘 | 移出视口 |
| **clip-path: polygon(0 0)** | ✅ 占据 | ❌ 不可交互 | ✅ 影响 | 可能触发合成 | 裁剪隐藏 |
| **transform: scale(0)** | ✅ 占据 | ❌ 不可交互 | ✅ 影响 | 可能触发合成 | 缩放动画 |
| **height: 0 + overflow: hidden** | ❌ 不占据 | ❌ 不可交互 | ✅ 影响 | 重排+重绘 | 折叠动画 |
| **z-index: -1** | ✅ 占据 | ❌ 不可交互 | ❌ 不影响 | 仅重绘 | 层级隐藏 |
| **filter: blur(0)** | ✅ 占据 | ✅ 可交互 | ✅ 影响 | 可能触发合成 | 模糊效果 |

### 1) display: none（最常用）⭐⭐⭐⭐⭐

**说明：**
- 元素完全消失，不占据空间
- 不可交互（无法点击）
- 触发重排（reflow）和重绘（repaint）
- 子元素也会被隐藏，且无法通过设置display来显示

**代码示例：**
```css
.hide {
  display: none;  /* 元素完全消失，不占空间 */
}
```

**JavaScript控制：**
```javascript
// 隐藏元素
element.style.display = 'none';

// 显示元素
element.style.display = 'block'; // 或 'inline'、'inline-block'
```

**应用场景：**
```html
<!-- 模态框的显示隐藏 -->
<div class="modal" style="display: none;">
  <div class="modal-content">
    <p>模态框内容</p>
  </div>
</div>

<script>
// 显示模态框
document.querySelector('.modal').style.display = 'block';

// 隐藏模态框
document.querySelector('.modal').style.display = 'none';
</script>
```

### 2) visibility: hidden

**说明：**
- 元素不可见，但占据空间位置
- 不可交互（无法点击）
- 只触发重绘（repaint），不触发重排
- 子元素可以通过设置visibility: visible来显示

**代码示例：**
```css
.hide {
  visibility: hidden;  /* 元素不可见，但占据空间 */
}

/* 子元素可以显示 */
.hide .child {
  visibility: visible;
}
```

**JavaScript控制：**
```javascript
// 隐藏元素
element.style.visibility = 'hidden';

// 显示元素
element.style.visibility = 'visible';
```

**应用场景：**
```html
<!-- 保留布局空间的隐藏 -->
<style>
  .placeholder {
    visibility: hidden;
  }
</style>

<div class="container">
  <div class="item">可见项1</div>
  <div class="item placeholder">占位项</div>
  <div class="item">可见项2</div>
</div>
```

### 3) opacity: 0

**说明：**
- 元素完全透明，但占据空间
- ⚠️ 仍可交互（可以点击、可以触发事件）
- 适合做渐变动画
- 可能触发GPU合成

**代码示例：**
```css
.hide {
  opacity: 0;  /* 透明度为0，元素透明但仍占据空间 */
}

/* 配合transition做渐变效果 */
.fade {
  opacity: 1;
  transition: opacity 0.3s;
}

.fade.hide {
  opacity: 0;
}
```

**JavaScript控制：**
```javascript
// 隐藏元素（带动画）
element.style.transition = 'opacity 0.3s';
element.style.opacity = '0';

// 显示元素（带动画）
element.style.opacity = '1';
```

**应用场景：**
```html
<!-- 淡入淡出动画 -->
<style>
  .tooltip {
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none; /* 禁止交互 */
  }

  .tooltip.show {
    opacity: 1;
    pointer-events: auto; /* 恢复交互 */
  }
</style>

<div class="tooltip">提示信息</div>

<script>
// 显示提示
document.querySelector('.tooltip').classList.add('show');

// 隐藏提示
setTimeout(() => {
  document.querySelector('.tooltip').classList.remove('show');
}, 3000);
</script>
```

### 4) 移出视口（position + left: -9999px）

**说明：**
- 将元素移到屏幕外，不占据原位置空间
- 不可交互
- 对SEO友好（搜索引擎仍能读取内容）

**代码示例：**
```css
.hide {
  position: absolute;
  left: -9999px;  /* 移到屏幕外 */
  top: -9999px;
}

/* 或使用translate */
.hide-translate {
  transform: translateX(-9999px);
}
```

**应用场景：**
```html
<!-- 屏幕阅读器可访问的内容 -->
<style>
  .sr-only {
    position: absolute;
    left: -10000px;
    width: 1px;
    height: 1px;
    overflow: hidden;
  }
</style>

<button>
  <span class="sr-only">关闭对话框</span>
  <span aria-hidden="true">×</span>
</button>
```

### 5) 裁剪路径（clip-path）

**说明：**
- 通过裁剪路径隐藏元素
- 占据空间，不可交互
- 可以实现各种形状的裁剪效果

**代码示例：**
```css
.hide {
  clip-path: polygon(0 0, 0 0, 0 0, 0 0);  /* 裁剪为0大小 */
}

/* 圆形裁剪 */
.circle {
  clip-path: circle(50%);
}

/* 三角形裁剪 */
.triangle {
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
}
```

**应用场景：**
```html
<!-- 图片裁剪效果 -->
<style>
  .img-circle {
    clip-path: circle(50%);
  }

  .img-hexagon {
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
  }
</style>

<img src="avatar.jpg" class="img-circle">
<img src="photo.jpg" class="img-hexagon">
```

### 6) 缩放（transform: scale(0)）

**说明：**
- 将元素缩放为0
- 占据空间，不可交互
- 适合做缩放动画

**代码示例：**
```css
.hide {
  transform: scale(0);  /* 缩放为0 */
}

/* 配合transition做动画 */
.zoom {
  transform: scale(1);
  transition: transform 0.3s;
}

.zoom.hide {
  transform: scale(0);
}
```

**应用场景：**
```html
<!-- 缩放动画 -->
<style>
  .modal {
    transform: scale(0);
    transition: transform 0.3s;
  }

  .modal.show {
    transform: scale(1);
  }
</style>

<div class="modal">
  <p>模态框内容</p>
</div>
```

### 7) 高度折叠（height: 0 + overflow: hidden）

**说明：**
- 将高度设为0并隐藏溢出内容
- 不占据空间，不可交互
- 适合做折叠/展开动画

**代码示例：**
```css
.hide {
  height: 0;
  overflow: hidden;
}

/* 配合transition做折叠动画 */
.collapse {
  height: auto;
  transition: height 0.3s;
}

.collapse.hide {
  height: 0;
}
```

**应用场景：**
```html
<!-- 手风琴效果 -->
<style>
  .accordion-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s;
  }

  .accordion-content.show {
    max-height: 500px; /* 设置一个足够大的值 */
  }
</style>

<div class="accordion">
  <div class="accordion-header" onclick="toggleAccordion()">
    点击展开/收起
  </div>
  <div class="accordion-content">
    <p>折叠的内容</p>
  </div>
</div>

<script>
function toggleAccordion() {
  document.querySelector('.accordion-content').classList.toggle('show');
}
</script>
```

### 8) 层级隐藏（z-index: -1）

**说明：**
- 将元素放到其他元素后面
- 占据空间，不可交互（被其他元素遮挡）
- 不影响子元素

**代码示例：**
```css
.hide {
  position: relative;
  z-index: -1;  /* 放到后面 */
}
```

### 9) 模糊（filter: blur）

**说明：**
- 将元素模糊化
- 占据空间，可交互
- 可以实现模糊效果

**代码示例：**
```css
.blur {
  filter: blur(10px);
}
```

### 记忆口诀

```
display不占位、visibility占位不可见
opacity透明可点击、position移出视口外
clip-path裁剪hide、scale缩放为零
height折叠overflow、z-index层级藏、filter模糊看不清
```

**性能对比口诀：**
```
display最伤性能（重排+重绘）
visibility次之仅重绘
opacity性能最好（可能GPU加速）
transform性能也不错（可能GPU加速）
```

---

# 第二部分：Vue进阶（完整详细）

## 一、组件通信

### 1. props + emit（父子通信）⭐⭐⭐⭐⭐

**核心口诀：父传子props、子传父emit**

#### Vue3 完整代码示例

**父组件（Parent.vue）：**
```vue
<template>
  <div class="parent">
    <h2>父组件</h2>
    <p>父组件的数据：{{ parentMessage }}</p>
    <p>从子组件接收的数据：{{ childData }}</p>

    <!-- 通过props传递数据给子组件 -->
    <!-- 通过@update监听子组件的事件 -->
    <Child
      :message="parentMessage"
      :count="count"
      @update="handleUpdate"
      @increment="handleIncrement"
    />
  </div>
</template>

<script setup>
import { ref } from 'vue';
import Child from './Child.vue';

// 父组件的数据
const parentMessage = ref('这是来自父组件的消息');
const count = ref(0);
const childData = ref('');

// 处理子组件传来的数据
const handleUpdate = (data) => {
  console.log('收到子组件的数据:', data);
  childData.value = data;
};

// 处理子组件的计数增加
const handleIncrement = (newCount) => {
  console.log('子组件计数变化:', newCount);
  count.value = newCount;
};
</script>
```

**子组件（Child.vue）：**
```vue
<template>
  <div class="child">
    <h3>子组件</h3>
    <p>接收的消息：{{ message }}</p>
    <p>接收的计数：{{ count }}</p>

    <input v-model="inputValue" placeholder="输入数据">
    <button @click="sendToParent">发送数据给父组件</button>
    <button @click="incrementCount">增加计数</button>
  </div>
</template>

<script setup>
import { ref } from 'vue';

// 定义props
const props = defineProps({
  message: {
    type: String,
    required: true,
    default: ''
  },
  count: {
    type: Number,
    default: 0
  }
});

// 定义emits
const emit = defineEmits(['update', 'increment']);

// 子组件的数据
const inputValue = ref('');

// 向父组件发送数据
const sendToParent = () => {
  emit('update', inputValue.value);
};

// 增加计数并通知父组件
const incrementCount = () => {
  emit('increment', props.count + 1);
};
</script>
```

#### Vue2 写法对比

**父组件（Vue2）：**
```vue
<template>
  <div class="parent">
    <h2>父组件</h2>
    <p>父组件的数据：{{ parentMessage }}</p>
    <p>从子组件接收的数据：{{ childData }}</p>

    <Child
      :message="parentMessage"
      :count="count"
      @update="handleUpdate"
    />
  </div>
</template>

<script>
import Child from './Child.vue';

export default {
  components: {
    Child
  },
  data() {
    return {
      parentMessage: '这是来自父组件的消息',
      count: 0,
      childData: ''
    };
  },
  methods: {
    handleUpdate(data) {
      console.log('收到子组件的数据:', data);
      this.childData = data;
    }
  }
};
</script>
```

**子组件（Vue2）：**
```vue
<template>
  <div class="child">
    <h3>子组件</h3>
    <p>接收的消息：{{ message }}</p>
    <p>接收的计数：{{ count }}</p>

    <input v-model="inputValue" placeholder="输入数据">
    <button @click="sendToParent">发送数据给父组件</button>
  </div>
</template>

<script>
export default {
  props: {
    message: {
      type: String,
      required: true
    },
    count: {
      type: Number,
      default: 0
    }
  },
  data() {
    return {
      inputValue: ''
    };
  },
  methods: {
    sendToParent() {
      this.$emit('update', this.inputValue);
    }
  }
};
</script>
```

---

### 2. provide + inject（跨级通信）⭐⭐⭐⭐

**核心口诀：祖先provide、后代inject**

#### Vue3 完整代码示例

**祖先组件（Ancestor.vue）：**
```vue
<template>
  <div class="ancestor">
    <h2>祖先组件</h2>
    <p>主题: {{ theme }}</p>
    <p>用户: {{ user.name }} ({{ user.age }}岁)</p>

    <button @click="toggleTheme">切换主题</button>
    <button @click="updateUser">更新用户信息</button>

    <Parent />
  </div>
</template>

<script setup>
import { ref, provide, reactive } from 'vue';
import Parent from './Parent.vue';

// 提供普通数据
const theme = ref('light');
const toggleTheme = () => {
  theme.value = theme.value === 'light' ? 'dark' : 'light';
};

// 提供响应式对象
const user = reactive({
  name: '张三',
  age: 25
});

const updateUser = () => {
  user.name = '李四';
  user.age = 30;
};

// 提供方法
const updateTheme = (newTheme) => {
  theme.value = newTheme;
};

// 使用provide提供数据
provide('theme', theme);
provide('user', user);
provide('updateTheme', updateTheme);
</script>
```

**中间组件（Parent.vue）：**
```vue
<template>
  <div class="parent">
    <h3>中间父组件（不需要接收数据）</h3>
    <Child />
  </div>
</template>

<script setup>
import Child from './Child.vue';
</script>
```

**后代组件（Child.vue）：**
```vue
<template>
  <div class="child">
    <h4>后代组件</h4>
    <p>接收的主题: {{ theme }}</p>
    <p>接收的用户: {{ user.name }} ({{ user.age }}岁)</p>

    <button @click="changeTheme">更改主题为blue</button>
  </div>
</template>

<script setup>
import { inject } from 'vue';

// 使用inject接收数据
const theme = inject('theme');
const user = inject('user');
const updateTheme = inject('updateTheme');

// 使用祖先提供的方法
const changeTheme = () => {
  updateTheme('blue');
};
</script>
```

#### 响应式数据处理

**方式1：使用ref/reactive（推荐）**
```javascript
// 祖先组件
import { ref, provide } from 'vue';

const count = ref(0);
provide('count', count);

// 后代组件
import { inject } from 'vue';
const count = inject('count');
// count是响应式的，变化会自动更新
```

**方式2：使用readonly保护数据**
```javascript
// 祖先组件
import { ref, provide, readonly } from 'vue';

const count = ref(0);
provide('count', readonly(count)); // 后代只读，不能修改

// 提供修改方法
const increment = () => count.value++;
provide('increment', increment);
```

#### Vue2 写法

**祖先组件（Vue2）：**
```vue
<script>
export default {
  data() {
    return {
      theme: 'light',
      user: {
        name: '张三',
        age: 25
      }
    };
  },
  provide() {
    return {
      theme: this.theme,
      user: this.user, // ⚠️ Vue2中provide的数据默认不是响应式的
      updateTheme: this.updateTheme
    };
  },
  methods: {
    updateTheme(newTheme) {
      this.theme = newTheme;
    }
  }
};
</script>
```

**后代组件（Vue2）：**
```vue
<script>
export default {
  inject: ['theme', 'user', 'updateTheme'],
  methods: {
    changeTheme() {
      this.updateTheme('blue');
    }
  }
};
</script>
```

**Vue2响应式处理：**
```javascript
// 方式1：使用函数返回
provide() {
  return {
    getTheme: () => this.theme // 使用函数返回最新值
  };
}

// 方式2：使用Vue.observable（Vue 2.6+）
import Vue from 'vue';

provide() {
  this.state = Vue.observable({
    theme: 'light'
  });
  return {
    state: this.state
  };
}
```

---

### 3. v-model（双向绑定）⭐⭐⭐⭐⭐

**核心口诀：v-model本质是props加emit的语法糖**

#### v-model的原理

```vue
<!-- 以下两种写法完全等价 -->

<!-- 简写形式 -->
<Child v-model="value" />

<!-- 完整形式（Vue3） -->
<Child
  :modelValue="value"
  @update:modelValue="value = $event"
/>

<!-- 完整形式（Vue2） -->
<Child
  :value="value"
  @input="value = $event"
/>
```

#### Vue3 完整代码示例

**父组件：**
```vue
<template>
  <div class="parent">
    <h2>父组件</h2>
    <p>输入框的值: {{ inputValue }}</p>
    <p>开关状态: {{ switchValue }}</p>

    <!-- 单个v-model -->
    <CustomInput v-model="inputValue" />

    <!-- 多个v-model -->
    <UserForm
      v-model:name="userName"
      v-model:age="userAge"
      v-model:email="userEmail"
    />

    <!-- 自定义修饰符 -->
    <CustomInput v-model.capitalize="inputValue" />
  </div>
</template>

<script setup>
import { ref } from 'vue';
import CustomInput from './CustomInput.vue';
import UserForm from './UserForm.vue';

const inputValue = ref('');
const switchValue = ref(false);
const userName = ref('');
const userAge = ref(0);
const userEmail = ref('');
</script>
```

**子组件（CustomInput.vue）：**
```vue
<template>
  <div class="custom-input">
    <input
      :value="modelValue"
      @input="handleInput"
      placeholder="请输入内容"
    />
  </div>
</template>

<script setup>
// 定义props，接收v-model传来的值
const props = defineProps({
  modelValue: {
    type: String,
    default: ''
  },
  // 自定义修饰符
  modelModifiers: {
    default: () => ({})
  }
});

// 定义emit，用于更新v-model的值
const emit = defineEmits(['update:modelValue']);

// 处理输入事件
const handleInput = (event) => {
  let value = event.target.value;

  // 处理capitalize修饰符
  if (props.modelModifiers.capitalize) {
    value = value.charAt(0).toUpperCase() + value.slice(1);
  }

  // 触发更新
  emit('update:modelValue', value);
};
</script>
```

**子组件（开关组件）：**
```vue
<template>
  <div class="custom-switch" @click="toggle">
    <span :class="['switch', { active: modelValue }]"></span>
    <span>{{ modelValue ? '开' : '关' }}</span>
  </div>
</template>

<script setup>
const props = defineProps({
  modelValue: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits(['update:modelValue']);

const toggle = () => {
  emit('update:modelValue', !props.modelValue);
};
</script>

<style scoped>
.switch {
  display: inline-block;
  width: 40px;
  height: 20px;
  background: #ccc;
  border-radius: 10px;
  position: relative;
  transition: background 0.3s;
}

.switch::after {
  content: '';
  position: absolute;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: white;
  top: 1px;
  left: 1px;
  transition: left 0.3s;
}

.switch.active {
  background: #42b983;
}

.switch.active::after {
  left: 21px;
}
</style>
```

#### 多个v-model（Vue3独有）

**父组件：**
```vue
<template>
  <div>
    <UserForm
      v-model:name="userName"
      v-model:age="userAge"
      v-model:email="userEmail"
    />

    <p>用户名: {{ userName }}</p>
    <p>年龄: {{ userAge }}</p>
    <p>邮箱: {{ userEmail }}</p>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const userName = ref('');
const userAge = ref(0);
const userEmail = ref('');
</script>
```

**子组件（UserForm.vue）：**
```vue
<template>
  <div class="user-form">
    <div>
      <label>姓名:</label>
      <input
        :value="name"
        @input="$emit('update:name', $event.target.value)"
      />
    </div>

    <div>
      <label>年龄:</label>
      <input
        type="number"
        :value="age"
        @input="$emit('update:age', Number($event.target.value))"
      />
    </div>

    <div>
      <label>邮箱:</label>
      <input
        type="email"
        :value="email"
        @input="$emit('update:email', $event.target.value)"
      />
    </div>
  </div>
</template>

<script setup>
defineProps({
  name: String,
  age: Number,
  email: String
});

defineEmits(['update:name', 'update:age', 'update:email']);
</script>
```

#### Vue2 v-model

**Vue2中v-model等价于：**
```vue
<!-- 简写 -->
<CustomInput v-model="value" />

<!-- 完整写法 -->
<CustomInput
  :value="value"
  @input="value = $event"
/>
```

**子组件（Vue2）：**
```vue
<template>
  <input
    :value="value"
    @input="$emit('input', $event.target.value)"
  />
</template>

<script>
export default {
  props: {
    value: {
      type: String,
      default: ''
    }
  }
};
</script>
```

**Vue2自定义prop和event名称：**
```vue
<script>
export default {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  methods: {
    toggle() {
      this.$emit('change', !this.checked);
    }
  }
};
</script>
```

### 记忆口诀

```
父子通信props加emit、数据下传事件上抛
跨级通信provide inject、祖先后代不需桥
v-model双向绑定、本质还是props和emit
多个v-model Vue3专属、自定义修饰符也很强
```

---

## 二、Vue生命周期

### Vue2 vs Vue3 完整对比

**重要性：⭐⭐⭐⭐⭐ 必须掌握**

| 阶段 | Vue2 Options API | Vue3 Composition API | 调用时机 | 常见用途 |
|------|-----------------|---------------------|---------|---------|
| **创建前** | beforeCreate | setup | 实例初始化后 | - |
| **创建后** | created | setup | 数据观测、属性计算完成 | 数据初始化、API调用 |
| **挂载前** | beforeMount | onBeforeMount | 渲染到DOM前 | - |
| **挂载后** | mounted | onMounted | 渲染到DOM后 | DOM操作、第三方库初始化 |
| **更新前** | beforeUpdate | onBeforeUpdate | 数据更新，DOM更新前 | 访问更新前的DOM |
| **更新后** | updated | onUpdated | DOM更新后 | 操作更新后的DOM |
| **销毁前** | beforeDestroy | onBeforeUnmount | 实例销毁前 | 清理定时器、事件监听 |
| **销毁后** | destroyed | onUnmounted | 实例销毁后 | 最后的清理工作 |
| **激活** | activated | onActivated | keep-alive组件激活 | 恢复数据、重新获取数据 |
| **停用** | deactivated | onDeactivated | keep-alive组件停用 | 保存状态 |
| **错误捕获** | errorCaptured | onErrorCaptured | 捕获子组件错误 | 错误处理 |

### 生命周期详细说明

#### 1. 创建阶段

**beforeCreate（Vue2）/ setup（Vue3）**
- **时机**：实例初始化后，数据观测和事件配置之前
- **特点**：无法访问data、computed、methods
- **用途**：很少使用

**created（Vue2）/ setup（Vue3）**
- **时机**：实例创建完成，数据观测、属性计算、方法配置完成
- **特点**：可以访问data、computed、methods，但无法访问DOM
- **用途**：数据初始化、调用API获取数据

**代码示例（Vue2）：**
```javascript
export default {
  data() {
    return {
      message: 'Hello'
    };
  },
  beforeCreate() {
    console.log('beforeCreate');
    console.log(this.message); // undefined
  },
  created() {
    console.log('created');
    console.log(this.message); // 'Hello'

    // 常见用途：获取数据
    this.fetchData();
  },
  methods: {
    async fetchData() {
      const data = await fetch('/api/data');
      this.data = data;
    }
  }
};
```

**代码示例（Vue3）：**
```javascript
import { ref, onMounted } from 'vue';

export default {
  setup() {
    const message = ref('Hello');

    // setup相当于beforeCreate + created
    console.log('setup');
    console.log(message.value); // 'Hello'

    // 数据初始化
    const data = ref([]);

    // 获取数据
    const fetchData = async () => {
      const response = await fetch('/api/data');
      data.value = await response.json();
    };

    // 立即调用
    fetchData();

    return {
      message,
      data
    };
  }
};
```

#### 2. 挂载阶段

**beforeMount（Vue2）/ onBeforeMount（Vue3）**
- **时机**：在挂载开始之前被调用，render函数首次被调用
- **特点**：虚拟DOM已创建，真实DOM未生成
- **用途**：很少使用

**mounted（Vue2）/ onMounted（Vue3）⭐⭐⭐⭐⭐**
- **时机**：实例被挂载到DOM后调用
- **特点**：可以访问DOM元素、$refs可用
- **用途**：DOM操作、第三方库初始化、获取DOM信息

**代码示例（Vue2）：**
```javascript
export default {
  data() {
    return {
      chartInstance: null
    };
  },
  mounted() {
    console.log('mounted');

    // 1. DOM操作
    const element = this.$refs.myElement;
    console.log(element); // 可以访问DOM元素

    // 2. 初始化第三方库（如图表库）
    this.initChart();

    // 3. 添加事件监听
    window.addEventListener('resize', this.handleResize);

    // 4. 获取DOM尺寸
    const width = this.$refs.container.offsetWidth;
    console.log('容器宽度:', width);
  },
  methods: {
    initChart() {
      // 初始化图表
      this.chartInstance = new Chart(this.$refs.chart, {
        // 配置...
      });
    },
    handleResize() {
      // 处理窗口大小变化
    }
  },
  beforeDestroy() {
    // 清理
    window.removeEventListener('resize', this.handleResize);
    if (this.chartInstance) {
      this.chartInstance.destroy();
    }
  }
};
```

**代码示例（Vue3）：**
```vue
<template>
  <div ref="container">
    <canvas ref="chart"></canvas>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue';

const container = ref(null);
const chart = ref(null);
let chartInstance = null;

onMounted(() => {
  console.log('onMounted');

  // 1. DOM操作
  console.log(container.value); // 访问DOM元素

  // 2. 初始化第三方库
  chartInstance = new Chart(chart.value, {
    // 配置...
  });

  // 3. 添加事件监听
  window.addEventListener('resize', handleResize);

  // 4. 获取DOM尺寸
  const width = container.value.offsetWidth;
  console.log('容器宽度:', width);

  // 5. 滚动到指定位置
  window.scrollTo(0, 0);

  // 6. 聚焦输入框
  const input = document.querySelector('input');
  input?.focus();
});

const handleResize = () => {
  // 处理窗口大小变化
  if (chartInstance) {
    chartInstance.resize();
  }
};

onBeforeUnmount(() => {
  // 清理
  window.removeEventListener('resize', handleResize);
  if (chartInstance) {
    chartInstance.destroy();
  }
});
</script>
```

#### 3. 更新阶段

**beforeUpdate（Vue2）/ onBeforeUpdate（Vue3）**
- **时机**：数据更新时调用，发生在虚拟DOM重新渲染之前
- **特点**：可以访问更新前的DOM
- **用途**：获取更新前的DOM状态

**updated（Vue2）/ onUpdated（Vue3）**
- **时机**：虚拟DOM重新渲染后调用
- **特点**：可以访问更新后的DOM
- **用途**：操作更新后的DOM
- **⚠️注意**：避免在updated中修改数据，会导致无限循环

**代码示例：**
```javascript
// Vue3
import { ref, onBeforeUpdate, onUpdated } from 'vue';

const count = ref(0);
let prevHeight = 0;

onBeforeUpdate(() => {
  // 记录更新前的高度
  const element = document.querySelector('.content');
  prevHeight = element?.offsetHeight || 0;
});

onUpdated(() => {
  // 比较更新后的高度
  const element = document.querySelector('.content');
  const newHeight = element?.offsetHeight || 0;

  if (newHeight !== prevHeight) {
    console.log('高度变化:', prevHeight, '->', newHeight);
  }
});
```

#### 4. 销毁阶段⭐⭐⭐⭐⭐

**beforeDestroy（Vue2）/ onBeforeUnmount（Vue3）**
- **时机**：实例销毁前调用
- **特点**：实例仍然完全可用
- **用途**：清理定时器、事件监听、第三方库实例

**destroyed（Vue2）/ onUnmounted（Vue3）**
- **时机**：实例销毁后调用
- **特点**：所有指令解绑、事件监听器移除、子实例销毁
- **用途**：最后的清理工作

**代码示例（Vue2）：**
```javascript
export default {
  data() {
    return {
      timer: null,
      observer: null
    };
  },
  mounted() {
    // 设置定时器
    this.timer = setInterval(() => {
      console.log('定时执行');
    }, 1000);

    // 创建观察器
    this.observer = new IntersectionObserver(entries => {
      // 处理...
    });
    this.observer.observe(this.$refs.element);

    // 添加事件监听
    window.addEventListener('scroll', this.handleScroll);
  },
  beforeDestroy() {
    // 清理定时器
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }

    // 清理观察器
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }

    // 移除事件监听
    window.removeEventListener('scroll', this.handleScroll);

    // 清理第三方库
    if (this.chartInstance) {
      this.chartInstance.destroy();
    }
  }
};
```

**代码示例（Vue3）：**
```vue
<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue';

let timer = null;
let observer = null;

onMounted(() => {
  // 设置定时器
  timer = setInterval(() => {
    console.log('定时执行');
  }, 1000);

  // 创建观察器
  observer = new IntersectionObserver(entries => {
    // 处理...
  });
  const element = document.querySelector('.element');
  observer.observe(element);

  // 添加事件监听
  window.addEventListener('scroll', handleScroll);
});

const handleScroll = () => {
  // 处理滚动
};

onBeforeUnmount(() => {
  // 清理定时器
  if (timer) {
    clearInterval(timer);
    timer = null;
  }

  // 清理观察器
  if (observer) {
    observer.disconnect();
    observer = null;
  }

  // 移除事件监听
  window.removeEventListener('scroll', handleScroll);
});
</script>
```

#### 5. keep-alive专属

**activated（Vue2）/ onActivated（Vue3）**
- **时机**：被keep-alive缓存的组件激活时调用
- **用途**：恢复数据、重新获取数据

**deactivated（Vue2）/ onDeactivated（Vue3）**
- **时机**：被keep-alive缓存的组件停用时调用
- **用途**：保存状态、清理临时数据

**代码示例：**
```vue
<template>
  <keep-alive>
    <component :is="currentComponent"></component>
  </keep-alive>
</template>

<script setup>
import { onActivated, onDeactivated } from 'vue';

onActivated(() => {
  console.log('组件被激活');
  // 恢复数据、重新获取数据
  fetchData();
});

onDeactivated(() => {
  console.log('组件被停用');
  // 保存滚动位置
  saveScrollPosition();
});
</script>
```

### 记忆口诀

```
创建挂载更新销毁，四大阶段要记牢
created数据初始化，mounted可操作DOM
beforeUnmount清资源，定时事件要移除
activated keep-alive专属，组件激活时调用
```

**Vue2 vs Vue3对照口诀：**
```
beforeCreate created 变成 setup
beforeMount mounted 加上 on
beforeUpdate updated 也加 on
beforeDestroy destroyed 改名 Unmount
```

---

# 第三部分：JavaScript进阶（完整详细）

## 一、this指向

### 五种绑定规则⭐⭐⭐⭐⭐

**重要性：极高频考点，必须完全掌握**

**核心口诀：新显隐默箭**
```
新（new）建显（call/apply/bind）眼（隐式绑定）
默（默认绑定）认最低，箭（箭头函数）头看外层
```

**优先级：new绑定 > 显式绑定 > 隐式绑定 > 默认绑定**

### 1. 默认绑定

**规则：**
- 独立函数调用，this指向全局对象
- 非严格模式：this指向window
- 严格模式：this指向undefined

**完整代码示例：**
```javascript
// 非严格模式
function fn() {
  console.log(this); // window
  console.log(this.name); // undefined
}
fn();

// 严格模式
'use strict';
function fn2() {
  console.log(this); // undefined
}
fn2();

// 对象方法赋值给变量（隐式绑定丢失）
const obj = {
  name: '张三',
  sayName: function() {
    console.log(this.name);
  }
};
const fn3 = obj.sayName;
fn3(); // undefined（this指向window）
```

### 2. 隐式绑定

**规则：**
- 函数作为对象方法调用
- this指向调用该方法的对象
- ⚠️ 注意隐式绑定丢失问题

**完整代码示例：**
```javascript
// 基本用法
const person = {
  name: '李四',
  age: 25,
  sayHello: function() {
    console.log(`我是${this.name}，今年${this.age}岁`);
  },
  friend: {
    name: '王五',
    sayHello: function() {
      console.log(`我是${this.name}`);
    }
  }
};

person.sayHello(); // 我是李四，今年25岁（this指向person）
person.friend.sayHello(); // 我是王五（this指向friend对象）

// 隐式绑定丢失 - 情况1：赋值
const fn = person.sayHello;
fn(); // 我是undefined，今年undefined岁（this指向window）

// 隐式绑定丢失 - 情况2：传参
function execute(callback) {
  callback();
}
execute(person.sayHello); // this丢失

// 隐式绑定丢失 - 情况3：setTimeout
setTimeout(person.sayHello, 1000); // this丢失

// 解决方案1：使用箭头函数
setTimeout(() => person.sayHello(), 1000); // 正确

// 解决方案2：使用bind
setTimeout(person.sayHello.bind(person), 1000); // 正确
```

### 3. 显式绑定（call、apply、bind）⭐⭐⭐⭐⭐

**规则：**
- 通过call、apply、bind手动指定this
- call和apply立即执行，bind返回新函数

**完整代码示例：**
```javascript
const person = {
  name: '赵六',
  age: 30
};

function introduce(city, hobby) {
  console.log(`我是${this.name}，今年${this.age}岁，来自${city}，爱好${hobby}`);
}

// call - 参数逐个传递
introduce.call(person, '北京', '篮球');
// 输出：我是赵六，今年30岁，来自北京，爱好篮球

// apply - 参数以数组传递
introduce.apply(person, ['上海', '足球']);
// 输出：我是赵六，今年30岁，来自上海，爱好足球

// bind - 返回新函数，不立即执行
const boundIntroduce = introduce.bind(person, '广州');
boundIntroduce('游泳');
// 输出：我是赵六，今年30岁，来自广州，爱好游泳

// bind的柯里化
const partialIntroduce = introduce.bind(person);
partialIntroduce('深圳', '阅读');
// 输出：我是赵六，今年30岁，来自深圳，爱好阅读

// 实际应用：事件处理
class Counter {
  constructor() {
    this.count = 0;
    this.element = document.getElementById('btn');

    // 错误：this丢失
    // this.element.addEventListener('click', this.increment);

    // 正确：使用bind
    this.element.addEventListener('click', this.increment.bind(this));
  }

  increment() {
    this.count++;
    console.log(this.count);
  }
}
```

**call、apply、bind的区别：**
```javascript
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: '小明' };

// call：立即执行，参数逐个传递
console.log(greet.call(person, 'Hello', '!'));
// Hello, 小明!

// apply：立即执行，参数以数组传递
console.log(greet.apply(person, ['Hi', '~']));
// Hi, 小明~

// bind：返回新函数，不立即执行
const boundGreet = greet.bind(person, 'Hey');
console.log(boundGreet('?'));
// Hey, 小明?

// bind可以分步传参（柯里化）
const boundGreet2 = greet.bind(person);
console.log(boundGreet2('Welcome', '.'));
// Welcome, 小明.
```

### 4. new绑定

**规则：**
- 作为构造函数调用（使用new关键字）
- this指向新创建的实例对象

**完整代码示例：**
```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayHello = function() {
    console.log(`你好，我是${this.name}`);
  };
}

const person1 = new Person('孙七', 28);
const person2 = new Person('周八', 32);

console.log(person1.name); // 孙七
console.log(person2.name); // 周八

person1.sayHello(); // 你好，我是孙七
person2.sayHello(); // 你好，我是周八

// new的执行过程：
// 1. 创建一个新的空对象
// 2. 将新对象的__proto__指向构造函数的prototype
// 3. 将构造函数的this指向新对象，执行构造函数
// 4. 如果构造函数返回对象，则返回该对象；否则返回新对象

// 特殊情况：构造函数返回对象
function Person2(name) {
  this.name = name;
  return { name: '强制返回' }; // 返回其他对象
}

const p = new Person2('吴九');
console.log(p.name); // 强制返回（返回的是构造函数返回的对象）

// 构造函数返回基本类型
function Person3(name) {
  this.name = name;
  return 'ignored'; // 返回基本类型，被忽略
}

const p2 = new Person3('郑十');
console.log(p2.name); // 郑十（返回的是新创建的对象）
```

### 5. 箭头函数

**规则：**
- 箭头函数没有自己的this
- this继承自外层作用域（定义时所在的作用域）
- 不能通过call、apply、bind改变this指向
- 不能作为构造函数使用

**完整代码示例：**
```javascript
// 例1：箭头函数继承外层this
const obj = {
  name: '对象',
  // 普通函数
  fn1: function() {
    console.log(this.name); // '对象'
  },
  // 箭头函数
  fn2: () => {
    console.log(this.name); // undefined（this指向window）
  },
  // 嵌套：普通函数 + 箭头函数
  fn3: function() {
    const arrow = () => {
      console.log(this.name); // '对象'（继承fn3的this）
    };
    arrow();
  },
  // 嵌套：箭头函数 + 箭头函数
  fn4: () => {
    const arrow = () => {
      console.log(this.name); // undefined（继承fn4的this，即window）
    };
    arrow();
  }
};

obj.fn1(); // '对象'
obj.fn2(); // undefined
obj.fn3(); // '对象'
obj.fn4(); // undefined

// 例2：定时器中的this
const counter = {
  count: 0,
  // 错误：普通函数，this丢失
  start1: function() {
    setInterval(function() {
      this.count++; // this指向window
      console.log(this.count); // NaN
    }, 1000);
  },
  // 正确：箭头函数，继承外层this
  start2: function() {
    setInterval(() => {
      this.count++; // this指向counter
      console.log(this.count); // 1, 2, 3...
    }, 1000);
  },
  // 正确：bind绑定this
  start3: function() {
    setInterval(function() {
      this.count++;
      console.log(this.count);
    }.bind(this), 1000);
  }
};

// 例3：事件处理
class Button {
  constructor() {
    this.count = 0;
    this.element = document.getElementById('btn');

    // 错误：this丢失
    // this.element.addEventListener('click', this.handleClick);

    // 正确：箭头函数
    this.element.addEventListener('click', () => {
      this.handleClick();
    });

    // 或者使用bind
    // this.element.addEventListener('click', this.handleClick.bind(this));
  }

  handleClick() {
    this.count++;
    console.log(this.count);
  }
}

// 例4：数组方法中的this
const obj2 = {
  numbers: [1, 2, 3, 4, 5],
  multiplier: 2,

  // 普通函数 + 箭头函数
  multiply1: function() {
    return this.numbers.map(num => num * this.multiplier);
  },

  // 普通函数 + 普通函数（错误）
  multiply2: function() {
    return this.numbers.map(function(num) {
      return num * this.multiplier; // this是undefined
    });
  },

  // 普通函数 + 普通函数 + thisArg参数
  multiply3: function() {
    return this.numbers.map(function(num) {
      return num * this.multiplier;
    }, this); // 传入this作为第二个参数
  }
};

console.log(obj2.multiply1()); // [2, 4, 6, 8, 10]
console.log(obj2.multiply2()); // [NaN, NaN, NaN, NaN, NaN]
console.log(obj2.multiply3()); // [2, 4, 6, 8, 10]

// 例5：箭头函数不能作为构造函数
const ArrowFunc = () => {};
// const instance = new ArrowFunc(); // TypeError: ArrowFunc is not a constructor

// 例6：箭头函数不能通过call/apply/bind改变this
const obj3 = { name: 'obj3' };
const arrow = () => {
  console.log(this.name);
};

arrow.call(obj3); // undefined（无法改变this）
arrow.apply(obj3); // undefined
const boundArrow = arrow.bind(obj3);
boundArrow(); // undefined
```

### 优先级总结

```javascript
// 优先级：new > 显式绑定 > 隐式绑定 > 默认绑定

function fn() {
  console.log(this.name);
}

const obj = {
  name: '对象',
  fn: fn
};

const boundFn = fn.bind({ name: 'bind对象' });

// 1. 默认绑定（优先级最低）
fn(); // undefined

// 2. 隐式绑定
obj.fn(); // '对象'

// 3. 显式绑定（优先级高于隐式绑定）
obj.fn.call({ name: 'call对象' }); // 'call对象'

// 4. bind vs call（bind优先级低于call）
boundFn.call({ name: 'call对象' }); // 'bind对象'（bind已经固定this）

// 5. new绑定（优先级最高）
function Person(name) {
  this.name = name;
}
const boundPerson = Person.bind({ name: 'bind对象' });
const p = new boundPerson('new对象');
console.log(p.name); // 'new对象'（new优先级最高）
```

### 记忆口诀

```
新（new）建显（call/apply/bind）眼（隐式绑定）
默（默认绑定）认最低，箭（箭头函数）头看外层

默认绑定：独立调用，严格undefined非严格window
隐式绑定：对象方法，this指向调用对象
显式绑定：call/apply/bind，手动指定this
new绑定：构造函数，this指向新实例
箭头函数：没有this，继承外层作用域
```

---

## 二、作用域和闭包

### 作用域三兄弟⭐⭐⭐⭐

**核心口诀：全局函数块，从大到小找变量**

#### 1. 全局作用域

**特点：**
- 在任何地方都能访问
- 生命周期：页面打开到关闭
- window对象的属性和方法

**代码示例：**
```javascript
// 全局变量
var globalVar = '全局变量';
let globalLet = '全局let';
const globalConst = '全局const';

function fn() {
  console.log(globalVar); // 可以访问
  console.log(globalLet); // 可以访问
  console.log(globalConst); // 可以访问
}

// window对象的属性
console.log(window.globalVar); // '全局变量'
console.log(window.globalLet); // undefined（let不会挂载到window）
console.log(window.globalConst); // undefined（const不会挂载到window）

// 不使用var/let/const声明的变量会成为全局变量（不推荐）
function createGlobal() {
  implicitGlobal = '隐式全局变量';
}
createGlobal();
console.log(implicitGlobal); // '隐式全局变量'
console.log(window.implicitGlobal); // '隐式全局变量'
```

#### 2. 函数作用域

**特点：**
- 只在函数内部访问
- 函数执行时创建，执行结束后销毁
- var、let、const声明的变量都是函数作用域

**代码示例：**
```javascript
function outer() {
  var a = 1;
  let b = 2;
  const c = 3;

  function inner() {
    console.log(a); // 1（可以访问外层函数的变量）
    console.log(b); // 2
    console.log(c); // 3
  }

  inner();
}

outer();
// console.log(a); // ReferenceError: a is not defined
// console.log(b); // ReferenceError: b is not defined
// console.log(c); // ReferenceError: c is not defined

// 函数参数也是函数作用域
function fn(param) {
  console.log(param); // 可以访问
}
// console.log(param); // ReferenceError: param is not defined
```

#### 3. 块级作用域（ES6）

**特点：**
- 只在代码块{}内有效
- let和const声明的变量是块级作用域
- var声明的变量不是块级作用域

**代码示例：**
```javascript
// if块级作用域
if (true) {
  var a = 1;
  let b = 2;
  const c = 3;
}
console.log(a); // 1（var不是块级作用域）
// console.log(b); // ReferenceError（let是块级作用域）
// console.log(c); // ReferenceError（const是块级作用域）

// for循环块级作用域
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// 输出：3 3 3（var不是块级作用域，i被共享）

for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 1000);
}
// 输出：0 1 2（let是块级作用域，每次循环都是独立的j）

// switch块级作用域
switch (1) {
  case 1:
    let x = 10;
    console.log(x); // 10
    break;
  case 2:
    // let x = 20; // SyntaxError: Identifier 'x' has already been declared
    break;
}

// 单独的{}也是块级作用域
{
  let blockVar = 'block';
  console.log(blockVar); // 'block'
}
// console.log(blockVar); // ReferenceError
```

### 作用域链

**概念：**
当查找变量时，从当前作用域开始，逐级向上查找，直到全局作用域，形成的链式结构叫作用域链。

**代码示例：**
```javascript
var a = 1; // 全局作用域

function outer() {
  var b = 2; // outer函数作用域

  function middle() {
    var c = 3; // middle函数作用域

    function inner() {
      var d = 4; // inner函数作用域

      // 作用域链：inner → middle → outer → 全局
      console.log(a); // 1（全局作用域）
      console.log(b); // 2（outer作用域）
      console.log(c); // 3（middle作用域）
      console.log(d); // 4（inner作用域）
    }

    inner();
    // console.log(d); // ReferenceError（d在inner作用域）
  }

  middle();
}

outer();
```

---

### 闭包⭐⭐⭐⭐⭐

**重要性：高频必考，实际应用广泛**

#### 闭包的定义

闭包是指函数能够访问其定义时所在作用域的变量，即使函数在其他地方执行。

**闭包三要素：**
1. 函数嵌套函数
2. 内部函数引用外部函数的变量
3. 内部函数被返回或传递到外部

**记忆口诀：**
```
函数套函数（嵌套函数）
内访外变量（引用外部变量）
外传内函数（返回内部函数）
```

#### 闭包的作用

1. **数据私有化**：创建私有变量
2. **延长变量生命周期**：外部函数执行完，变量不会被销毁
3. **创建函数工厂**：生成特定功能的函数

#### 完整代码示例

**示例1：计数器（数据私有化）**
```javascript
// 不使用闭包（数据可以被外部修改）
let count = 0;
function increment() {
  count++;
  return count;
}
console.log(increment()); // 1
console.log(increment()); // 2
count = 100; // 可以被外部修改
console.log(increment()); // 101

// 使用闭包（数据私有）
function createCounter() {
  let count = 0; // 私有变量

  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
console.log(counter.decrement()); // 1
// counter.count = 100; // 无法直接修改count
console.log(counter.getCount()); // 1

// 每个计数器都有独立的count
const counter2 = createCounter();
console.log(counter2.increment()); // 1
console.log(counter.getCount()); // 1（不受counter2影响）
```

**示例2：循环问题与闭包解决方案**

```javascript
// 问题：使用var的循环（错误示例）
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 输出5个5
  }, 1000);
}
// 原因：setTimeout是异步的，循环结束后i已经是5
// 所有setTimeout共享同一个i

// 解决方案1：使用let（块级作用域）✅ 推荐
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i); // 输出0 1 2 3 4
  }, 1000);
}
// 原因：let在每次循环时都会创建新的作用域

// 解决方案2：使用闭包（IIFE）
for (var i = 0; i < 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j); // 输出0 1 2 3 4
    }, 1000);
  })(i);
}
// 原因：立即执行函数创建了新的作用域，j是参数的拷贝

// 解决方案3：使用闭包（函数工厂）
function createLogger(index) {
  return function() {
    console.log(index);
  };
}

for (var i = 0; i < 5; i++) {
  setTimeout(createLogger(i), 1000);
}
// 输出0 1 2 3 4

// 解决方案4：使用bind
for (var i = 0; i < 5; i++) {
  setTimeout(console.log.bind(null, i), 1000);
}
// 输出0 1 2 3 4
```

**示例3：函数工厂**
```javascript
// 创建不同倍数的乘法器
function createMultiplier(multiplier) {
  return function(x) {
    return x * multiplier;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
const quadruple = createMultiplier(4);

console.log(double(5)); // 10
console.log(triple(5)); // 15
console.log(quadruple(5)); // 20

// 创建不同货币的格式化器
function createCurrencyFormatter(symbol) {
  return function(amount) {
    return `${symbol}${amount.toFixed(2)}`;
  };
}

const formatUSD = createCurrencyFormatter('$');
const formatEUR = createCurrencyFormatter('€');
const formatCNY = createCurrencyFormatter('¥');

console.log(formatUSD(99.9)); // $99.90
console.log(formatEUR(99.9)); // €99.90
console.log(formatCNY(99.9)); // ¥99.90
```

**示例4：模块模式**
```javascript
const userModule = (function() {
  // 私有变量
  let users = [];
  let currentId = 0;

  // 私有方法
  function generateId() {
    return ++currentId;
  }

  // 公开接口
  return {
    addUser: function(name, email) {
      const user = {
        id: generateId(),
        name: name,
        email: email
      };
      users.push(user);
      return user;
    },

    getUser: function(id) {
      return users.find(user => user.id === id);
    },

    getAllUsers: function() {
      // 返回副本，防止外部修改
      return users.map(user => ({...user}));
    },

    deleteUser: function(id) {
      const index = users.findIndex(user => user.id === id);
      if (index !== -1) {
        users.splice(index, 1);
        return true;
      }
      return false;
    }
  };
})();

// 使用
const user1 = userModule.addUser('张三', 'zhangsan@example.com');
const user2 = userModule.addUser('李四', 'lisi@example.com');

console.log(userModule.getAllUsers());
// [
//   { id: 1, name: '张三', email: 'zhangsan@example.com' },
//   { id: 2, name: '李四', email: 'lisi@example.com' }
// ]

console.log(userModule.getUser(1));
// { id: 1, name: '张三', email: 'zhangsan@example.com' }

userModule.deleteUser(1);
console.log(userModule.getAllUsers());
// [{ id: 2, name: '李四', email: 'lisi@example.com' }]

// 私有变量和方法无法访问
// console.log(users); // ReferenceError
// console.log(generateId); // ReferenceError
```

**示例5：缓存函数结果**
```javascript
function memoize(fn) {
  const cache = {};

  return function(...args) {
    const key = JSON.stringify(args);

    if (key in cache) {
      console.log('从缓存中获取');
      return cache[key];
    }

    console.log('计算结果');
    const result = fn.apply(this, args);
    cache[key] = result;
    return result;
  };
}

// 斐波那契数列（性能测试）
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFibonacci = memoize(fibonacci);

console.time('第一次计算');
console.log(memoizedFibonacci(40)); // 计算结果 102334155
console.timeEnd('第一次计算'); // 约1000ms

console.time('第二次计算');
console.log(memoizedFibonacci(40)); // 从缓存中获取 102334155
console.timeEnd('第二次计算'); // 约0ms
```

#### 闭包的缺点

1. **内存泄漏风险**：闭包会使外部函数的变量一直保存在内存中
2. **性能问题**：作用域链变长，查找变量时间增加

**避免内存泄漏：**
```javascript
// 及时清理不需要的闭包
let closure = (function() {
  let largeData = new Array(1000000).fill('data');

  return function() {
    return largeData.length;
  };
})();

// 使用完后清理
closure = null; // 释放内存
```

### 记忆口诀

```
作用域三兄弟：全局函数块
全局到处访问，函数内部私有，块级let和const

闭包三要素：函数套函数、内访外变量、外传内函数
闭包作用：数据私有化、延长生命周期、函数工厂

循环闭包问题：let块级作用域、IIFE立即执行、函数工厂包一层
```

---

# 第四部分：事件机制进阶（完整详细）

## 一、addEventListener详解

### 基本语法⭐⭐⭐⭐⭐

```javascript
element.addEventListener(type, listener, options);
```

**参数说明：**
- **type**：事件类型（如'click'、'scroll'、'keydown'）
- **listener**：事件处理函数
- **options**：配置对象或布尔值

### listener参数的多种形式

**完整代码示例：**
```javascript
const button = document.getElementById('btn');

// 1. 函数引用
function handleClick(e) {
  console.log('clicked', e);
}
button.addEventListener('click', handleClick);

// 2. 匿名函数（this指向element）
button.addEventListener('click', function(e) {
  console.log('clicked');
  console.log(this); // button元素
});

// 3. 箭头函数（this不指向element）
button.addEventListener('click', (e) => {
  console.log('clicked');
  console.log(this); // 外层作用域的this（通常是window）
});

// 4. 对象形式（需实现handleEvent方法）
const handler = {
  count: 0,
  handleEvent(e) {
    this.count++;
    console.log('clicked', this.count, 'times');
    console.log(this); // handler对象
  }
};
button.addEventListener('click', handler);
```

---

### options参数详解⭐⭐⭐⭐⭐

options可以是一个布尔值或对象：
- 布尔值：等同于`{ capture: true/false }`
- 对象：可以包含capture、once、passive、signal四个属性

#### 1. capture - 控制事件阶段

**说明：**
- `true`：捕获阶段触发
- `false`：冒泡阶段触发（默认）

**完整代码示例：**
```html
<div id="parent">
  <button id="child">点击我</button>
</div>

<script>
const parent = document.getElementById('parent');
const child = document.getElementById('child');

// 冒泡阶段（默认）
parent.addEventListener('click', () => {
  console.log('父元素 - 冒泡');
}, false); // 或不传

child.addEventListener('click', () => {
  console.log('子元素 - 冒泡');
}, false);

// 捕获阶段
parent.addEventListener('click', () => {
  console.log('父元素 - 捕获');
}, true);

child.addEventListener('click', () => {
  console.log('子元素 - 捕获');
}, true);

// 点击子元素，输出顺序：
// 父元素 - 捕获（捕获阶段：外→内）
// 子元素 - 捕获
// 子元素 - 冒泡（目标阶段）
// 父元素 - 冒泡（冒泡阶段：内→外）
</script>
```

#### 2. once - 只触发一次

**说明：**
- 事件触发一次后自动移除监听器
- 相当于在回调中调用removeEventListener

**完整代码示例：**
```javascript
const button = document.getElementById('btn');

// 不使用once
let clickCount = 0;
function handleClick() {
  clickCount++;
  console.log('点击次数:', clickCount);

  if (clickCount >= 1) {
    button.removeEventListener('click', handleClick);
  }
}
button.addEventListener('click', handleClick);

// 使用once（更简洁）✅ 推荐
button.addEventListener('click', () => {
  console.log('只执行一次');
}, { once: true });

// 实际应用：首次交互检测
let hasInteracted = false;
document.addEventListener('click', () => {
  if (!hasInteracted) {
    hasInteracted = true;
    console.log('用户首次点击');
    // 加载更多资源、启动分析等
  }
}, { once: true });

// 实际应用：一次性提示
function showWelcome() {
  alert('欢迎首次访问！');
}
document.addEventListener('DOMContentLoaded', showWelcome, { once: true });
```

#### 3. passive - 性能优化（重要）⭐⭐⭐⭐⭐

**说明：**
- 告诉浏览器不会调用`preventDefault()`
- 浏览器可以立即执行滚动，不需要等待事件处理完成
- 显著提升滚动性能，特别是移动端

**性能问题原理：**
```javascript
// 问题场景：触摸滚动事件
element.addEventListener('touchstart', (e) => {
  // 浏览器不知道这里是否会调用preventDefault()
  // 必须等待此函数执行完才能决定是否滚动
  // 如果函数执行时间长，会导致滚动卡顿

  doSomething(); // 耗时操作

  // 如果最后调用了preventDefault，浏览器需要阻止滚动
  // e.preventDefault();
});

// 问题：即使不调用preventDefault()，浏览器也要等待确认
// 导致滚动响应延迟，用户体验差
```

**解决方案：使用passive**
```javascript
// ✅ 使用passive告诉浏览器不会阻止默认行为
element.addEventListener('touchstart', (e) => {
  // 浏览器知道不会调用preventDefault()
  // 可以立即开始滚动，不需要等待

  doSomething(); // 耗时操作

  // ⚠️ 如果调用preventDefault()会报警告
  // e.preventDefault(); // 无效且会有警告
}, { passive: true });
```

**完整代码示例：**
```javascript
// 示例1：滚动事件性能优化
window.addEventListener('scroll', () => {
  // 滚动时的处理逻辑
  const scrollTop = window.pageYOffset;
  console.log('滚动位置:', scrollTop);

  // 更新UI
  updateScrollIndicator(scrollTop);
}, { passive: true });

// 示例2：触摸事件性能优化
const slider = document.querySelector('.slider');

slider.addEventListener('touchstart', (e) => {
  // 记录触摸起点
  const touch = e.touches[0];
  startX = touch.clientX;
  startY = touch.clientY;
}, { passive: true });

slider.addEventListener('touchmove', (e) => {
  // 计算滑动距离
  const touch = e.touches[0];
  const deltaX = touch.clientX - startX;
  const deltaY = touch.clientY - startY;

  // 更新UI
  updateSliderPosition(deltaX);

  // ⚠️ 不能调用preventDefault()
  // e.preventDefault(); // 会报警告
}, { passive: true });

// 示例3：需要阻止默认行为时（必须设置passive: false）
slider.addEventListener('touchstart', (e) => {
  // 某些情况需要阻止默认行为
  if (shouldPreventDefault()) {
    e.preventDefault(); // 有效
  }
}, { passive: false }); // 显式设置为false

// 示例4：Chrome 56+的默认行为
// 以下事件在document/body/window上默认passive: true
// touchstart
// touchmove
// wheel
// mousewheel

// 如果需要阻止默认行为，必须显式设置passive: false
document.addEventListener('touchmove', (e) => {
  e.preventDefault(); // 需要设置passive: false
}, { passive: false });

// 示例5：特性检测
let passiveSupported = false;

try {
  const options = {
    get passive() {
      passiveSupported = true;
      return false;
    }
  };

  window.addEventListener('test', null, options);
  window.removeEventListener('test', null, options);
} catch (err) {
  passiveSupported = false;
}

// 根据支持情况使用
window.addEventListener('scroll', handleScroll,
  passiveSupported ? { passive: true } : false
);
```

**性能对比：**
```javascript
// ❌ 不使用passive（性能差）
window.addEventListener('scroll', () => {
  // 浏览器必须等待此函数执行完
  heavyCalculation(); // 假设耗时100ms
  // 滚动会有100ms延迟，卡顿明显
});

// ✅ 使用passive（性能好）
window.addEventListener('scroll', () => {
  // 浏览器可以立即滚动，不等待此函数
  heavyCalculation(); // 假设耗时100ms
  // 滚动流畅，计算在后台进行
}, { passive: true });
```

#### 4. signal - 批量移除监听器

**说明：**
- 使用AbortController创建信号
- 一次性移除多个监听器
- 比逐个调用removeEventListener更方便

**完整代码示例：**
```javascript
// 创建AbortController
const controller = new AbortController();
const signal = controller.signal;

// 添加多个监听器
document.addEventListener('click', handleClick, { signal });
document.addEventListener('keydown', handleKeydown, { signal });
document.addEventListener('scroll', handleScroll, { signal });
window.addEventListener('resize', handleResize, { signal });

// 一次性移除所有监听器
controller.abort();

// 实际应用1：组件卸载时清理
class Component {
  constructor() {
    this.controller = new AbortController();
    this.signal = this.controller.signal;
  }

  mount() {
    // 添加多个事件监听
    document.addEventListener('click', this.handleClick, {
      signal: this.signal
    });
    document.addEventListener('keydown', this.handleKeydown, {
      signal: this.signal
    });
    window.addEventListener('resize', this.handleResize, {
      signal: this.signal
    });
  }

  unmount() {
    // 一次性清理所有监听器
    this.controller.abort();
  }

  handleClick = () => { /* ... */ }
  handleKeydown = () => { /* ... */ }
  handleResize = () => { /* ... */ }
}

// 使用
const component = new Component();
component.mount();
// ... 使用一段时间后
component.unmount(); // 清理所有监听器

// 实际应用2：条件性移除
const modalController = new AbortController();

function openModal() {
  // 打开模态框时添加监听
  document.addEventListener('keydown', handleEscape, {
    signal: modalController.signal
  });
  document.addEventListener('click', handleOutsideClick, {
    signal: modalController.signal
  });
}

function closeModal() {
  // 关闭模态框时移除监听
  modalController.abort();
}

// 实际应用3：超时自动移除
const timeoutController = new AbortController();

button.addEventListener('click', handleClick, {
  signal: timeoutController.signal
});

// 5秒后自动移除
setTimeout(() => {
  timeoutController.abort();
  console.log('5秒后自动移除监听器');
}, 5000);
```

### 组合使用（实战示例）⭐⭐⭐⭐⭐

```javascript
// 实战1：首次交互检测（once + capture + passive）
const controller = new AbortController();

['click', 'keydown', 'scroll', 'touchstart'].forEach(type => {
  document.addEventListener(type, () => {
    console.log('首次用户交互');

    // 加载次要资源
    loadSecondaryResources();

    // 启动分析
    initAnalytics();

    // 移除所有监听器
    controller.abort();
  }, {
    once: true,          // 只触发一次
    capture: true,       // 捕获阶段（更早触发）
    passive: true,       // 性能优化
    signal: controller.signal  // 便于统一管理
  });
});

// 实战2：模态框外部点击关闭
function createModal() {
  const modal = document.querySelector('.modal');
  const controller = new AbortController();

  function open() {
    modal.classList.add('show');

    // 添加外部点击监听
    document.addEventListener('click', (e) => {
      if (!modal.contains(e.target)) {
        close();
      }
    }, {
      capture: true,  // 捕获阶段，先于内部事件
      signal: controller.signal
    });

    // ESC键关闭
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        close();
      }
    }, {
      once: true,  // 只关闭一次
      signal: controller.signal
    });
  }

  function close() {
    modal.classList.remove('show');
    controller.abort(); // 移除所有监听器
  }

  return { open, close };
}

// 实战3：滚动到底部加载更多（passive + signal）
class InfiniteScroll {
  constructor(container) {
    this.container = container;
    this.controller = new AbortController();
    this.loading = false;
  }

  start() {
    window.addEventListener('scroll', () => {
      if (this.loading) return;

      const { scrollTop, scrollHeight, clientHeight } = document.documentElement;

      // 距离底部100px时加载
      if (scrollTop + clientHeight >= scrollHeight - 100) {
        this.loadMore();
      }
    }, {
      passive: true,  // 性能优化
      signal: this.controller.signal
    });
  }

  async loadMore() {
    this.loading = true;

    // 加载数据
    const data = await fetchData();
    this.container.append(...data);

    this.loading = false;
  }

  stop() {
    this.controller.abort();
  }
}

// 实战4：防抖滚动事件（passive）
let scrollTimer = null;

window.addEventListener('scroll', () => {
  // 滚动时隐藏header
  document.body.classList.add('scrolling');

  // 清除之前的定时器
  clearTimeout(scrollTimer);

  // 500ms后显示header
  scrollTimer = setTimeout(() => {
    document.body.classList.remove('scrolling');
  }, 500);
}, { passive: true }); // 性能优化
```

### 记忆口诀

```
addEventListener四参数：capture、once、passive、signal
capture控制阶段（true捕获false冒泡）
once只触发一次（自动移除）
passive性能优化（滚动触摸必须加）
signal批量移除（AbortController）

组合使用最强大：
once捕获检测首次交互
passive优化滚动性能
signal统一管理清理
```

---

## 二、防抖和节流

### 防抖（Debounce）⭐⭐⭐⭐⭐

**概念：**
在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

**核心思想：**
等待用户停止操作一段时间后才执行。

**应用场景：**
1. 搜索框输入：用户停止输入后再搜索
2. 窗口resize：窗口调整完成后再计算布局
3. 表单验证：用户输入完成后再验证
4. 按钮提交：防止重复提交

**完整实现代码：**
```javascript
/**
 * 防抖函数
 * @param {Function} fn - 要执行的函数
 * @param {number} delay - 延迟时间（毫秒）
 * @param {boolean} immediate - 是否立即执行
 * @returns {Function} 防抖后的函数
 */
function debounce(fn, delay = 300, immediate = false) {
  let timer = null;

  return function(...args) {
    // 清除之前的定时器
    if (timer) {
      clearTimeout(timer);
    }

    if (immediate) {
      // 立即执行模式
      const callNow = !timer;
      timer = setTimeout(() => {
        timer = null;
      }, delay);

      if (callNow) {
        fn.apply(this, args);
      }
    } else {
      // 延迟执行模式
      timer = setTimeout(() => {
        fn.apply(this, args);
      }, delay);
    }
  };
}

// 使用示例1：搜索框
const searchInput = document.getElementById('search');

function handleSearch(value) {
  console.log('搜索:', value);
  // 发送搜索请求
  fetch(`/api/search?q=${value}`)
    .then(res => res.json())
    .then(data => {
      // 显示搜索结果
      console.log('搜索结果:', data);
    });
}

// 不使用防抖：每次输入都会发送请求（性能浪费）
// searchInput.addEventListener('input', (e) => {
//   handleSearch(e.target.value);
// });

// 使用防抖：停止输入500ms后才发送请求 ✅
const debouncedSearch = debounce(handleSearch, 500);
searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value);
});

// 使用示例2：窗口resize
function handleResize() {
  console.log('窗口大小:', window.innerWidth, window.innerHeight);
  // 重新计算布局
  recalculateLayout();
}

// 不使用防抖：resize时会触发几百次（性能问题）
// window.addEventListener('resize', handleResize);

// 使用防抖：调整完成后300ms才执行 ✅
const debouncedResize = debounce(handleResize, 300);
window.addEventListener('resize', debouncedResize);

// 使用示例3：表单验证
const usernameInput = document.getElementById('username');

function validateUsername(username) {
  console.log('验证用户名:', username);
  // 发送验证请求
  return fetch(`/api/validate-username?username=${username}`)
    .then(res => res.json());
}

const debouncedValidate = debounce(async function(e) {
  const username = e.target.value;

  if (username.length < 3) {
    showError('用户名至少3个字符');
    return;
  }

  const result = await validateUsername(username);

  if (result.valid) {
    showSuccess('用户名可用');
  } else {
    showError('用户名已存在');
  }
}, 500);

usernameInput.addEventListener('input', debouncedValidate);

// 使用示例4：按钮防止重复点击（立即执行模式）
const submitButton = document.getElementById('submit');

function handleSubmit() {
  console.log('提交表单');
  // 提交表单逻辑
  submitForm();
}

// 使用立即执行模式：第一次点击立即执行，之后2秒内的点击被忽略 ✅
const debouncedSubmit = debounce(handleSubmit, 2000, true);
submitButton.addEventListener('click', debouncedSubmit);
```

### 节流（Throttle）⭐⭐⭐⭐⭐

**概念：**
规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

**核心思想：**
固定时间间隔执行，降低执行频率。

**应用场景：**
1. 滚动事件：监听滚动位置
2. 鼠标移动：实时跟踪鼠标位置
3. 视频播放进度：实时更新进度
4. 拖拽：实时更新位置

**完整实现代码：**
```javascript
/**
 * 节流函数（时间戳版本）
 * @param {Function} fn - 要执行的函数
 * @param {number} delay - 间隔时间（毫秒）
 * @returns {Function} 节流后的函数
 */
function throttle(fn, delay = 300) {
  let lastTime = 0;

  return function(...args) {
    const now = Date.now();

    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

/**
 * 节流函数（定时器版本）
 * @param {Function} fn - 要执行的函数
 * @param {number} delay - 间隔时间（毫秒）
 * @returns {Function} 节流后的函数
 */
function throttleTimer(fn, delay = 300) {
  let timer = null;

  return function(...args) {
    if (timer) return;

    timer = setTimeout(() => {
      fn.apply(this, args);
      timer = null;
    }, delay);
  };
}

/**
 * 节流函数（时间戳+定时器版本，最完整）
 * @param {Function} fn - 要执行的函数
 * @param {number} delay - 间隔时间（毫秒）
 * @param {Object} options - 配置项
 * @param {boolean} options.leading - 是否在开始时执行
 * @param {boolean} options.trailing - 是否在结束时执行
 * @returns {Function} 节流后的函数
 */
function throttleComplete(fn, delay = 300, options = {}) {
  let timer = null;
  let lastTime = 0;
  const { leading = true, trailing = true } = options;

  return function(...args) {
    const now = Date.now();

    if (!lastTime && !leading) {
      lastTime = now;
    }

    const remaining = delay - (now - lastTime);

    if (remaining <= 0 || remaining > delay) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }

      lastTime = now;
      fn.apply(this, args);
    } else if (!timer && trailing) {
      timer = setTimeout(() => {
        lastTime = leading ? Date.now() : 0;
        timer = null;
        fn.apply(this, args);
      }, remaining);
    }
  };
}

// 使用示例1：滚动事件
function handleScroll() {
  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
  console.log('滚动位置:', scrollTop);

  // 更新滚动指示器
  const scrollPercent = (scrollTop / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
  document.querySelector('.scroll-indicator').style.width = scrollPercent + '%';
}

// 不使用节流：滚动时会触发几百次（性能问题）
// window.addEventListener('scroll', handleScroll);

// 使用节流：每100ms最多执行一次 ✅
const throttledScroll = throttle(handleScroll, 100);
window.addEventListener('scroll', throttledScroll);

// 使用示例2：鼠标移动
function handleMouseMove(e) {
  console.log('鼠标位置:', e.clientX, e.clientY);

  // 更新跟随元素位置
  const follower = document.querySelector('.mouse-follower');
  follower.style.left = e.clientX + 'px';
  follower.style.top = e.clientY + 'px';
}

const throttledMouseMove = throttle(handleMouseMove, 50);
document.addEventListener('mousemove', throttledMouseMove);

// 使用示例3：视频播放进度
const video = document.getElementById('video');

function updateProgress() {
  const percent = (video.currentTime / video.duration) * 100;
  console.log('播放进度:', percent + '%');

  // 更新进度条
  document.querySelector('.progress-bar').style.width = percent + '%';

  // 保存进度到服务器
  saveProgress(video.currentTime);
}

const throttledUpdateProgress = throttle(updateProgress, 1000);
video.addEventListener('timeupdate', throttledUpdateProgress);

// 使用示例4：输入框实时搜索（节流+防抖结合）
const realtimeSearchInput = document.getElementById('realtime-search');

// 节流：保证实时性（最多每300ms搜索一次）
// 防抖：避免频繁请求（停止输入500ms后最后搜索一次）
const throttledSearch = throttle(handleSearch, 300);
const debouncedSearch = debounce(handleSearch, 500);

realtimeSearchInput.addEventListener('input', (e) => {
  const value = e.target.value;
  throttledSearch(value); // 实时搜索
  debouncedSearch(value); // 最终搜索
});

// 使用示例5：无限滚动加载
let isLoading = false;

function loadMore() {
  if (isLoading) return;

  isLoading = true;
  console.log('加载更多...');

  // 模拟加载数据
  fetch('/api/load-more')
    .then(res => res.json())
    .then(data => {
      // 渲染数据
      renderData(data);
      isLoading = false;
    });
}

function checkScrollBottom() {
  const { scrollTop, scrollHeight, clientHeight } = document.documentElement;

  // 距离底部200px时加载
  if (scrollTop + clientHeight >= scrollHeight - 200) {
    loadMore();
  }
}

const throttledCheckScroll = throttle(checkScrollBottom, 200);
window.addEventListener('scroll', throttledCheckScroll);
```

### 防抖和节流对比

| 特性 | 防抖（Debounce） | 节流（Throttle） |
|------|-----------------|----------------|
| **执行时机** | 停止触发n秒后执行 | 固定时间间隔执行 |
| **执行次数** | 多次触发只执行一次 | 固定频率执行 |
| **应用场景** | 搜索框、resize、表单验证 | 滚动、鼠标移动、视频进度 |
| **响应速度** | 较慢（等待停止） | 较快（固定间隔） |
| **核心思想** | 等待用户停止操作 | 降低执行频率 |

**形象比喻：**
```
防抖：电梯等待
- 有人按电梯，等待10秒
- 10秒内又有人按，重新等待10秒
- 直到10秒内没人按，电梯才出发

节流：游戏技能冷却
- 技能释放后进入冷却时间
- 冷却期间无法再次释放
- 冷却结束后才能释放下一次
```

### 记忆口诀

```
防抖：等停止、重计时、最后一次才执行
节流：固定频率、有规律、降低执行次数

防抖场景：搜索框输入、窗口resize、表单验证、按钮提交
节流场景：滚动监听、鼠标移动、视频进度、拖拽操作

防抖像电梯（等人齐了再走）
节流像红绿灯（固定间隔放行）
```

---

# 手写代码练习

## 1. 手写防抖函数

```javascript
/**
 * 防抖函数
 * @param {Function} fn - 要执行的函数
 * @param {number} delay - 延迟时间
 * @param {boolean} immediate - 是否立即执行
 */
function debounce(fn, delay = 300, immediate = false) {
  let timer = null;

  return function(...args) {
    if (timer) {
      clearTimeout(timer);
    }

    if (immediate) {
      const callNow = !timer;
      timer = setTimeout(() => {
        timer = null;
      }, delay);

      if (callNow) {
        fn.apply(this, args);
      }
    } else {
      timer = setTimeout(() => {
        fn.apply(this, args);
      }, delay);
    }
  };
}

// 测试
const log = debounce((msg) => {
  console.log('执行:', msg);
}, 1000);

log('1'); // 不执行
log('2'); // 不执行
log('3'); // 1秒后执行，输出'执行: 3'
```

## 2. 手写节流函数

```javascript
/**
 * 节流函数
 * @param {Function} fn - 要执行的函数
 * @param {number} delay - 间隔时间
 */
function throttle(fn, delay = 300) {
  let lastTime = 0;

  return function(...args) {
    const now = Date.now();

    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 测试
const log = throttle((msg) => {
  console.log('执行:', msg);
}, 1000);

log('1'); // 立即执行，输出'执行: 1'
log('2'); // 不执行
log('3'); // 不执行
setTimeout(() => log('4'), 1500); // 1.5秒后执行，输出'执行: 4'
```

## 3. 手写闭包计数器

```javascript
/**
 * 创建计数器（闭包实现）
 */
function createCounter() {
  let count = 0; // 私有变量

  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    },
    getCount() {
      return count;
    },
    reset() {
      count = 0;
      return count;
    }
  };
}

// 测试
const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
console.log(counter.decrement()); // 1
console.log(counter.reset()); // 0

// 每个计数器都是独立的
const counter2 = createCounter();
console.log(counter2.increment()); // 1
console.log(counter.getCount()); // 0（不受counter2影响）
```

---

# 今日练习题

## CSS部分

### 题目1：display三大值的区别是什么？
**答案：**
- **inline**：不独占一行，不能设置宽高，只能设置水平方向的margin和padding
- **block**：独占一行，可以设置宽高，可以设置所有方向的margin和padding
- **inline-block**：不独占一行，可以设置宽高，可以设置所有方向的margin和padding

### 题目2：display:none、visibility:hidden、opacity:0的区别？
**答案：**
- **display:none**：不占据空间，不可交互，触发重排+重绘
- **visibility:hidden**：占据空间，不可交互，仅触发重绘
- **opacity:0**：占据空间，可交互，可能触发GPU合成

---

## Vue部分

### 题目1：Vue3组件如何实现父子通信？请写出完整代码。
**答案：**
```vue
<!-- 父组件 -->
<template>
  <Child :message="msg" @update="handleUpdate" />
</template>

<script setup>
import { ref } from 'vue';
import Child from './Child.vue';

const msg = ref('Hello');

const handleUpdate = (data) => {
  console.log('收到子组件数据:', data);
};
</script>

<!-- 子组件 -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="sendToParent">发送</button>
  </div>
</template>

<script setup>
const props = defineProps({
  message: String
});

const emit = defineEmits(['update']);

const sendToParent = () => {
  emit('update', 'data from child');
};
</script>
```

### 题目2：Vue生命周期中，哪个阶段适合操作DOM？为什么？
**答案：**
- **mounted（Vue2）/ onMounted（Vue3）**
- **原因**：此时组件已经挂载到DOM，可以访问真实DOM元素和$refs
- **用途**：DOM操作、第三方库初始化、获取元素尺寸等

---

## JavaScript部分

### 题目1：解释this的五种绑定规则，并举例说明优先级。
**答案：**
1. **默认绑定**：独立函数调用，this指向window（非严格）或undefined（严格）
2. **隐式绑定**：对象方法调用，this指向调用对象
3. **显式绑定**：call/apply/bind，this指向指定对象
4. **new绑定**：构造函数调用，this指向新实例
5. **箭头函数**：继承外层作用域的this

**优先级：new > 显式绑定 > 隐式绑定 > 默认绑定**

### 题目2：什么是闭包？请手写一个闭包计数器。
**答案：**
闭包是指函数能够访问其定义时所在作用域的变量，即使函数在其他地方执行。

```javascript
function createCounter() {
  let count = 0;

  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
```

---

## 事件机制部分

### 题目1：addEventListener的passive选项有什么作用？为什么能提升性能？
**答案：**
- **作用**：告诉浏览器不会调用preventDefault()，浏览器可以立即执行滚动，不需要等待事件处理完成
- **原理**：浏览器通常需要等待事件处理函数执行完才能确认是否需要阻止默认行为，如果设置passive: true，浏览器知道不会阻止，可以立即滚动
- **应用**：滚动、触摸等高频事件，能显著提升移动端滚动性能

### 题目2：手写一个防抖函数。
**答案：**
```javascript
function debounce(fn, delay = 300) {
  let timer = null;

  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用
const search = debounce((value) => {
  console.log('搜索:', value);
}, 500);

search('a'); // 不执行
search('ab'); // 不执行
search('abc'); // 500ms后执行
```

---

# 今日总结

## 今天学习的核心内容

### CSS布局
1. **display三大值**：inline（行内）、block（块级）、inline-block（行内块）
2. **元素隐藏**：display:none、visibility:hidden、opacity:0及其区别

### Vue进阶
1. **组件通信**：props/emit（父子）、provide/inject（跨级）、v-model（双向绑定）
2. **生命周期**：创建、挂载、更新、销毁四大阶段，Vue2与Vue3对照

### JavaScript核心
1. **this指向**：五种绑定规则及优先级
2. **作用域**：全局、函数、块级三种作用域
3. **闭包**：定义、作用、应用场景及完整实现

### 事件机制
1. **addEventListener详解**：capture、once、passive、signal四大参数
2. **防抖节流**：概念、应用场景、完整实现代码

## 必须记住的核心口诀

```
CSS：inline行内block块级、inline-block最灵活
Vue：父传子props、子传父emit、跨级provide inject
JS：新显隐默箭、this指向五规则、闭包三要素
事件：capture once passive signal、防抖节流要区分
```

## 明天学习预告

- HTTP协议与网络请求
- 浏览器工作原理
- 性能优化方案
- 前端工程化基础

**加油！继续努力！💪**
