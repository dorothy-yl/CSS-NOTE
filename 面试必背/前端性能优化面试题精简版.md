# 前端性能优化面试题精简版 ⭐⭐⭐⭐⭐

> 💡 **重要程度**: 高频必考 | 📌 **学习时长**: 2-3小时
> 🔥 **热度指数**: ⭐⭐⭐⭐⭐ (几乎每个面试都会问)

---

## 🎯 核心记忆口诀

### 性能优化六大方向
```
减少请求、减小体积、提高速度
缓存利用、异步加载、体验优化
```

### 性能指标口诀
```
FCP首次绘制、LCP最大内容、FID首次交互
CLS布局偏移、TTFB首字节
```

### 图片优化口诀
```
小图Base64、大图懒加载
WebP格式、雪碧图合并
响应式图片、CDN加速
```

---

## 📋 快速导航

| 章节 | 重要级别 | 核心内容 | 预计阅读时间 |
|------|---------|---------|------------|
| [一、资源加载优化](#一资源加载优化) | ⭐⭐⭐⭐⭐ | 减少请求、压缩资源 | 20分钟 |
| [二、渲染性能优化](#二渲染性能优化) | ⭐⭐⭐⭐⭐ | 重排重绘、CSS优化 | 20分钟 |
| [三、JavaScript优化](#三javascript优化) | ⭐⭐⭐⭐⭐ | 防抖节流、代码分割 | 20分钟 |
| [四、网络优化](#四网络优化) | ⭐⭐⭐⭐⭐ | CDN、HTTP缓存 | 15分钟 |
| [五、图片优化](#五图片优化) | ⭐⭐⭐⭐⭐ | 懒加载、格式选择 | 15分钟 |
| [六、Vue/React优化](#六vuereact优化) | ⭐⭐⭐⭐⭐ | 组件优化、虚拟滚动 | 20分钟 |
| [七、Webpack/Vite优化](#七webpackvite优化) | ⭐⭐⭐⭐⭐ | 构建优化、打包优化 | 25分钟 |
| [八、性能监控](#八性能监控) | ⭐⭐⭐⭐ | 性能指标、监控工具 | 15分钟 |
| [九、面试答题模板](#九面试答题模板) | ⭐⭐⭐⭐⭐ | 答题技巧 | 10分钟 |

---

# 一、资源加载优化

## 1. 减少HTTP请求 ⭐⭐⭐⭐⭐

**口诀：合并压缩、雪碧图、内联小资源**

### 1) CSS雪碧图（Sprite）
```css
/* 将多个小图标合并成一张大图 */
.icon-home {
  background: url('sprites.png') 0 0;
  width: 20px;
  height: 20px;
}

.icon-user {
  background: url('sprites.png') -20px 0;
  width: 20px;
  height: 20px;
}
```

**优点：** 10个小图标从10个请求变成1个请求
**适用：** 小图标、固定UI元素

### 2) 小图片Base64内联
```css
/* 小于10KB的图片转为Base64 */
.logo {
  background: url('data:image/png;base64,iVBORw0KG...');
}
```

**优点：** 减少请求，首屏更快
**缺点：** 增大CSS体积，不能缓存
**建议：** 只对<10KB的图片使用

### 3) 合并CSS/JS文件
```javascript
// ❌ 不好：多个请求
<link rel="stylesheet" href="a.css">
<link rel="stylesheet" href="b.css">
<link rel="stylesheet" href="c.css">

// ✅ 好：合并为一个
<link rel="stylesheet" href="bundle.css">
```

---

## 2. 资源压缩 ⭐⭐⭐⭐⭐

**口诀：Gzip压缩、代码混淆、Tree Shaking**

### 1) Gzip/Brotli压缩
```javascript
// 服务器端开启Gzip
// Nginx配置
gzip on;
gzip_types text/css application/javascript image/svg+xml;
gzip_min_length 1024;  // 大于1KB才压缩
gzip_comp_level 6;     // 压缩级别1-9

// 效果：文件体积减少70-90%
```

**对比：**
- 原始大小：100KB
- Gzip后：20-30KB
- Brotli后：15-25KB（更优）

### 2) 代码压缩（Minify）
```javascript
// 压缩前
function calculateTotal(price, quantity) {
  const tax = 0.1;
  return price * quantity * (1 + tax);
}

// 压缩后
function calculateTotal(e,t){return e*t*1.1}
```

**工具：** Webpack、Vite、Terser

### 3) Tree Shaking（摇树优化）
```javascript
// utils.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }
export function multiply(a, b) { return a * b; }

// main.js
import { add } from './utils.js';  // 只导入add

// 打包后：subtract和multiply不会被打包
```

**要求：** 使用ES6 Module，不要用CommonJS

---

## 3. 按需加载 ⭐⭐⭐⭐⭐

**口诀：懒加载、动态导入、路由分割**

### 1) 路由懒加载
```javascript
// ❌ 不好：所有页面一次加载
import Home from './Home.vue';
import About from './About.vue';

// ✅ 好：按需加载
const Home = () => import('./Home.vue');
const About = () => import('./About.vue');

const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About }
];
```

**效果：** 首屏体积从1MB降到300KB

### 2) 组件懒加载
```vue
<!-- 异步组件 -->
<script setup>
import { defineAsyncComponent } from 'vue';

// 大组件懒加载
const HeavyChart = defineAsyncComponent(() =>
  import('./HeavyChart.vue')
);
</script>

<template>
  <HeavyChart v-if="showChart" />
</template>
```

### 3) 第三方库按需引入
```javascript
// ❌ 不好：引入整个lodash（70KB）
import _ from 'lodash';
_.debounce(fn, 300);

// ✅ 好：只引入需要的（2KB）
import debounce from 'lodash/debounce';
debounce(fn, 300);

// Element Plus按需引入
import { ElButton, ElInput } from 'element-plus';
```

**记忆口诀：**
```
资源加载三大招：减少请求、压缩体积、按需加载
合并雪碧Base64、Gzip压缩Tree Shaking、懒加载动态导入
```

---

# 二、渲染性能优化

## 1. 避免重排（Reflow）和重绘（Repaint）⭐⭐⭐⭐⭐

**口诀：读写分离、批量修改、脱离文档流**

### 重排vs重绘对比

| 操作 | 重排(Reflow) | 重绘(Repaint) | 性能影响 |
|------|-------------|--------------|---------|
| 修改width/height | ✅ | ✅ | 最慢 |
| 修改color/background | ❌ | ✅ | 较快 |
| 修改transform/opacity | ❌ | ❌ | 最快 |

### 1) 批量修改DOM
```javascript
// ❌ 不好：触发3次重排
element.style.width = '100px';
element.style.height = '100px';
element.style.margin = '10px';

// ✅ 好：只触发1次重排
element.style.cssText = 'width:100px;height:100px;margin:10px';

// ✅ 更好：使用class
element.classList.add('optimized-style');
```

### 2) 读写分离
```javascript
// ❌ 不好：读写交替，触发多次重排
div1.style.height = div1.offsetHeight + 10 + 'px'; // 写-读-写
div2.style.height = div2.offsetHeight + 10 + 'px';

// ✅ 好：先读后写
const height1 = div1.offsetHeight;  // 读
const height2 = div2.offsetHeight;  // 读
div1.style.height = height1 + 10 + 'px'; // 写
div2.style.height = height2 + 10 + 'px'; // 写
```

### 3) 脱离文档流
```javascript
// 大量DOM操作时，先脱离文档流
const container = document.getElementById('container');

// 方式1：display: none
container.style.display = 'none';
// ... 进行100次DOM操作
container.style.display = 'block';  // 只触发1次重排

// 方式2：DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);
}
ul.appendChild(fragment);  // 只触发1次重排
```

### 4) 使用transform代替top/left
```css
/* ❌ 不好：触发重排 */
.box {
  position: absolute;
  left: 100px;
  transition: left 0.3s;
}
.box:hover {
  left: 200px;
}

/* ✅ 好：只触发合成，不重排 */
.box {
  transform: translateX(0);
  transition: transform 0.3s;
}
.box:hover {
  transform: translateX(100px);
}
```

---

## 2. CSS优化 ⭐⭐⭐⭐⭐

**口诀：选择器简化、避免@import、关键CSS内联**

### 1) 简化CSS选择器
```css
/* ❌ 不好：选择器过深 */
.header .nav .menu .item .link .icon {
  color: red;
}

/* ✅ 好：扁平化 */
.nav-link-icon {
  color: red;
}
```

**原因：** CSS选择器从右向左匹配，越短越快

### 2) 避免使用@import
```css
/* ❌ 不好：串行加载 */
@import url('a.css');
@import url('b.css');

/* ✅ 好：并行加载 */
<link rel="stylesheet" href="a.css">
<link rel="stylesheet" href="b.css">
```

### 3) 关键CSS内联
```html
<!-- 首屏关键CSS直接写在<head>里 -->
<head>
  <style>
    /* 关键CSS：首屏必需的样式 */
    .header { height: 60px; background: #fff; }
    .hero { height: 400px; }
  </style>

  <!-- 非关键CSS异步加载 -->
  <link rel="preload" href="main.css" as="style" onload="this.rel='stylesheet'">
</head>
```

**记忆口诀：**
```
渲染优化记四点：避免重排、批量修改、transform动画、CSS简化
读写分离脱文档、transform代替left、关键CSS内联
```

---

# 三、JavaScript优化

## 1. 防抖和节流 ⭐⭐⭐⭐⭐

**口诀：防抖等停止、节流固定间隔**

### 防抖（Debounce）
```javascript
// 应用场景：搜索框输入、窗口resize
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 使用
const search = debounce((keyword) => {
  console.log('搜索:', keyword);
}, 300);

input.addEventListener('input', (e) => search(e.target.value));
```

### 节流（Throttle）
```javascript
// 应用场景：滚动事件、鼠标移动
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 使用
const handleScroll = throttle(() => {
  console.log('滚动位置:', window.scrollY);
}, 200);

window.addEventListener('scroll', handleScroll);
```

### 对比表格

| 特性 | 防抖 | 节流 |
|------|------|------|
| **执行时机** | 停止触发后执行 | 固定间隔执行 |
| **执行次数** | 1次 | 多次 |
| **适用场景** | 搜索、resize | 滚动、mousemove |
| **实际例子** | 输入停止300ms后搜索 | 滚动时每200ms执行一次 |

---

## 2. 长列表优化 ⭐⭐⭐⭐⭐

**口诀：虚拟滚动、分页加载、时间分片**

### 1) 虚拟滚动（Virtual Scroll）
```vue
<!-- 只渲染可见区域的元素 -->
<template>
  <div class="virtual-list" @scroll="handleScroll" ref="container">
    <div class="phantom" :style="{ height: totalHeight + 'px' }"></div>
    <div class="content" :style="{ transform: `translateY(${offset}px)` }">
      <div v-for="item in visibleData" :key="item.id" class="item">
        {{ item.text }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';

const data = ref(Array.from({ length: 10000 }, (_, i) => ({
  id: i,
  text: `Item ${i}`
})));

const itemHeight = 50;      // 每项高度
const visibleCount = 20;    // 可见数量
const scrollTop = ref(0);

const startIndex = computed(() => Math.floor(scrollTop.value / itemHeight));
const endIndex = computed(() => startIndex.value + visibleCount);
const visibleData = computed(() => data.value.slice(startIndex.value, endIndex.value));
const offset = computed(() => startIndex.value * itemHeight);
const totalHeight = computed(() => data.value.length * itemHeight);

function handleScroll(e) {
  scrollTop.value = e.target.scrollTop;
}
</script>
```

**效果：** 10000条数据，只渲染20个DOM节点

### 2) 时间分片（Time Slicing）
```javascript
// 大量数据分批渲染
function timeSlice(data, batchSize = 100) {
  let index = 0;

  function render() {
    const batch = data.slice(index, index + batchSize);
    batch.forEach(item => {
      const div = document.createElement('div');
      div.textContent = item;
      container.appendChild(div);
    });

    index += batchSize;

    if (index < data.length) {
      requestAnimationFrame(render);  // 下一帧继续
    }
  }

  render();
}

// 使用
const data = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);
timeSlice(data, 100);  // 每次渲染100条
```

---

## 3. Web Worker ⭐⭐⭐⭐

**口诀：计算密集、后台处理、不阻塞UI**

```javascript
// worker.js
self.addEventListener('message', (e) => {
  const { data } = e;

  // 耗时计算
  const result = heavyComputation(data);

  // 返回结果
  self.postMessage(result);
});

function heavyComputation(data) {
  // 复杂计算逻辑
  let sum = 0;
  for (let i = 0; i < 1000000000; i++) {
    sum += i;
  }
  return sum;
}

// main.js
const worker = new Worker('worker.js');

worker.postMessage({ data: [1, 2, 3] });

worker.addEventListener('message', (e) => {
  console.log('计算结果:', e.data);
});
```

**适用场景：**
- 大数据处理
- 图像处理
- 复杂计算
- 数据加密/解密

**记忆口诀：**
```
JS优化三板斧：防抖节流、虚拟滚动、Web Worker
防抖等停止、节流固定间隔、虚拟滚动只渲染可见
```

---

# 四、网络优化

## 1. CDN加速 ⭐⭐⭐⭐⭐

**口诀：就近访问、并行下载、减轻服务器**

```html
<!-- 使用CDN -->
<script src="https://cdn.jsdelivr.net/npm/vue@3.3.4/dist/vue.global.js"></script>
<link href="https://cdn.jsdelivr.net/npm/element-plus@2.3.0/dist/index.css">

<!-- 多个CDN域名，突破浏览器并发限制 -->
<link href="https://cdn1.example.com/a.css">
<link href="https://cdn2.example.com/b.css">
<script src="https://cdn3.example.com/c.js"></script>
```

**优点：**
- 就近访问，延迟低
- 分散流量，减轻源站压力
- 多域名并行下载（浏览器限制：同域名6个并发）

---

## 2. HTTP缓存策略 ⭐⭐⭐⭐⭐

**口诀：强缓存优先、协商缓存兜底**

### 缓存配置最佳实践

```javascript
// HTML：协商缓存（保证获取最新）
app.get('/*.html', (req, res) => {
  res.set({
    'Cache-Control': 'no-cache',
    'ETag': calculateETag(content)
  });
});

// CSS/JS（带hash）：强缓存1年
// app.abc123.js
app.get('/static/*.js', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=31536000, immutable'
  });
});

// 图片：强缓存30天
app.get('/images/*', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=2592000'
  });
});

// API：不缓存
app.get('/api/*', (req, res) => {
  res.set({
    'Cache-Control': 'no-store'
  });
});
```

---

## 3. DNS预解析和预连接 ⭐⭐⭐⭐

```html
<!-- DNS预解析 -->
<link rel="dns-prefetch" href="https://api.example.com">

<!-- 预连接（DNS + TCP + TLS） -->
<link rel="preconnect" href="https://cdn.example.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="main.css" as="style">
<link rel="preload" href="main.js" as="script">

<!-- 预获取下一页资源 -->
<link rel="prefetch" href="/page2.html">
```

### 对比表格

| 指令 | 作用 | 时机 | 适用场景 |
|------|------|------|----------|
| dns-prefetch | DNS解析 | 空闲时 | 第三方域名 |
| preconnect | DNS+TCP+TLS | 空闲时 | 重要资源域名 |
| preload | 提前下载 | 立即 | 关键资源 |
| prefetch | 提前缓存 | 空闲时 | 下一页资源 |

**记忆口诀：**
```
网络优化四法宝：CDN加速、HTTP缓存、资源预加载
强缓存一年、协商缓存验证、preload关键资源
```

---

# 五、图片优化

## 1. 图片格式选择 ⭐⭐⭐⭐⭐

**口诀：照片JPEG、图标PNG、动画GIF改WebP**

### 格式对比表

| 格式 | 特点 | 适用场景 | 体积 | 浏览器支持 |
|------|------|----------|------|-----------|
| **JPEG** | 有损压缩 | 照片、复杂图像 | 小 | ✅ 所有 |
| **PNG** | 无损压缩、透明 | Logo、图标 | 大 | ✅ 所有 |
| **WebP** | 有损/无损、透明 | 替代JPEG/PNG | 最小 | ✅ 现代浏览器 |
| **SVG** | 矢量图 | 图标、简单图形 | 极小 | ✅ 所有 |
| **AVIF** | 新一代格式 | 照片 | 极小 | ⚠️ 部分支持 |

### WebP兼容方案
```html
<picture>
  <source srcset="image.avif" type="image/avif">
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="fallback">
</picture>
```

---

## 2. 图片懒加载 ⭐⭐⭐⭐⭐

**口诀：首屏优先、滚动到才加载**

### 原生懒加载
```html
<!-- 简单方式：loading="lazy" -->
<img src="image.jpg" loading="lazy" alt="图片">
```

### IntersectionObserver懒加载
```javascript
// 更精细的控制
const images = document.querySelectorAll('img[data-src]');

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;  // 加载真实图片
      img.removeAttribute('data-src');
      observer.unobserve(img);
    }
  });
}, {
  rootMargin: '50px'  // 提前50px加载
});

images.forEach(img => observer.observe(img));
```

```html
<!-- HTML -->
<img data-src="real-image.jpg" src="placeholder.jpg" alt="图片">
```

---

## 3. 响应式图片 ⭐⭐⭐⭐

**口诀：不同尺寸、不同分辨率、按需加载**

```html
<!-- 根据屏幕宽度选择图片 -->
<img
  srcset="
    small.jpg 480w,
    medium.jpg 800w,
    large.jpg 1200w
  "
  sizes="
    (max-width: 480px) 100vw,
    (max-width: 800px) 50vw,
    33vw
  "
  src="medium.jpg"
  alt="响应式图片"
>
```

**记忆口诀：**
```
图片优化五要点：格式选择、懒加载、响应式、压缩、CDN
照片JPEG、图标PNG、WebP最优、懒加载提速
```

---

# 六、Vue/React优化

## 1. Vue性能优化 ⭐⭐⭐⭐⭐

### 1) v-if vs v-show
```vue
<!-- 频繁切换用v-show -->
<div v-show="isVisible">内容</div>

<!-- 很少切换用v-if -->
<div v-if="isLogin">用户信息</div>
```

### 2) 列表使用key
```vue
<!-- ❌ 不好：用index作key -->
<li v-for="(item, index) in list" :key="index">

<!-- ✅ 好：用唯一id -->
<li v-for="item in list" :key="item.id">
```

### 3) computed缓存
```vue
<script setup>
// ✅ 好：使用computed，有缓存
const total = computed(() => {
  return cart.value.reduce((sum, item) => sum + item.price, 0);
});

// ❌ 不好：使用方法，每次都计算
function getTotal() {
  return cart.value.reduce((sum, item) => sum + item.price, 0);
}
</script>
```

### 4) keep-alive缓存组件
```vue
<template>
  <keep-alive :include="['UserList', 'OrderList']">
    <router-view />
  </keep-alive>
</template>
```

---

## 2. React性能优化 ⭐⭐⭐⭐⭐

### 1) React.memo
```javascript
// 防止不必要的重新渲染
const Child = React.memo(({ name }) => {
  console.log('Child渲染');
  return <div>{name}</div>;
});
```

### 2) useMemo和useCallback
```javascript
// useMemo - 缓存计算结果
const total = useMemo(() => {
  return cart.reduce((sum, item) => sum + item.price, 0);
}, [cart]);

// useCallback - 缓存函数
const handleClick = useCallback(() => {
  console.log('点击');
}, []);
```

### 3) 虚拟滚动
```javascript
// 使用react-window
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={500}
  itemCount={10000}
  itemSize={50}
  width="100%"
>
  {({ index, style }) => (
    <div style={style}>Item {index}</div>
  )}
</FixedSizeList>
```

**记忆口诀：**
```
Vue优化：v-show频繁切换、key用id、computed缓存、keep-alive复用
React优化：memo防重渲、useMemo缓存值、useCallback缓存函数
```

---

# 七、Webpack/Vite优化

## 1. Webpack性能优化 ⭐⭐⭐⭐⭐

**口诀：缓存分割、按需懒加载、并行压缩**

### 1) 缓存优化（Cache）

#### contenthash文件指纹
```javascript
// webpack.config.js
module.exports = {
  output: {
    filename: '[name].[contenthash:8].js',  // 内容变化才改变hash
    chunkFilename: '[name].[contenthash:8].chunk.js'
  }
};
```

**效果：** 文件内容不变，hash不变，浏览器直接用缓存

#### cache持久化缓存
```javascript
// webpack.config.js
module.exports = {
  cache: {
    type: 'filesystem',  // 文件系统缓存
    buildDependencies: {
      config: [__filename]  // 配置变化时重新构建
    }
  }
};
```

**效果：** 二次构建速度提升90%（30s → 3s）

---

### 2) 代码分割（Code Splitting）⭐⭐⭐⭐⭐

#### splitChunks提取公共代码
```javascript
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // 提取第三方库
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        },
        // 提取公共代码
        common: {
          minChunks: 2,
          name: 'common',
          priority: 5,
          reuseExistingChunk: true
        }
      }
    }
  }
};
```

**效果：**
- main.js：100KB → 30KB
- vendor.js：70KB（可长期缓存）
- common.js：10KB

#### 动态导入（Dynamic Import）
```javascript
// ❌ 不好：打包到一起
import HeavyComponent from './HeavyComponent.vue';

// ✅ 好：按需加载
const HeavyComponent = () => import(
  /* webpackChunkName: "heavy" */
  './HeavyComponent.vue'
);
```

---

### 3) 构建速度优化 ⭐⭐⭐⭐⭐

#### 多进程构建
```javascript
// webpack.config.js
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({
        parallel: true,  // 多进程并行压缩
        terserOptions: {
          compress: {
            drop_console: true  // 删除console
          }
        }
      })
    ]
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'thread-loader',  // 多进程loader
            options: { workers: 4 }
          },
          'babel-loader'
        ]
      }
    ]
  }
};
```

**效果：** 构建时间减少40-60%

#### 缩小构建范围
```javascript
// webpack.config.js
module.exports = {
  resolve: {
    // 指定扩展名，减少查找
    extensions: ['.js', '.vue', '.json'],
    // 别名，避免层层查找
    alias: {
      '@': path.resolve(__dirname, 'src'),
      'vue$': 'vue/dist/vue.runtime.esm.js'
    },
    // 指定模块查找目录
    modules: [path.resolve(__dirname, 'node_modules')]
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve(__dirname, 'src'),  // 只处理src
        exclude: /node_modules/,  // 排除node_modules
        use: 'babel-loader'
      }
    ]
  }
};
```

#### noParse跳过解析
```javascript
// webpack.config.js
module.exports = {
  module: {
    noParse: /jquery|lodash/,  // 不解析这些库（已经打包好）
  }
};
```

---

### 4) Tree Shaking ⭐⭐⭐⭐⭐

```javascript
// webpack.config.js
module.exports = {
  mode: 'production',  // 生产模式自动开启
  optimization: {
    usedExports: true,  // 标记未使用的导出
    sideEffects: false  // 开启副作用检测
  }
};

// package.json
{
  "sideEffects": [
    "*.css",
    "*.scss"
  ]
}
```

**要求：**
- 使用ES6 Module（import/export）
- 不要用CommonJS（require）

---

### 5) DLL动态链接库（已过时，了解即可）

```javascript
// webpack.dll.config.js
const webpack = require('webpack');

module.exports = {
  entry: {
    vendor: ['vue', 'vue-router', 'vuex']
  },
  output: {
    filename: '[name].dll.js',
    library: '[name]_library'
  },
  plugins: [
    new webpack.DllPlugin({
      name: '[name]_library',
      path: path.join(__dirname, '[name]-manifest.json')
    })
  ]
};
```

**注意：** Webpack 5的持久化缓存已替代DLL，不推荐使用

---

## 2. Vite性能优化 ⭐⭐⭐⭐⭐

**口诀：预构建、按需编译、Rollup打包**

### 1) Vite vs Webpack对比

| 对比项 | Webpack | Vite |
|--------|---------|------|
| **开发模式** | Bundle（打包） | ESM（原生模块） |
| **冷启动** | 慢（20-60s） | 快（1-3s） |
| **热更新** | 慢（需重新打包） | 快（只编译改动文件） |
| **生产构建** | Webpack | Rollup |
| **适用场景** | 大型项目、复杂配置 | 现代浏览器、快速开发 |

### Vite快的原因
1. **开发时**：不打包，利用浏览器原生ESM
2. **按需编译**：只编译当前页面需要的模块
3. **预构建**：依赖预构建（esbuild，比Webpack快10-100倍）

---

### 2) Vite优化配置

#### 依赖预构建优化
```javascript
// vite.config.js
export default {
  optimizeDeps: {
    // 强制预构建的依赖
    include: [
      'vue',
      'vue-router',
      'pinia',
      'axios',
      'lodash-es'
    ],
    // 排除预构建
    exclude: ['your-local-package']
  }
};
```

#### 构建优化
```javascript
// vite.config.js
export default {
  build: {
    // 代码分割
    rollupOptions: {
      output: {
        manualChunks: {
          // 提取Vue全家桶
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          // 提取UI库
          'ui-vendor': ['element-plus'],
          // 提取工具库
          'utils': ['axios', 'dayjs', 'lodash-es']
        }
      }
    },
    // 压缩
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    },
    // chunk大小警告
    chunkSizeWarningLimit: 1000,
    // 小于4KB的图片转base64
    assetsInlineLimit: 4096
  }
};
```

#### 开发服务器优化
```javascript
// vite.config.js
export default {
  server: {
    // 预热常用文件
    warmup: {
      clientFiles: [
        './src/components/**/*.vue',
        './src/views/**/*.vue'
      ]
    },
    // 文件系统缓存
    fs: {
      cachedChecks: true
    }
  }
};
```

---

### 3) Vite插件优化

#### 自动导入
```javascript
// vite.config.js
import AutoImport from 'unplugin-auto-import/vite';
import Components from 'unplugin-vue-components/vite';
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers';

export default {
  plugins: [
    // 自动导入Vue API
    AutoImport({
      imports: ['vue', 'vue-router', 'pinia'],
      resolvers: [ElementPlusResolver()]
    }),
    // 自动导入组件
    Components({
      resolvers: [ElementPlusResolver()]
    })
  ]
};
```

**效果：** 不需要手动import，自动按需引入

#### 图片优化插件
```javascript
// vite.config.js
import { ViteImageOptimizer } from 'vite-plugin-image-optimizer';

export default {
  plugins: [
    ViteImageOptimizer({
      // 图片压缩
      png: { quality: 80 },
      jpeg: { quality: 80 },
      webp: { quality: 80 }
    })
  ]
};
```

#### gzip压缩插件
```javascript
// vite.config.js
import viteCompression from 'vite-plugin-compression';

export default {
  plugins: [
    viteCompression({
      algorithm: 'gzip',
      ext: '.gz',
      threshold: 10240  // 大于10KB才压缩
    })
  ]
};
```

---

### 4) Vite常见问题优化

#### 问题1：首次启动慢
**原因：** 依赖预构建耗时

**解决：**
```javascript
// vite.config.js
export default {
  optimizeDeps: {
    // 强制预构建，避免二次预构建
    include: ['vue', 'vue-router', 'pinia', 'element-plus']
  }
};
```

#### 问题2：热更新慢
**原因：** 大量文件监听

**解决：**
```javascript
// vite.config.js
export default {
  server: {
    watch: {
      // 忽略不需要监听的文件
      ignored: ['**/node_modules/**', '**/.git/**']
    }
  }
};
```

#### 问题3：打包体积大
**原因：** 第三方库体积大

**解决：**
```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      external: ['vue', 'element-plus'],  // 外部化
      output: {
        globals: {
          vue: 'Vue',
          'element-plus': 'ElementPlus'
        }
      }
    }
  }
};

// index.html引入CDN
<script src="https://cdn.jsdelivr.net/npm/vue@3.3.4"></script>
```

---

## 3. Webpack vs Vite选择建议 ⭐⭐⭐⭐

### 选择Webpack的场景
- ✅ 大型项目（>1000个模块）
- ✅ 需要兼容IE11
- ✅ 复杂的构建需求
- ✅ 成熟的生态和插件

### 选择Vite的场景
- ✅ 新项目（推荐）
- ✅ Vue3/React项目
- ✅ 现代浏览器（ES2015+）
- ✅ 快速开发体验

---

## 4. 面试高频题 ⭐⭐⭐⭐⭐

### Q1: Webpack构建速度优化？

**答案（5个方面）：**

1. **缓存**
   - cache: 'filesystem'持久化缓存
   - babel-loader的cacheDirectory

2. **多进程**
   - thread-loader多进程loader
   - TerserPlugin并行压缩

3. **缩小范围**
   - include/exclude精确匹配
   - resolve.modules指定查找目录

4. **DLL预编译**（已过时）
   - 第三方库预编译
   - Webpack 5用cache替代

5. **按需加载**
   - 动态import
   - splitChunks代码分割

---

### Q2: Vite为什么比Webpack快？

**答案（3个核心原因）：**

1. **开发时不打包**
   - Webpack：所有模块打包成bundle
   - Vite：利用浏览器原生ESM

2. **按需编译**
   - Webpack：启动时全量编译
   - Vite：只编译当前页面需要的

3. **esbuild预构建**
   - Webpack：JavaScript编译（慢）
   - Vite：esbuild编译（Go语言，快10-100倍）

**对比：**
- Webpack冷启动：30-60s
- Vite冷启动：1-3s

---

### Q3: Tree Shaking原理？

**答案：**

**原理：** 基于ES6 Module的静态分析，删除未使用的代码

**工作流程：**
1. **标记阶段**：标记所有使用的导出
2. **清除阶段**：删除未使用的导出

**要求：**
- 使用ES6 Module（import/export）
- 不要用CommonJS（require/module.exports）
- package.json设置sideEffects

**效果：** lodash从70KB降到5KB（只用了1个函数）

---

### Q4: splitChunks如何配置？

**答案（最佳实践）：**

```javascript
splitChunks: {
  chunks: 'all',
  cacheGroups: {
    // 第三方库
    vendor: {
      test: /[\\/]node_modules[\\/]/,
      name: 'vendors',
      priority: 10
    },
    // 公共代码
    common: {
      minChunks: 2,
      name: 'common',
      priority: 5
    }
  }
}
```

**效果：**
- 第三方库单独打包，可长期缓存
- 公共代码提取，避免重复打包
- 首屏加载更快

---

**记忆口诀：**
```
Webpack优化：缓存分割、多进程并行、缩小范围
Vite优化：预构建依赖、代码分割、插件自动化
Vite快三点：不打包、按需编译、esbuild预构建
```

---

# 八、性能监控

## 1. 性能指标 ⭐⭐⭐⭐⭐

**口诀：FCP首绘、LCP最大、FID交互、CLS偏移、TTFB首字节**

### 核心Web指标（Core Web Vitals）

| 指标 | 含义 | 目标值 | 影响因素 |
|------|------|--------|----------|
| **FCP** | 首次内容绘制 | <1.8s | HTML、CSS加载速度 |
| **LCP** | 最大内容绘制 | <2.5s | 图片、视频加载 |
| **FID** | 首次输入延迟 | <100ms | JavaScript执行 |
| **CLS** | 累积布局偏移 | <0.1 | 动态内容加载 |
| **TTFB** | 首字节时间 | <600ms | 服务器响应速度 |

### 使用Performance API监控
```javascript
// 1. 获取性能指标
window.addEventListener('load', () => {
  const perfData = performance.timing;
  const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
  const domReadyTime = perfData.domContentLoadedEventEnd - perfData.navigationStart;
  const ttfb = perfData.responseStart - perfData.navigationStart;

  console.log('页面加载时间:', pageLoadTime);
  console.log('DOM解析时间:', domReadyTime);
  console.log('首字节时间:', ttfb);
});

// 2. 使用Web Vitals库
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

getCLS(console.log);
getFID(console.log);
getFCP(console.log);
getLCP(console.log);
getTTFB(console.log);
```

---

## 2. 性能监控工具 ⭐⭐⭐⭐

### 1) Chrome DevTools
```
1. Performance面板：录制性能
2. Lighthouse：性能评分
3. Network面板：网络瀑布图
4. Coverage：代码覆盖率
```

### 2) 前端监控平台
- **Sentry** - 错误监控
- **Google Analytics** - 用户行为
- **阿里云ARMS** - 性能监控
- **神策数据** - 埋点分析

**记忆口诀：**
```
性能指标记五个：FCP、LCP、FID、CLS、TTFB
首绘最大交互偏移首字节、DevTools和Lighthouse是好工具
```

---

# 九、面试答题模板

## 面试题：如何进行前端性能优化？⭐⭐⭐⭐⭐

### 答题结构（总-分-总）

**第一步：总述（六大方向）**
```
前端性能优化可以从6个方向入手：
1. 资源加载优化
2. 渲染性能优化
3. JavaScript优化
4. 网络优化
5. 图片优化
6. 框架层面优化
```

**第二步：分述（3-4个重点，带代码示例）**

**1. 资源加载优化（必说）**
- 减少HTTP请求：合并文件、CSS雪碧图
- 资源压缩：Gzip/Brotli压缩
- 按需加载：路由懒加载、组件异步加载
- 代码示例：
```javascript
// 路由懒加载
const Home = () => import('./Home.vue');
```

**2. 渲染性能优化（必说）**
- 避免重排重绘：批量修改DOM、读写分离
- 使用transform代替top/left
- 虚拟滚动优化长列表
- 代码示例：
```javascript
// transform代替left
transform: translateX(100px);  // 不触发重排
```

**3. 网络优化（推荐说）**
- CDN加速
- HTTP缓存策略：强缓存+协商缓存
- DNS预解析、资源预加载
- 代码示例：
```html
<link rel="preload" href="main.js" as="script">
```

**4. 图片优化（可选）**
- 格式选择：WebP优先
- 图片懒加载：IntersectionObserver
- 响应式图片：srcset

**第三步：总结（监控和度量）**
```
最后，性能优化要有数据支撑，通过：
1. Chrome DevTools、Lighthouse评估
2. 监控FCP、LCP、FID等核心指标
3. 建立性能监控平台，持续优化
```

---

## 其他常见追问

### Q1: 重排和重绘的区别？⭐⭐⭐⭐⭐

**答案：**
- **重排（Reflow）**：元素位置、大小变化，需重新计算布局，**影响性能**
  - 触发：修改width/height、添加删除元素、改变字体大小
- **重绘（Repaint）**：元素外观变化，**不影响布局**，性能影响较小
  - 触发：修改color、background、visibility

**优化：**
- 批量修改DOM
- 使用transform/opacity（只触发合成层，不重排不重绘）
- 读写分离

---

### Q2: 虚拟滚动原理？⭐⭐⭐⭐⭐

**答案：**
只渲染可视区域的元素，大幅减少DOM数量

**核心步骤：**
1. 计算可见区域：根据scrollTop和容器高度
2. 只渲染可见元素：如10000条数据只渲染20个
3. 用padding/transform撑起总高度
4. 监听scroll事件更新可见区域

**效果：** 10000条数据从渲染10000个DOM降到20个

---

### Q3: 防抖和节流的区别？⭐⭐⭐⭐⭐

**答案：**

| 特性 | 防抖 | 节流 |
|------|------|------|
| **原理** | 等待停止触发后执行 | 固定时间间隔执行 |
| **执行次数** | 1次 | 多次 |
| **场景** | 搜索框、resize | 滚动、mousemove |
| **比喻** | 电梯等人齐了再走 | 地铁固定时间发车 |

---

### Q4: 如何优化首屏加载速度？⭐⭐⭐⭐⭐

**答案（5个方面）：**

1. **资源优化**
   - 路由懒加载、代码分割
   - 图片懒加载、WebP格式
   - Gzip压缩、Tree Shaking

2. **加载策略**
   - 关键CSS内联
   - 异步加载非关键资源
   - preload/prefetch

3. **渲染优化**
   - SSR服务端渲染
   - 骨架屏、Loading优化

4. **网络优化**
   - CDN加速
   - HTTP/2多路复用
   - 强缓存静态资源

5. **监控优化**
   - 监控FCP、LCP指标
   - Lighthouse评分优化

---

## 🎯 必背金句

```
1. "性能优化遵循2-8原则：20%的优化带来80%的提升"
2. "优先优化首屏，懒加载其他资源"
3. "避免过早优化，先测量再优化"
4. "性能优化是持续过程，需要监控和迭代"
```

---

## 📊 优化效果对比

| 优化项 | 优化前 | 优化后 | 提升 |
|--------|--------|--------|------|
| 首屏加载时间 | 5s | 1.5s | 70% |
| 首屏资源大小 | 2MB | 500KB | 75% |
| 首屏请求数 | 50个 | 15个 | 70% |
| LCP | 4s | 2s | 50% |
| Lighthouse分数 | 60分 | 95分 | +35分 |

---

## 💡 学习建议

### 必须掌握（面试必考）
1. ✅ 重排重绘原理和优化
2. ✅ 防抖节流实现
3. ✅ 虚拟滚动原理
4. ✅ 图片懒加载实现
5. ✅ HTTP缓存策略

### 加分项
1. ⭐ Web Worker使用
2. ⭐ SSR服务端渲染
3. ⭐ PWA性能优化
4. ⭐ 性能监控平台搭建

### 实战练习
1. 用Lighthouse分析真实项目
2. 实现一个虚拟滚动组件
3. 优化一个真实页面，对比优化前后数据

---

**🎉 掌握这份文档，性能优化面试题轻松拿下！记得结合实际项目经验回答，更有说服力！💪**
