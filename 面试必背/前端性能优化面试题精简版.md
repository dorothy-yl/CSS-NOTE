# 前端性能优化面试题精简版 ⭐⭐⭐⭐⭐

> 💡 **重要程度**: 高频必考 | 📌 **学习时长**: 2-3小时
> 🔥 **热度指数**: ⭐⭐⭐⭐⭐ (几乎每个面试都会问)

---

## 🎯 核心记忆口诀

### 性能优化六大方向
```
减少请求、减小体积、提高速度
缓存利用、异步加载、体验优化
```

### 性能指标口诀
```
FCP首次绘制、LCP最大内容、FID首次交互
CLS布局偏移、TTFB首字节
```

### 图片优化口诀
```
小图Base64、大图懒加载
WebP格式、雪碧图合并
响应式图片、CDN加速
```

---

## 📋 快速导航

| 章节 | 重要级别 | 核心内容 | 预计阅读时间 |
|------|---------|---------|------------|
| [一、资源加载优化](#一资源加载优化) | ⭐⭐⭐⭐⭐ | 减少请求、压缩资源 | 20分钟 |
| [二、渲染性能优化](#二渲染性能优化) | ⭐⭐⭐⭐⭐ | 重排重绘、CSS优化 | 20分钟 |
| [三、JavaScript优化](#三javascript优化) | ⭐⭐⭐⭐⭐ | 防抖节流、代码分割 | 20分钟 |
| [四、网络优化](#四网络优化) | ⭐⭐⭐⭐⭐ | CDN、HTTP缓存 | 15分钟 |
| [五、图片优化](#五图片优化) | ⭐⭐⭐⭐⭐ | 懒加载、格式选择 | 15分钟 |
| [六、Vue/React优化](#六vuereact优化) | ⭐⭐⭐⭐⭐ | 组件优化、虚拟滚动 | 20分钟 |
| [七、Webpack/Vite优化](#七webpackvite优化) | ⭐⭐⭐⭐⭐ | 构建优化、打包优化 | 25分钟 |
| [八、性能监控](#八性能监控) | ⭐⭐⭐⭐ | 性能指标、监控工具 | 15分钟 |
| [九、面试答题模板](#九面试答题模板) | ⭐⭐⭐⭐⭐ | 答题技巧 | 10分钟 |

---

# 一、资源加载优化

## 🎤 面试背诵话术

**当面试官问："如何进行资源加载优化？"**

**你可以这样回答：**

> 资源加载优化主要从三个方面入手：**减少请求次数、减小资源体积、按需加载资源**。
>
> **第一，减少HTTP请求。**我会采用CSS雪碧图将多个小图标合并成一张大图，将10个请求降为1个；对于小于10KB的图片，使用Base64编码内联到CSS中，直接减少请求；还会合并CSS和JS文件，避免多次请求。
>
> **第二，资源压缩。**在服务器端开启Gzip或Brotli压缩，可以将文件体积减少70-90%，比如100KB的文件压缩后只有20-30KB；使用Webpack或Vite进行代码压缩和混淆；配合Tree Shaking删除未使用的代码，比如只引入lodash的一个函数，就不会把整个70KB的库打包进来。
>
> **第三，按需加载。**采用路由懒加载，用动态import将页面组件分割成独立的chunk，用户访问哪个页面才加载哪个；对于大组件也使用异步组件懒加载；第三方库按需引入，比如Element Plus只引入需要的组件，而不是整个库。
>
> **这样优化下来，首屏资源体积可以从1MB降到300KB左右，首屏加载时间从5秒降到1.5秒，提升非常明显。**

---

**追问1："你提到的Tree Shaking具体是怎么工作的？"**

**回答：**

> Tree Shaking的原理是基于ES6 Module的静态分析。因为ES6的import和export是静态的，在编译时就能确定模块的依赖关系，所以打包工具可以分析出哪些代码被使用了，哪些没有被使用。
>
> 具体工作流程是：先标记所有使用的导出，然后删除未使用的导出。但它有个前提条件，就是**必须使用ES6 Module语法**，不能用CommonJS的require，因为require是动态的，编译时无法确定。
>
> 在Webpack中，生产模式会自动开启Tree Shaking，配合设置optimization.usedExports为true，以及在package.json中配置sideEffects来标记哪些文件有副作用。这样优化效果非常明显，比如整个lodash是70KB，但我只用了一个debounce函数，Tree Shaking后只打包了2KB。

---

**追问2："CSS雪碧图和Base64内联，你会怎么选择？"**

**回答：**

> 我会根据图片的大小、使用频率和缓存需求来选择。
>
> **CSS雪碧图适合：**多个小图标、固定的UI元素，比如导航图标、状态图标。优点是减少HTTP请求，而且图片可以被浏览器缓存，更新某个图标只需要改CSS坐标。缺点是维护成本高，需要工具来生成。
>
> **Base64内联适合：**非常小的图片（小于10KB）、首屏必需的图片。优点是彻底消除HTTP请求，首屏渲染更快。缺点是会增大CSS体积，而且图片不能单独缓存，每次CSS变化都要重新下载。
>
> **我的经验是：**小于5KB的首屏必需图标用Base64，5-20KB的多个图标用雪碧图，大于20KB的图片独立加载并配合懒加载和CDN。

---

**追问3："Gzip压缩你是在服务器配置还是构建时配置？"**

**回答：**

> 我一般**两边都配**，以达到最佳效果。
>
> **服务器端配置Gzip：**这是主要的压缩方式，在Nginx中设置gzip on，指定要压缩的文件类型，设置压缩级别为6（平衡压缩率和CPU消耗），只对大于1KB的文件压缩。这样对所有动态和静态资源都能生效。
>
> **构建时预压缩：**使用vite-plugin-compression或compression-webpack-plugin，在构建时就生成.gz文件，服务器可以直接返回预压缩的文件，省去了运行时压缩的CPU开销，响应更快。
>
> **最佳实践是：**静态资源用预压缩，动态内容用服务器实时压缩。如果服务器支持，Brotli压缩效果比Gzip更好，可以再减少15-25%的体积。

---

**追问4："你提到的按需加载，具体是怎么实现的？"**

**回答：**

> 按需加载主要通过动态import来实现。
>
> **在Vue Router中：**不直接import组件，而是使用箭头函数返回import，比如`const Home = () => import('./Home.vue')`。这样Webpack或Vite会把这个组件打包成单独的chunk，只有访问该路由时才会加载。
>
> **在组件层面：**对于大型图表组件、富文本编辑器这类体积大但不是首屏必需的组件，使用Vue的defineAsyncComponent或React的lazy来异步加载，配合Suspense显示loading状态。
>
> **在第三方库层面：**避免`import _ from 'lodash'`这种导入整个库的方式，改用`import debounce from 'lodash/debounce'`只导入需要的函数。UI库也配置按需引入插件，比如用unplugin-vue-components自动按需导入Element Plus组件。
>
> **实际效果：**我之前一个项目首屏体积1.2MB，应用路由懒加载后降到350KB，首屏加载时间从6秒降到2秒以内，用户体验提升非常明显。

---

## 1. 减少HTTP请求 ⭐⭐⭐⭐⭐

**口诀：合并压缩、雪碧图、内联小资源**

### 1) CSS雪碧图（Sprite）
```css
/* 将多个小图标合并成一张大图 */
.icon-home {
  background: url('sprites.png') 0 0;
  width: 20px;
  height: 20px;
}

.icon-user {
  background: url('sprites.png') -20px 0;
  width: 20px;
  height: 20px;
}
```

**优点：** 10个小图标从10个请求变成1个请求
**适用：** 小图标、固定UI元素

### 2) 小图片Base64内联
```css
/* 小于10KB的图片转为Base64 */
.logo {
  background: url('data:image/png;base64,iVBORw0KG...');
}
```

**优点：** 减少请求，首屏更快
**缺点：** 增大CSS体积，不能缓存
**建议：** 只对<10KB的图片使用

### 3) 合并CSS/JS文件
```javascript
// ❌ 不好：多个请求
<link rel="stylesheet" href="a.css">
<link rel="stylesheet" href="b.css">
<link rel="stylesheet" href="c.css">

// ✅ 好：合并为一个
<link rel="stylesheet" href="bundle.css">
```

---

## 2. 资源压缩 ⭐⭐⭐⭐⭐

**口诀：Gzip压缩、代码混淆、Tree Shaking**

### 1) Gzip/Brotli压缩
```javascript
// 服务器端开启Gzip
// Nginx配置
gzip on;
gzip_types text/css application/javascript image/svg+xml;
gzip_min_length 1024;  // 大于1KB才压缩
gzip_comp_level 6;     // 压缩级别1-9

// 效果：文件体积减少70-90%
```

**对比：**
- 原始大小：100KB
- Gzip后：20-30KB
- Brotli后：15-25KB（更优）

### 2) 代码压缩（Minify）
```javascript
// 压缩前
function calculateTotal(price, quantity) {
  const tax = 0.1;
  return price * quantity * (1 + tax);
}

// 压缩后
function calculateTotal(e,t){return e*t*1.1}
```

**工具：** Webpack、Vite、Terser

### 3) Tree Shaking（摇树优化）
```javascript
// utils.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }
export function multiply(a, b) { return a * b; }

// main.js
import { add } from './utils.js';  // 只导入add

// 打包后：subtract和multiply不会被打包
```

**要求：** 使用ES6 Module，不要用CommonJS

---

## 3. 按需加载 ⭐⭐⭐⭐⭐

**口诀：懒加载、动态导入、路由分割**

### 1) 路由懒加载
```javascript
// ❌ 不好：所有页面一次加载
import Home from './Home.vue';
import About from './About.vue';

// ✅ 好：按需加载
const Home = () => import('./Home.vue');
const About = () => import('./About.vue');

const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About }
];
```

**效果：** 首屏体积从1MB降到300KB

### 2) 组件懒加载
```vue
<!-- 异步组件 -->
<script setup>
import { defineAsyncComponent } from 'vue';

// 大组件懒加载
const HeavyChart = defineAsyncComponent(() =>
  import('./HeavyChart.vue')
);
</script>

<template>
  <HeavyChart v-if="showChart" />
</template>
```

### 3) 第三方库按需引入
```javascript
// ❌ 不好：引入整个lodash（70KB）
import _ from 'lodash';
_.debounce(fn, 300);

// ✅ 好：只引入需要的（2KB）
import debounce from 'lodash/debounce';
debounce(fn, 300);

// Element Plus按需引入
import { ElButton, ElInput } from 'element-plus';
```

**记忆口诀：**
```
资源加载三大招：减少请求、压缩体积、按需加载
合并雪碧Base64、Gzip压缩Tree Shaking、懒加载动态导入
```

---

# 二、渲染性能优化

## 🎤 面试背诵话术

**当面试官问："如何进行渲染性能优化？"**

**你可以这样回答：**

> 渲染性能优化主要从三个核心方向入手：**避免重排重绘、CSS性能优化、DOM操作优化**。
>
> **第一，避免重排和重绘。**重排是最耗性能的，因为它需要重新计算元素的位置和大小，影响整个页面布局。我会采用批量修改DOM的方式，比如修改多个样式时，不是一个个改，而是用cssText一次性修改，或者直接切换class，这样3次重排降为1次。还有读写分离，先把所有offsetHeight这类读操作集中执行，再执行写操作，避免浏览器强制同步布局。对于大量DOM操作，会先设置display为none，操作完再显示，或者用DocumentFragment，这样100次DOM操作只触发1次重排。
>
> **第二，CSS性能优化。**选择器要简化，避免层级过深，因为CSS选择器是从右向左匹配的，`.header .nav .menu .item`这种6层选择器比`.nav-item`慢很多。动画优先使用transform和opacity，因为它们只触发GPU合成，不会触发重排重绘。我之前做过一个滑动动画，用left实现时帧率只有30fps很卡，改成transform后直接60fps丝滑流畅。还会避免用@import加载CSS，因为它是串行的，改用link标签并行加载快3-5倍。
>
> **第三，关键CSS内联和长列表优化。**首屏关键CSS直接内联到HTML的head标签里，大概2-3KB，非关键CSS异步加载，这样首屏渲染提前500-800ms。对于长列表，必须用虚拟滚动，10000条数据如果全部渲染会有10000个DOM节点，页面直接卡死，虚拟滚动只渲染可见的20个，滚动时动态更新，性能提升几百倍。
>
> **这样优化下来，页面的FPS从30帧提升到60帧，用户滑动和交互非常流畅，FID首次输入延迟从300ms降到50ms以内，体验提升非常明显。**

---

**追问1："重排和重绘有什么区别？哪个性能影响更大？"**

**回答：**

> **重排（Reflow）和重绘（Repaint）的区别主要在于是否影响布局。**
>
> **重排**会触发几何属性的变化，比如修改width、height、margin、padding、display、position这些，浏览器需要重新计算元素的位置和大小，然后重新布局整个页面或部分页面，最后再重绘。性能开销非常大，因为可能影响到父元素、兄弟元素、子元素的布局。
>
> **重绘**只是视觉效果变化，比如修改color、background、border-color、visibility，元素的位置和大小没变，浏览器只需要重新绘制这个元素的外观就行，不涉及布局计算。性能开销相对小很多。
>
> **重排一定会触发重绘，但重绘不一定触发重排。**所以重排的性能影响更大，是重绘的几十倍到上百倍。
>
> **最优的是只触发合成层，**比如用transform、opacity做动画，这两个属性浏览器会单独提升到合成层，GPU直接处理，不触发重排也不触发重绘，性能最好，这就是为什么我做动画一定用transform而不是left/top。

---

**追问2："什么操作会触发强制同步布局？如何避免？"**

**回答：**

> 强制同步布局（Forced Synchronous Layout）是指在JavaScript修改了样式后，立即读取布局信息，浏览器必须立即进行重排来计算最新值，导致性能问题。
>
> **典型的触发场景：**读写交替操作，比如先修改了元素的width，然后立即读取offsetHeight，浏览器必须立即重排才能给你准确的值。如果循环里有这种操作，就会触发多次强制同步布局，性能极差。
>
> **具体例子：**`div.style.width = '100px'; let height = div.offsetHeight;`这两行代码，第二行读取offsetHeight时浏览器必须立即重排。如果在循环里对100个元素这样操作，就触发100次重排。
>
> **如何避免：读写分离。**把所有读操作集中在一起，把所有写操作也集中在一起。先一次性读取10个元素的offsetHeight存到数组，然后再统一修改这10个元素的样式，这样只触发1次重排。
>
> **我的经验是：**操作DOM前先用变量缓存需要读取的值，修改样式时用requestAnimationFrame包裹，或者用CSS变量配合transform，完全避免JavaScript读取布局信息。

---

**追问3："虚拟滚动的原理是什么？如何实现？"**

**回答：**

> 虚拟滚动的核心思想是**只渲染可视区域的DOM节点，而不是全部渲染，**大幅减少DOM数量来提升性能。
>
> **实现原理分四步：**
>
> **第一步，计算可见区域。**根据容器的scrollTop和容器高度，计算出当前可见的是第几条到第几条数据。比如容器高度500px，每项高度50px，能看到10条，scrollTop是200，那就是第5条到第15条可见。
>
> **第二步，只渲染可见数据。**10000条数据，只把可见的这10-20条渲染成真实DOM，其他的不渲染。这样10000个节点降到20个，DOM数量减少了99.8%。
>
> **第三步，撑起总高度。**用一个phantom占位元素，高度设为总数据量乘以单项高度，比如10000*50px=500000px，让滚动条看起来是正常的长度。
>
> **第四步，动态更新。**监听scroll事件，滚动时重新计算可见区域，用transform translateY来偏移可见内容的位置，然后更新这20个DOM节点显示的数据。
>
> **关键点是：**每项高度必须固定或者可预测，这样才能准确计算。还要加上缓冲区，可见10条就渲染15-20条，上下各留几条，滚动更流畅不会出现白屏。
>
> **我之前做过一个1万条数据的表格，**全部渲染页面完全卡死，加载要10秒，滑动FPS只有5帧。用虚拟滚动后秒开，滑动60帧丝滑，内存占用从500MB降到50MB，效果非常明显。

---

**追问4："transform为什么比left/top性能好？"**

**回答：**

> 这个问题涉及到浏览器的渲染流程和合成层机制。
>
> **修改left/top的过程：**改变left会触发重排，因为元素位置变了，浏览器要重新计算布局，然后重绘，最后合成。整个流程是：JavaScript → 样式计算 → 布局(Layout) → 绘制(Paint) → 合成(Composite)，性能开销大。
>
> **使用transform的过程：**transform不会触发重排和重绘，浏览器会把这个元素提升到独立的合成层，由GPU直接处理，只涉及合成这一步。流程是：JavaScript → 样式计算 → 合成(Composite)，跳过了最耗时的布局和绘制。
>
> **合成层的优势：**GPU渲染，速度快；不影响其他元素；可以做亚像素级的平滑动画。而left/top是CPU渲染，还会触发整个页面的重排重绘。
>
> **具体性能对比：**我测试过一个从0移动到100px的动画，用left实现FPS只有30帧，卡顿明显；用transform实现稳定60帧，非常流畅。而且transform的CPU占用只有left的20%。
>
> **同理opacity也一样，**它也会提升到合成层，只涉及透明度合成，不触发重排重绘。所以做动画我永远优先用transform和opacity这两个属性。

---

**追问5："关键CSS内联具体怎么做？如何确定哪些是关键CSS？"**

**回答：**

> 关键CSS（Critical CSS）是指首屏渲染必需的CSS，内联到HTML里可以避免阻塞渲染，提升首屏速度。
>
> **如何确定关键CSS：**
>
> **第一，手动分析。**打开页面，查看首屏（viewport第一屏）包含哪些元素，比如header、hero区、导航。只把这些元素的样式提取出来，一般2-5KB。
>
> **第二，工具提取。**用Chrome DevTools的Coverage工具，录制首屏加载，它会标记出哪些CSS被使用了，哪些没用到。或者用critical、critters这些自动化工具，扫描HTML生成关键CSS。
>
> **第三，经验法则。**通常包括：布局相关的（width、height、display、position）、可见内容的（background、color、font）、首屏图片的。动画、hover状态、弹窗这些非首屏必需的不算关键CSS。
>
> **具体实现：**
> ```html
> <head>
>   <style>
>     /* 关键CSS内联，2-3KB */
>     .header { height: 60px; background: #fff; }
>     .hero { height: 400px; background: url('hero.jpg'); }
>   </style>
>   <!-- 非关键CSS异步加载 -->
>   <link rel="preload" href="main.css" as="style" onload="this.rel='stylesheet'">
> </head>
> ```
>
> **效果：**内联关键CSS后，首屏FCP从2.5s降到1.2s，因为不需要等待CSS文件下载和解析就能开始渲染。但要注意关键CSS不能太大，超过14KB就得分包，否则反而影响HTML下载速度。

---

## 1. 避免重排（Reflow）和重绘（Repaint）⭐⭐⭐⭐⭐

**口诀：读写分离、批量修改、脱离文档流**

### 重排vs重绘对比

| 操作 | 重排(Reflow) | 重绘(Repaint) | 性能影响 |
|------|-------------|--------------|---------|
| 修改width/height | ✅ | ✅ | 最慢 |
| 修改color/background | ❌ | ✅ | 较快 |
| 修改transform/opacity | ❌ | ❌ | 最快 |

### 1) 批量修改DOM
```javascript
// ❌ 不好：触发3次重排
element.style.width = '100px';
element.style.height = '100px';
element.style.margin = '10px';

// ✅ 好：只触发1次重排
element.style.cssText = 'width:100px;height:100px;margin:10px';

// ✅ 更好：使用class
element.classList.add('optimized-style');
```

### 2) 读写分离
```javascript
// ❌ 不好：读写交替，触发多次重排
div1.style.height = div1.offsetHeight + 10 + 'px'; // 写-读-写
div2.style.height = div2.offsetHeight + 10 + 'px';

// ✅ 好：先读后写
const height1 = div1.offsetHeight;  // 读
const height2 = div2.offsetHeight;  // 读
div1.style.height = height1 + 10 + 'px'; // 写
div2.style.height = height2 + 10 + 'px'; // 写
```

### 3) 脱离文档流
```javascript
// 大量DOM操作时，先脱离文档流
const container = document.getElementById('container');

// 方式1：display: none
container.style.display = 'none';
// ... 进行100次DOM操作
container.style.display = 'block';  // 只触发1次重排

// 方式2：DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);
}
ul.appendChild(fragment);  // 只触发1次重排
```

### 4) 使用transform代替top/left
```css
/* ❌ 不好：触发重排 */
.box {
  position: absolute;
  left: 100px;
  transition: left 0.3s;
}
.box:hover {
  left: 200px;
}

/* ✅ 好：只触发合成，不重排 */
.box {
  transform: translateX(0);
  transition: transform 0.3s;
}
.box:hover {
  transform: translateX(100px);
}
```

---

## 2. CSS优化 ⭐⭐⭐⭐⭐

**口诀：选择器简化、避免@import、关键CSS内联**

### 1) 简化CSS选择器
```css
/* ❌ 不好：选择器过深 */
.header .nav .menu .item .link .icon {
  color: red;
}

/* ✅ 好：扁平化 */
.nav-link-icon {
  color: red;
}
```

**原因：** CSS选择器从右向左匹配，越短越快

### 2) 避免使用@import
```css
/* ❌ 不好：串行加载 */
@import url('a.css');
@import url('b.css');

/* ✅ 好：并行加载 */
<link rel="stylesheet" href="a.css">
<link rel="stylesheet" href="b.css">
```

### 3) 关键CSS内联
```html
<!-- 首屏关键CSS直接写在<head>里 -->
<head>
  <style>
    /* 关键CSS：首屏必需的样式 */
    .header { height: 60px; background: #fff; }
    .hero { height: 400px; }
  </style>

  <!-- 非关键CSS异步加载 -->
  <link rel="preload" href="main.css" as="style" onload="this.rel='stylesheet'">
</head>
```

**记忆口诀：**
```
渲染优化记四点：避免重排、批量修改、transform动画、CSS简化
读写分离脱文档、transform代替left、关键CSS内联
```

---

# 三、JavaScript优化

## 1. 防抖和节流 ⭐⭐⭐⭐⭐

**口诀：防抖等停止、节流固定间隔**

### 防抖（Debounce）
```javascript
// 应用场景：搜索框输入、窗口resize
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 使用
const search = debounce((keyword) => {
  console.log('搜索:', keyword);
}, 300);

input.addEventListener('input', (e) => search(e.target.value));
```

### 节流（Throttle）
```javascript
// 应用场景：滚动事件、鼠标移动
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 使用
const handleScroll = throttle(() => {
  console.log('滚动位置:', window.scrollY);
}, 200);

window.addEventListener('scroll', handleScroll);
```

### 对比表格

| 特性 | 防抖 | 节流 |
|------|------|------|
| **执行时机** | 停止触发后执行 | 固定间隔执行 |
| **执行次数** | 1次 | 多次 |
| **适用场景** | 搜索、resize | 滚动、mousemove |
| **实际例子** | 输入停止300ms后搜索 | 滚动时每200ms执行一次 |

---

## 2. 长列表优化 ⭐⭐⭐⭐⭐

**口诀：虚拟滚动、分页加载、时间分片**

### 1) 虚拟滚动（Virtual Scroll）
```vue
<!-- 只渲染可见区域的元素 -->
<template>
  <div class="virtual-list" @scroll="handleScroll" ref="container">
    <div class="phantom" :style="{ height: totalHeight + 'px' }"></div>
    <div class="content" :style="{ transform: `translateY(${offset}px)` }">
      <div v-for="item in visibleData" :key="item.id" class="item">
        {{ item.text }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';

const data = ref(Array.from({ length: 10000 }, (_, i) => ({
  id: i,
  text: `Item ${i}`
})));

const itemHeight = 50;      // 每项高度
const visibleCount = 20;    // 可见数量
const scrollTop = ref(0);

const startIndex = computed(() => Math.floor(scrollTop.value / itemHeight));
const endIndex = computed(() => startIndex.value + visibleCount);
const visibleData = computed(() => data.value.slice(startIndex.value, endIndex.value));
const offset = computed(() => startIndex.value * itemHeight);
const totalHeight = computed(() => data.value.length * itemHeight);

function handleScroll(e) {
  scrollTop.value = e.target.scrollTop;
}
</script>
```

**效果：** 10000条数据，只渲染20个DOM节点

### 2) 时间分片（Time Slicing）
```javascript
// 大量数据分批渲染
function timeSlice(data, batchSize = 100) {
  let index = 0;

  function render() {
    const batch = data.slice(index, index + batchSize);
    batch.forEach(item => {
      const div = document.createElement('div');
      div.textContent = item;
      container.appendChild(div);
    });

    index += batchSize;

    if (index < data.length) {
      requestAnimationFrame(render);  // 下一帧继续
    }
  }

  render();
}

// 使用
const data = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);
timeSlice(data, 100);  // 每次渲染100条
```

---

## 3. Web Worker ⭐⭐⭐⭐

**口诀：计算密集、后台处理、不阻塞UI**

```javascript
// worker.js
self.addEventListener('message', (e) => {
  const { data } = e;

  // 耗时计算
  const result = heavyComputation(data);

  // 返回结果
  self.postMessage(result);
});

function heavyComputation(data) {
  // 复杂计算逻辑
  let sum = 0;
  for (let i = 0; i < 1000000000; i++) {
    sum += i;
  }
  return sum;
}

// main.js
const worker = new Worker('worker.js');

worker.postMessage({ data: [1, 2, 3] });

worker.addEventListener('message', (e) => {
  console.log('计算结果:', e.data);
});
```

**适用场景：**
- 大数据处理
- 图像处理
- 复杂计算
- 数据加密/解密

---

## 4. 内存泄漏优化 ⭐⭐⭐⭐⭐

**口诀：闭包未清、定时器忘停、事件未移除、DOM引用残留**

### 什么是内存泄漏？

**定义：** 不再需要的内存没有被释放，导致内存占用持续增长

**影响：**
- 页面卡顿、响应变慢
- 内存占用过高，浏览器崩溃
- 移动端更严重（内存有限）

---

### 常见内存泄漏场景 ⭐⭐⭐⭐⭐

#### 1) 未清除的定时器
```javascript
// ❌ 不好：组件销毁了，定时器还在运行
export default {
  mounted() {
    setInterval(() => {
      console.log('执行中...');
    }, 1000);
  }
}

// ✅ 好：组件销毁时清除定时器
export default {
  data() {
    return {
      timer: null
    }
  },
  mounted() {
    this.timer = setInterval(() => {
      console.log('执行中...');
    }, 1000);
  },
  beforeUnmount() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
}
```

#### 2) 未移除的事件监听器
```javascript
// ❌ 不好：事件监听器没有移除
export default {
  mounted() {
    window.addEventListener('resize', this.handleResize);
    document.addEventListener('scroll', this.handleScroll);
  }
  // 组件销毁，监听器还在
}

// ✅ 好：组件销毁时移除监听器
export default {
  mounted() {
    window.addEventListener('resize', this.handleResize);
    document.addEventListener('scroll', this.handleScroll);
  },
  beforeUnmount() {
    window.removeEventListener('resize', this.handleResize);
    document.removeEventListener('scroll', this.handleScroll);
  }
}
```

#### 3) 闭包引用
```javascript
// ❌ 不好：闭包持有大对象引用
function createLeak() {
  const largeData = new Array(1000000).fill('leak');

  return function() {
    console.log(largeData[0]);  // 闭包持有largeData
  };
}

const fn = createLeak();  // largeData无法被回收

// ✅ 好：手动释放引用
function createNoLeak() {
  let largeData = new Array(1000000).fill('no leak');

  return function() {
    console.log(largeData[0]);
    largeData = null;  // 使用后释放
  };
}
```

#### 4) DOM引用残留
```javascript
// ❌ 不好：删除DOM后仍持有引用
const button = document.getElementById('btn');
const data = {
  element: button,  // 持有DOM引用
  text: 'Click me'
};

button.remove();  // DOM删除了
// 但data.element仍然引用着，导致内存泄漏

// ✅ 好：清除引用
data.element = null;
```

#### 5) Vue/React组件未清理
```javascript
// ❌ Vue不好的例子
export default {
  data() {
    return {
      subscription: null
    }
  },
  mounted() {
    // 第三方库订阅
    this.subscription = EventBus.subscribe('event', () => {});
  }
  // 组件销毁，订阅还在
}

// ✅ Vue好的例子
export default {
  data() {
    return {
      subscription: null
    }
  },
  mounted() {
    this.subscription = EventBus.subscribe('event', () => {});
  },
  beforeUnmount() {
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = null;
    }
  }
}
```

```javascript
// ❌ React不好的例子
function Component() {
  useEffect(() => {
    const subscription = EventBus.subscribe('event', () => {});
    // 没有清理
  }, []);

  return <div>Component</div>;
}

// ✅ React好的例子
function Component() {
  useEffect(() => {
    const subscription = EventBus.subscribe('event', () => {});

    // 返回清理函数
    return () => {
      subscription.unsubscribe();
    };
  }, []);

  return <div>Component</div>;
}
```

#### 6) 全局变量和意外的全局变量
```javascript
// ❌ 不好：意外的全局变量
function createLeak() {
  // 忘记写var/let/const，变成全局变量
  leakedVar = 'This is leaked';
}

// ✅ 好：使用严格模式
'use strict';
function noLeak() {
  const localVar = 'This is local';
}
```

#### 7) 循环引用（较少见）
```javascript
// ❌ 不好：循环引用
function createCircular() {
  const obj1 = {};
  const obj2 = {};

  obj1.ref = obj2;  // obj1引用obj2
  obj2.ref = obj1;  // obj2引用obj1

  return { obj1, obj2 };
}

// 现代浏览器的标记清除算法可以处理循环引用
// 但老旧浏览器可能有问题
```

---

### 如何检测内存泄漏？⭐⭐⭐⭐⭐

#### 方法1：Chrome DevTools Memory工具（最重要）

**步骤：**
```
1. 打开Chrome DevTools → Memory
2. 选择 "Heap snapshot"（堆快照）
3. 点击 "Take snapshot" 拍摄快照1
4. 执行可能泄漏的操作（如打开关闭弹窗10次）
5. 再次点击 "Take snapshot" 拍摄快照2
6. 选择快照2，选择 "Comparison"（对比）模式
7. 对比快照1和快照2，查看内存增长
```

**关键指标：**
- **Delta（增量）**：新增/删除的对象数量
- **Alloc. Size（分配大小）**：新增的内存大小
- **Freed Size（释放大小）**：释放的内存大小

**判断泄漏：**
- 如果Delta持续增长，可能存在泄漏
- 如果Freed Size很少，可能没有正常回收

---

#### 方法2：Performance Monitor实时监控

**步骤：**
```
1. 打开DevTools → More tools → Performance monitor
2. 查看指标：
   - JS heap size（JS堆大小）
   - DOM Nodes（DOM节点数）
   - JS event listeners（事件监听器数）
3. 执行操作，观察这些指标是否持续增长
```

**判断标准：**
- JS heap size持续上升 → 可能内存泄漏
- DOM Nodes持续增长 → 可能DOM未清理
- Event listeners增长不回落 → 事件监听器未移除

---

#### 方法3：Performance录制分析

**步骤：**
```
1. 打开DevTools → Performance
2. 勾选 "Memory"
3. 点击Record，执行操作（如打开关闭弹窗20次）
4. 停止录制
5. 查看Memory曲线
```

**判断标准：**
- 锯齿状正常（GC回收）
- 持续上升不下降 → 内存泄漏
- 突然掉落是GC工作

---

#### 方法4：代码检查法

**使用ESLint插件：**
```javascript
// .eslintrc.js
module.exports = {
  plugins: ['react-hooks', 'vue'],
  rules: {
    'react-hooks/exhaustive-deps': 'warn',  // 检查useEffect依赖
    'vue/no-lifecycle-after-await': 'error'  // 检查Vue生命周期
  }
};
```

---

### 内存泄漏优化方案 ⭐⭐⭐⭐⭐

#### 优化方案总结表

| 场景 | 问题 | 解决方案 | 代码示例 |
|------|------|---------|---------|
| **定时器** | 组件销毁定时器未清除 | beforeUnmount清除 | `clearInterval(timer)` |
| **事件监听** | 事件监听器未移除 | removeEventListener | `window.removeEventListener('resize', fn)` |
| **闭包** | 闭包持有大对象 | 手动释放引用 | `largeData = null` |
| **DOM引用** | 删除DOM后仍引用 | 清空引用 | `element = null` |
| **订阅** | 第三方库订阅未取消 | 取消订阅 | `subscription.unsubscribe()` |
| **全局变量** | 意外全局变量 | 使用严格模式 | `'use strict'` |
| **WeakMap** | 强引用导致无法GC | 使用WeakMap | `new WeakMap()` |

---

#### 优化技巧1：使用WeakMap/WeakSet

```javascript
// ❌ 不好：Map强引用，即使DOM删除也不会GC
const cache = new Map();
const element = document.getElementById('btn');
cache.set(element, { data: 'some data' });

element.remove();  // DOM删除
// 但cache仍然持有element引用，内存泄漏

// ✅ 好：WeakMap弱引用，DOM删除后自动GC
const cache = new WeakMap();
const element = document.getElementById('btn');
cache.set(element, { data: 'some data' });

element.remove();  // DOM删除
// WeakMap会自动释放，不会泄漏
```

---

#### 优化技巧2：Vue3组合式API自动清理

```javascript
// Vue3的onUnmounted会自动清理
import { onMounted, onUnmounted } from 'vue';

export default {
  setup() {
    let timer = null;

    onMounted(() => {
      timer = setInterval(() => {
        console.log('tick');
      }, 1000);
    });

    // 自动清理
    onUnmounted(() => {
      if (timer) {
        clearInterval(timer);
      }
    });
  }
}
```

---

#### 优化技巧3：React自定义Hook封装

```javascript
// 封装通用清理Hook
function useCleanup(callback) {
  const savedCallback = useRef();

  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  useEffect(() => {
    return () => {
      if (savedCallback.current) {
        savedCallback.current();
      }
    };
  }, []);
}

// 使用
function Component() {
  const timer = useRef();

  useEffect(() => {
    timer.current = setInterval(() => {
      console.log('tick');
    }, 1000);
  }, []);

  // 自动清理
  useCleanup(() => {
    if (timer.current) {
      clearInterval(timer.current);
    }
  });
}
```

---

### 实战案例：真实项目内存泄漏优化 ⭐⭐⭐⭐⭐

#### 案例1：地图组件内存泄漏

**问题：** 使用高德地图，切换路由后内存持续增长

**分析：**
```javascript
// ❌ 问题代码
export default {
  mounted() {
    this.map = new AMap.Map('container', {
      zoom: 11,
      center: [116.397428, 39.90923]
    });
  }
  // 组件销毁，地图实例没有销毁
}
```

**解决：**
```javascript
// ✅ 优化代码
export default {
  data() {
    return {
      map: null
    }
  },
  mounted() {
    this.map = new AMap.Map('container', {
      zoom: 11,
      center: [116.397428, 39.90923]
    });
  },
  beforeUnmount() {
    if (this.map) {
      this.map.destroy();  // 销毁地图实例
      this.map = null;
    }
  }
}
```

**效果：** 内存占用从500MB降到80MB

---

#### 案例2：图表组件内存泄漏

**问题：** 使用ECharts，切换路由10次后浏览器崩溃

**分析：**
```javascript
// ❌ 问题代码
export default {
  mounted() {
    this.chart = echarts.init(this.$refs.chart);
    this.chart.setOption(this.options);

    window.addEventListener('resize', this.handleResize);
  },
  methods: {
    handleResize() {
      this.chart.resize();
    }
  }
  // chart实例和resize监听器都没清理
}
```

**解决：**
```javascript
// ✅ 优化代码
export default {
  data() {
    return {
      chart: null
    }
  },
  mounted() {
    this.initChart();
    window.addEventListener('resize', this.handleResize);
  },
  methods: {
    initChart() {
      this.chart = echarts.init(this.$refs.chart);
      this.chart.setOption(this.options);
    },
    handleResize() {
      if (this.chart) {
        this.chart.resize();
      }
    }
  },
  beforeUnmount() {
    // 清理图表
    if (this.chart) {
      this.chart.dispose();
      this.chart = null;
    }
    // 移除监听器
    window.removeEventListener('resize', this.handleResize);
  }
}
```

**效果：** 切换100次路由，内存稳定在150MB以内

---

#### 案例3：WebSocket连接泄漏

**问题：** 实时聊天应用，切换页面后连接未断开

**分析：**
```javascript
// ❌ 问题代码
export default {
  mounted() {
    this.ws = new WebSocket('ws://localhost:8080');

    this.ws.onmessage = (e) => {
      console.log('收到消息:', e.data);
    };
  }
  // 组件销毁，WebSocket连接还在
}
```

**解决：**
```javascript
// ✅ 优化代码
export default {
  data() {
    return {
      ws: null
    }
  },
  mounted() {
    this.connectWebSocket();
  },
  methods: {
    connectWebSocket() {
      this.ws = new WebSocket('ws://localhost:8080');

      this.ws.onmessage = (e) => {
        console.log('收到消息:', e.data);
      };
    }
  },
  beforeUnmount() {
    if (this.ws) {
      this.ws.close();  // 关闭连接
      this.ws = null;
    }
  }
}
```

---

### 面试高频问答 ⭐⭐⭐⭐⭐

#### Q1: 如何检测和优化内存泄漏？

**答题结构（推荐）：**

> **检测方法我主要用三种：**
>
> **第一，Chrome DevTools的Memory工具。**具体操作是先拍一个堆快照，然后执行可能泄漏的操作，比如打开关闭弹窗10次，再拍一个快照，用Comparison模式对比两个快照。如果Delta持续增长，Freed Size很少，说明有内存泄漏。我之前就是用这个方法发现了一个地图组件泄漏，每次切换路由增长50MB，最后定位到是map实例没有destroy。
>
> **第二，Performance Monitor实时监控。**打开Performance monitor，观察JS heap size、DOM Nodes、Event listeners这三个指标。如果执行操作后这些数值持续上升不回落，就可能存在泄漏。我用这个方法发现过ECharts图表组件的泄漏，切换10次路由后event listeners从100涨到500。
>
> **第三，Performance录制分析。**录制一段时间的性能，查看Memory曲线。正常情况应该是锯齿状，有升有降，如果持续上升不下降就有问题。
>
> **常见的优化方案包括：**
> 1. 组件销毁时清除定时器：beforeUnmount里clearInterval
> 2. 移除事件监听器：removeEventListener
> 3. 销毁第三方实例：map.destroy()、chart.dispose()
> 4. 关闭连接：ws.close()
> 5. 取消订阅：subscription.unsubscribe()
> 6. 使用WeakMap代替Map，避免强引用
>
> **我之前优化过一个真实项目，**用户反馈切换页面几次后就很卡。我用Memory工具分析，发现每次切换增长300MB，定位到是高德地图和ECharts实例没有销毁。加上destroy()和dispose()后，内存从峰值800MB降到稳定150MB，用户体验明显改善。

---

#### Q2: Vue/React中如何避免内存泄漏？

**Vue避免内存泄漏：**
```javascript
export default {
  data() {
    return {
      timer: null,
      observer: null,
      chart: null
    }
  },
  mounted() {
    // 1. 定时器
    this.timer = setInterval(() => {}, 1000);

    // 2. 事件监听
    window.addEventListener('resize', this.handleResize);

    // 3. IntersectionObserver
    this.observer = new IntersectionObserver(() => {});

    // 4. 第三方库
    this.chart = echarts.init(this.$refs.chart);
  },
  beforeUnmount() {
    // 清理所有资源
    if (this.timer) clearInterval(this.timer);
    window.removeEventListener('resize', this.handleResize);
    if (this.observer) this.observer.disconnect();
    if (this.chart) this.chart.dispose();
  }
}
```

**React避免内存泄漏：**
```javascript
function Component() {
  useEffect(() => {
    const timer = setInterval(() => {}, 1000);
    const handleResize = () => {};

    window.addEventListener('resize', handleResize);

    // 返回清理函数
    return () => {
      clearInterval(timer);
      window.removeEventListener('resize', handleResize);
    };
  }, []);
}
```

---

**记忆口诀：**
```
内存泄漏四大凶：定时器、事件监听、闭包引用、DOM残留
检测三法宝：Heap snapshot、Performance Monitor、Memory曲线
优化记清理：beforeUnmount销毁、removeEventListener、实例destroy
```

---

## 5. 白屏问题优化 ⭐⭐⭐⭐⭐

**口诀：白屏原因要找准、SSR骨架加载快、资源优化不能少**

### 什么是白屏问题？

**定义：** 用户打开页面后，长时间看到空白页面，没有任何内容显示

**影响：**
- 用户体验极差，跳出率高
- 首屏FCP/LCP指标差
- SEO不友好（搜索引擎抓不到内容）

---

### 白屏产生的原因 ⭐⭐⭐⭐⭐

#### 原因1：JavaScript文件过大，加载慢
```html
<!-- ❌ 问题：单个bundle太大 -->
<script src="app.js"></script>  <!-- 3MB，加载5秒 -->

<!-- 页面结构 -->
<div id="app"></div>
<!-- 在JS加载完之前，div是空的，白屏 -->
```

**表现：** 网络慢或JS文件大，加载时间长，白屏时间长

---

#### 原因2：JavaScript执行时间长
```javascript
// ❌ 问题：首屏执行大量同步计算
function App() {
  // 首次渲染时执行耗时计算
  const data = heavyComputation();  // 耗时3秒

  return <div>{data}</div>;
}

// 3秒内页面一片空白
```

**表现：** JS加载完了，但执行耗时，白屏

---

#### 原因3：CSS文件阻塞渲染
```html
<!-- ❌ 问题：CSS文件过大或加载慢 -->
<head>
  <link rel="stylesheet" href="large-style.css">  <!-- 1MB CSS -->
</head>
<body>
  <div id="app">首页内容</div>
</body>

<!-- CSS未加载完，页面不渲染，白屏 -->
```

**表现：** CSS加载慢，阻塞页面渲染，白屏

---

#### 原因4：首屏依赖接口数据
```javascript
// ❌ 问题：首屏依赖异步数据
export default {
  data() {
    return {
      list: []
    }
  },
  async mounted() {
    this.list = await fetchData();  // 接口耗时2秒
  }
}

// 接口返回前，页面内容为空，白屏
```

**表现：** 接口慢，首屏无内容，白屏

---

#### 原因5：代码报错导致页面崩溃
```javascript
// ❌ 问题：代码报错，页面渲染失败
export default {
  mounted() {
    this.undefined.method();  // 报错
  }
}

// 代码报错，白屏
```

**表现：** JS报错，页面无法渲染，白屏

---

### 白屏问题排查方法 ⭐⭐⭐⭐⭐

#### 方法1：Chrome DevTools排查

**步骤：**
```
1. 打开DevTools → Network
   - 查看资源加载时间
   - 找出加载慢的资源（红色或长条）

2. 打开DevTools → Performance
   - 录制首屏加载
   - 查看Parse HTML、Evaluate Script时间
   - 找出耗时操作

3. 打开DevTools → Console
   - 查看是否有JS报错
   - 查看warning信息

4. 打开DevTools → Coverage
   - 查看首屏CSS/JS使用率
   - 找出未使用的代码
```

---

#### 方法2：Lighthouse分析

**步骤：**
```
1. 打开DevTools → Lighthouse
2. 选择 "Performance" + "Desktop/Mobile"
3. 点击 "Analyze page load"
4. 查看诊断结果：
   - FCP（首次内容绘制）
   - LCP（最大内容绘制）
   - TTI（可交互时间）
   - Blocking Time（阻塞时间）
```

**关键指标：**
- FCP > 3s → 白屏问题严重
- LCP > 4s → 首屏加载慢
- TTI > 7s → 可交互延迟高

---

#### 方法3：真机测试

```javascript
// 模拟慢速网络
// Chrome DevTools → Network → Throttling

- Fast 3G：下载1.6Mbps，上传750Kbps
- Slow 3G：下载400Kbps，上传400Kbps
- Offline：离线模式

// 在慢网环境下测试白屏时间
```

---

### 白屏问题解决方案 ⭐⭐⭐⭐⭐

#### 方案1：骨架屏（推荐）⭐⭐⭐⭐⭐

**定义：** 在内容加载前，显示页面的大致结构，避免完全白屏

**实现方式：**

**1) 手动编写骨架屏**
```vue
<template>
  <div class="page">
    <!-- 骨架屏 -->
    <div v-if="loading" class="skeleton">
      <div class="skeleton-header"></div>
      <div class="skeleton-item" v-for="i in 5" :key="i"></div>
    </div>

    <!-- 真实内容 -->
    <div v-else class="content">
      <div class="header">{{ title }}</div>
      <div class="item" v-for="item in list" :key="item.id">
        {{ item.name }}
      </div>
    </div>
  </div>
</template>

<style>
.skeleton-header {
  width: 100%;
  height: 60px;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

.skeleton-item {
  width: 100%;
  height: 80px;
  margin-top: 10px;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: loading 1.5s infinite;
}

@keyframes loading {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
</style>
```

**2) 使用插件自动生成（推荐）**
```javascript
// Vue项目：使用vue-skeleton-webpack-plugin
// 安装
npm install vue-skeleton-webpack-plugin

// webpack配置
const SkeletonWebpackPlugin = require('vue-skeleton-webpack-plugin');

module.exports = {
  plugins: [
    new SkeletonWebpackPlugin({
      webpackConfig: require('./webpack.skeleton.conf'),
      quiet: true
    })
  ]
};
```

**3) 服务端直出骨架屏（最佳）**
```html
<!-- index.html直接写骨架屏 -->
<!DOCTYPE html>
<html>
<head>
  <style>
    .skeleton { /* 骨架屏样式 */ }
  </style>
</head>
<body>
  <div id="app">
    <!-- 骨架屏HTML，首屏直接显示 -->
    <div class="skeleton">
      <div class="skeleton-header"></div>
      <div class="skeleton-item"></div>
      <div class="skeleton-item"></div>
    </div>
  </div>
  <script src="app.js"></script>
  <!-- JS加载后，Vue/React会替换掉骨架屏 -->
</body>
</html>
```

**效果：** 白屏时间从3秒降到0秒（立即显示骨架屏）

---

#### 方案2：Loading加载动画 ⭐⭐⭐⭐

```html
<!DOCTYPE html>
<html>
<head>
  <style>
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- 首屏Loading -->
    <div id="loading">
      <div class="spinner"></div>
      <p>加载中...</p>
    </div>
  </div>

  <script>
    // Vue/React挂载后，隐藏Loading
    window.addEventListener('load', () => {
      const loading = document.getElementById('loading');
      if (loading) {
        loading.style.display = 'none';
      }
    });
  </script>
  <script src="app.js"></script>
</body>
</html>
```

---

#### 方案3：SSR服务端渲染（最佳方案）⭐⭐⭐⭐⭐

**定义：** 服务端渲染好HTML，直接返回完整页面，无白屏

**对比：**

| 模式 | 首屏渲染 | 白屏时间 | SEO | 服务器压力 |
|------|---------|---------|-----|----------|
| **CSR**（客户端渲染） | JS渲染 | 长（3-5s） | 差 | 小 |
| **SSR**（服务端渲染） | 服务端渲染 | 短（<1s） | 好 | 大 |

**实现：**

**Vue SSR（Nuxt.js）**
```javascript
// nuxt.config.js
export default {
  ssr: true,  // 开启SSR
  target: 'server'
}

// pages/index.vue
export default {
  async asyncData({ $axios }) {
    const data = await $axios.$get('/api/data');
    return { data };
  }
}

// 服务端直接渲染好HTML返回，无白屏
```

**React SSR（Next.js）**
```javascript
// pages/index.js
export default function Home({ data }) {
  return <div>{data}</div>;
}

export async function getServerSideProps() {
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();

  return {
    props: { data }
  };
}

// 服务端渲染，首屏直接有内容
```

**效果：** 白屏时间从3秒降到0.5秒以内

---

#### 方案4：资源优化（必做）⭐⭐⭐⭐⭐

**1) 代码分割，减小首屏bundle**
```javascript
// 路由懒加载
const Home = () => import('./Home.vue');
const About = () => import('./About.vue');

// 组件懒加载
const HeavyChart = defineAsyncComponent(() => import('./Chart.vue'));
```

**效果：** 首屏JS从2MB降到500KB

---

**2) 关键CSS内联**
```html
<head>
  <style>
    /* 关键CSS内联，首屏立即渲染 */
    body { margin: 0; font-family: Arial; }
    .header { height: 60px; background: #fff; }
  </style>

  <!-- 非关键CSS异步加载 -->
  <link rel="preload" href="main.css" as="style" onload="this.rel='stylesheet'">
</head>
```

**效果：** FCP从2.5s降到1.2s

---

**3) 预加载关键资源**
```html
<head>
  <!-- DNS预解析 -->
  <link rel="dns-prefetch" href="https://api.example.com">

  <!-- 预连接 -->
  <link rel="preconnect" href="https://cdn.example.com">

  <!-- 预加载关键资源 -->
  <link rel="preload" href="main.js" as="script">
  <link rel="preload" href="logo.png" as="image">
</head>
```

---

**4) 开启Gzip/Brotli压缩**
```nginx
# Nginx配置
gzip on;
gzip_types text/css application/javascript image/svg+xml;
gzip_min_length 1024;
gzip_comp_level 6;
```

**效果：** 文件体积减少70%

---

#### 方案5：接口优化 ⭐⭐⭐⭐

**1) 首屏数据预取（SSR）**
```javascript
// 服务端预取数据，直接返回
export async function getServerSideProps() {
  const data = await fetchData();
  return { props: { data } };
}

// 客户端直接使用，无需等待接口
```

---

**2) 接口并行请求**
```javascript
// ❌ 不好：串行请求，耗时6秒
const user = await fetchUser();      // 2秒
const orders = await fetchOrders();  // 2秒
const products = await fetchProducts();  // 2秒

// ✅ 好：并行请求，耗时2秒
const [user, orders, products] = await Promise.all([
  fetchUser(),
  fetchOrders(),
  fetchProducts()
]);
```

---

**3) 接口数据缓存**
```javascript
// 使用localStorage缓存首屏数据
const cache = localStorage.getItem('homeData');
if (cache) {
  this.data = JSON.parse(cache);  // 先显示缓存数据
}

// 异步更新
fetchData().then(newData => {
  this.data = newData;
  localStorage.setItem('homeData', JSON.stringify(newData));
});
```

---

#### 方案6：错误监控和降级（必做）⭐⭐⭐⭐

**1) 错误边界（React）**
```javascript
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('页面错误:', error, errorInfo);
    // 上报错误到监控平台
  }

  render() {
    if (this.state.hasError) {
      // 降级展示
      return <div>页面加载失败，请刷新重试</div>;
    }

    return this.props.children;
  }
}

// 使用
<ErrorBoundary>
  <App />
</ErrorBoundary>
```

---

**2) 全局错误监听**
```javascript
// 监听JS错误
window.addEventListener('error', (event) => {
  console.error('页面错误:', event.error);

  // 上报错误
  reportError({
    message: event.message,
    filename: event.filename,
    line: event.lineno,
    col: event.colno,
    stack: event.error?.stack
  });

  // 显示降级页面
  document.getElementById('app').innerHTML = `
    <div style="padding: 20px; text-align: center;">
      <h2>页面加载失败</h2>
      <button onclick="location.reload()">刷新重试</button>
    </div>
  `;
});

// 监听Promise未捕获错误
window.addEventListener('unhandledrejection', (event) => {
  console.error('Promise错误:', event.reason);
  reportError({ message: event.reason });
});
```

---

### 白屏优化效果对比 ⭐⭐⭐⭐

| 优化方案 | 白屏时间（优化前） | 白屏时间（优化后） | 提升 |
|---------|----------------|----------------|------|
| **骨架屏** | 3秒 | 0秒（立即显示） | 100% |
| **Loading动画** | 3秒 | 0秒（立即显示） | 100% |
| **SSR** | 3-5秒 | 0.5-1秒 | 80% |
| **代码分割** | 5秒 | 1.5秒 | 70% |
| **关键CSS内联** | 2.5秒 | 1.2秒 | 52% |
| **Gzip压缩** | 3秒 | 1秒 | 67% |
| **综合优化** | 5秒 | 0.5秒 | 90% |

---

### 面试高频问答 ⭐⭐⭐⭐⭐

#### Q1: 白屏问题如何排查和优化？

**答题结构（推荐2分钟版本）：**

> **白屏问题我遇到过很多次，主要从排查和优化两方面来说。**
>
> **排查方法主要三种：**
>
> **第一，Chrome DevTools。**打开Network查看资源加载时间，找出加载慢的文件。打开Performance录制首屏加载，查看Parse HTML和Evaluate Script的耗时，找出阻塞渲染的操作。打开Console查看是否有JS报错导致页面崩溃。我之前就是用这个方法发现一个3MB的bundle导致首屏白屏5秒。
>
> **第二，Lighthouse分析。**运行Lighthouse得分，重点看FCP、LCP、TTI三个指标。如果FCP大于3秒，说明首屏白屏问题严重。Lighthouse还会给出具体优化建议，比如减少阻塞资源、启用文本压缩等。
>
> **第三，真机测试。**在慢速3G网络下测试，模拟真实用户环境。很多问题在快网下不明显，慢网下就暴露了。
>
> **优化方案我主要用五种：**
>
> **1. 骨架屏（最推荐）。**在首屏内容加载前，先显示页面的骨架结构，给用户明确的加载反馈。我会在index.html里直接写骨架屏的HTML和CSS，JS加载后Vue或React会自动替换掉，这样白屏时间直接降到0秒。
>
> **2. SSR服务端渲染。**使用Nuxt或Next.js，服务端直接渲染好HTML返回，首屏直接有内容。对比CSR客户端渲染，白屏时间从3-5秒降到0.5秒以内，而且SEO友好。
>
> **3. 资源优化。**路由懒加载和代码分割，把首屏bundle从2MB降到500KB。关键CSS内联，非关键CSS异步加载。开启Gzip压缩，文件体积减少70%。使用preload预加载关键资源。
>
> **4. 接口优化。**首屏接口并行请求，不要串行。使用localStorage缓存首屏数据，先展示缓存，再异步更新。如果有SSR，服务端预取数据。
>
> **5. 错误监控。**全局监听JS错误和Promise错误，一旦发生错误，显示友好的降级页面，而不是白屏。同时上报错误到监控平台，及时修复。
>
> **我之前优化过一个真实项目，**用户反馈首屏白屏很久。我用Performance分析，发现首屏bundle 3MB，加上接口串行请求，白屏长达6秒。我加了骨架屏、做了代码分割、接口改并行，开启Gzip，最终白屏时间降到0.5秒（骨架屏立即显示），用户满意度大幅提升。

---

#### Q2: 骨架屏、Loading、SSR怎么选？

**答案：**

| 方案 | 优点 | 缺点 | 适用场景 | 推荐度 |
|------|------|------|---------|--------|
| **骨架屏** | 用户体验好，页面结构清晰 | 需要维护骨架屏代码 | 所有页面 | ⭐⭐⭐⭐⭐ |
| **Loading** | 实现简单 | 用户体验一般 | 简单页面 | ⭐⭐⭐ |
| **SSR** | 首屏快，SEO好 | 服务器压力大，开发成本高 | ToC产品、需要SEO | ⭐⭐⭐⭐⭐ |

**我的选择建议：**
- **ToC产品、内容网站**：SSR + 骨架屏（最佳）
- **ToB后台系统**：骨架屏 + 资源优化
- **简单页面**：Loading + 资源优化

---

**记忆口诀：**
```
白屏问题五大招：骨架屏、Loading、SSR、资源优化、接口优化
排查用DevTools、Lighthouse、真机测试
骨架屏最佳、SSR最快、资源优化必做、错误监控不能少
```

---

# 四、网络优化

## 1. CDN加速 ⭐⭐⭐⭐⭐

**口诀：就近访问、并行下载、减轻服务器**

```html
<!-- 使用CDN -->
<script src="https://cdn.jsdelivr.net/npm/vue@3.3.4/dist/vue.global.js"></script>
<link href="https://cdn.jsdelivr.net/npm/element-plus@2.3.0/dist/index.css">

<!-- 多个CDN域名，突破浏览器并发限制 -->
<link href="https://cdn1.example.com/a.css">
<link href="https://cdn2.example.com/b.css">
<script src="https://cdn3.example.com/c.js"></script>
```

**优点：**
- 就近访问，延迟低
- 分散流量，减轻源站压力
- 多域名并行下载（浏览器限制：同域名6个并发）

---

## 2. HTTP缓存策略 ⭐⭐⭐⭐⭐

**口诀：强缓存优先、协商缓存兜底**

### 缓存配置最佳实践

```javascript
// HTML：协商缓存（保证获取最新）
app.get('/*.html', (req, res) => {
  res.set({
    'Cache-Control': 'no-cache',
    'ETag': calculateETag(content)
  });
});

// CSS/JS（带hash）：强缓存1年
// app.abc123.js
app.get('/static/*.js', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=31536000, immutable'
  });
});

// 图片：强缓存30天
app.get('/images/*', (req, res) => {
  res.set({
    'Cache-Control': 'public, max-age=2592000'
  });
});

// API：不缓存
app.get('/api/*', (req, res) => {
  res.set({
    'Cache-Control': 'no-store'
  });
});
```

---

## 3. DNS预解析和预连接 ⭐⭐⭐⭐

```html
<!-- DNS预解析 -->
<link rel="dns-prefetch" href="https://api.example.com">

<!-- 预连接（DNS + TCP + TLS） -->
<link rel="preconnect" href="https://cdn.example.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="main.css" as="style">
<link rel="preload" href="main.js" as="script">

<!-- 预获取下一页资源 -->
<link rel="prefetch" href="/page2.html">
```

### 对比表格

| 指令 | 作用 | 时机 | 适用场景 |
|------|------|------|----------|
| dns-prefetch | DNS解析 | 空闲时 | 第三方域名 |
| preconnect | DNS+TCP+TLS | 空闲时 | 重要资源域名 |
| preload | 提前下载 | 立即 | 关键资源 |
| prefetch | 提前缓存 | 空闲时 | 下一页资源 |

**记忆口诀：**
```
网络优化四法宝：CDN加速、HTTP缓存、资源预加载
强缓存一年、协商缓存验证、preload关键资源
```

---

# 五、图片优化

## 1. 图片格式选择 ⭐⭐⭐⭐⭐

**口诀：照片JPEG、图标PNG、动画GIF改WebP**

### 格式对比表

| 格式 | 特点 | 适用场景 | 体积 | 浏览器支持 |
|------|------|----------|------|-----------|
| **JPEG** | 有损压缩 | 照片、复杂图像 | 小 | ✅ 所有 |
| **PNG** | 无损压缩、透明 | Logo、图标 | 大 | ✅ 所有 |
| **WebP** | 有损/无损、透明 | 替代JPEG/PNG | 最小 | ✅ 现代浏览器 |
| **SVG** | 矢量图 | 图标、简单图形 | 极小 | ✅ 所有 |
| **AVIF** | 新一代格式 | 照片 | 极小 | ⚠️ 部分支持 |

### WebP兼容方案
```html
<picture>
  <source srcset="image.avif" type="image/avif">
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="fallback">
</picture>
```

---

## 2. 图片懒加载 ⭐⭐⭐⭐⭐

**口诀：首屏优先、滚动到才加载**

### 原生懒加载
```html
<!-- 简单方式：loading="lazy" -->
<img src="image.jpg" loading="lazy" alt="图片">
```

### IntersectionObserver懒加载
```javascript
// 更精细的控制
const images = document.querySelectorAll('img[data-src]');

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;  // 加载真实图片
      img.removeAttribute('data-src');
      observer.unobserve(img);
    }
  });
}, {
  rootMargin: '50px'  // 提前50px加载
});

images.forEach(img => observer.observe(img));
```

```html
<!-- HTML -->
<img data-src="real-image.jpg" src="placeholder.jpg" alt="图片">
```

---

## 3. 响应式图片 ⭐⭐⭐⭐

**口诀：不同尺寸、不同分辨率、按需加载**

```html
<!-- 根据屏幕宽度选择图片 -->
<img
  srcset="
    small.jpg 480w,
    medium.jpg 800w,
    large.jpg 1200w
  "
  sizes="
    (max-width: 480px) 100vw,
    (max-width: 800px) 50vw,
    33vw
  "
  src="medium.jpg"
  alt="响应式图片"
>
```

**记忆口诀：**
```
图片优化五要点：格式选择、懒加载、响应式、压缩、CDN
照片JPEG、图标PNG、WebP最优、懒加载提速
```

---

# 六、Vue/React优化

## 1. Vue性能优化 ⭐⭐⭐⭐⭐

### 1) v-if vs v-show
```vue
<!-- 频繁切换用v-show -->
<div v-show="isVisible">内容</div>

<!-- 很少切换用v-if -->
<div v-if="isLogin">用户信息</div>
```

### 2) 列表使用key
```vue
<!-- ❌ 不好：用index作key -->
<li v-for="(item, index) in list" :key="index">

<!-- ✅ 好：用唯一id -->
<li v-for="item in list" :key="item.id">
```

### 3) computed缓存
```vue
<script setup>
// ✅ 好：使用computed，有缓存
const total = computed(() => {
  return cart.value.reduce((sum, item) => sum + item.price, 0);
});

// ❌ 不好：使用方法，每次都计算
function getTotal() {
  return cart.value.reduce((sum, item) => sum + item.price, 0);
}
</script>
```

### 4) keep-alive缓存组件
```vue
<template>
  <keep-alive :include="['UserList', 'OrderList']">
    <router-view />
  </keep-alive>
</template>
```

---

## 2. React性能优化 ⭐⭐⭐⭐⭐

### 1) React.memo
```javascript
// 防止不必要的重新渲染
const Child = React.memo(({ name }) => {
  console.log('Child渲染');
  return <div>{name}</div>;
});
```

### 2) useMemo和useCallback
```javascript
// useMemo - 缓存计算结果
const total = useMemo(() => {
  return cart.reduce((sum, item) => sum + item.price, 0);
}, [cart]);

// useCallback - 缓存函数
const handleClick = useCallback(() => {
  console.log('点击');
}, []);
```

### 3) 虚拟滚动
```javascript
// 使用react-window
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={500}
  itemCount={10000}
  itemSize={50}
  width="100%"
>
  {({ index, style }) => (
    <div style={style}>Item {index}</div>
  )}
</FixedSizeList>
```

**记忆口诀：**
```
Vue优化：v-show频繁切换、key用id、computed缓存、keep-alive复用
React优化：memo防重渲、useMemo缓存值、useCallback缓存函数
```

---

# 七、Webpack/Vite优化

## 1. Webpack性能优化 ⭐⭐⭐⭐⭐

**口诀：缓存分割、按需懒加载、并行压缩**

### 1) 缓存优化（Cache）

#### contenthash文件指纹
```javascript
// webpack.config.js
module.exports = {
  output: {
    filename: '[name].[contenthash:8].js',  // 内容变化才改变hash
    chunkFilename: '[name].[contenthash:8].chunk.js'
  }
};
```

**效果：** 文件内容不变，hash不变，浏览器直接用缓存

#### cache持久化缓存
```javascript
// webpack.config.js
module.exports = {
  cache: {
    type: 'filesystem',  // 文件系统缓存
    buildDependencies: {
      config: [__filename]  // 配置变化时重新构建
    }
  }
};
```

**效果：** 二次构建速度提升90%（30s → 3s）

---

### 2) 代码分割（Code Splitting）⭐⭐⭐⭐⭐

#### splitChunks提取公共代码
```javascript
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // 提取第三方库
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          priority: 10
        },
        // 提取公共代码
        common: {
          minChunks: 2,
          name: 'common',
          priority: 5,
          reuseExistingChunk: true
        }
      }
    }
  }
};
```

**效果：**
- main.js：100KB → 30KB
- vendor.js：70KB（可长期缓存）
- common.js：10KB

#### 动态导入（Dynamic Import）
```javascript
// ❌ 不好：打包到一起
import HeavyComponent from './HeavyComponent.vue';

// ✅ 好：按需加载
const HeavyComponent = () => import(
  /* webpackChunkName: "heavy" */
  './HeavyComponent.vue'
);
```

---

### 3) 构建速度优化 ⭐⭐⭐⭐⭐

#### 多进程构建
```javascript
// webpack.config.js
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({
        parallel: true,  // 多进程并行压缩
        terserOptions: {
          compress: {
            drop_console: true  // 删除console
          }
        }
      })
    ]
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'thread-loader',  // 多进程loader
            options: { workers: 4 }
          },
          'babel-loader'
        ]
      }
    ]
  }
};
```

**效果：** 构建时间减少40-60%

#### 缩小构建范围
```javascript
// webpack.config.js
module.exports = {
  resolve: {
    // 指定扩展名，减少查找
    extensions: ['.js', '.vue', '.json'],
    // 别名，避免层层查找
    alias: {
      '@': path.resolve(__dirname, 'src'),
      'vue$': 'vue/dist/vue.runtime.esm.js'
    },
    // 指定模块查找目录
    modules: [path.resolve(__dirname, 'node_modules')]
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve(__dirname, 'src'),  // 只处理src
        exclude: /node_modules/,  // 排除node_modules
        use: 'babel-loader'
      }
    ]
  }
};
```

#### noParse跳过解析
```javascript
// webpack.config.js
module.exports = {
  module: {
    noParse: /jquery|lodash/,  // 不解析这些库（已经打包好）
  }
};
```

---

### 4) Tree Shaking ⭐⭐⭐⭐⭐

```javascript
// webpack.config.js
module.exports = {
  mode: 'production',  // 生产模式自动开启
  optimization: {
    usedExports: true,  // 标记未使用的导出
    sideEffects: false  // 开启副作用检测
  }
};

// package.json
{
  "sideEffects": [
    "*.css",
    "*.scss"
  ]
}
```

**要求：**
- 使用ES6 Module（import/export）
- 不要用CommonJS（require）

---

### 5) DLL动态链接库（已过时，了解即可）

```javascript
// webpack.dll.config.js
const webpack = require('webpack');

module.exports = {
  entry: {
    vendor: ['vue', 'vue-router', 'vuex']
  },
  output: {
    filename: '[name].dll.js',
    library: '[name]_library'
  },
  plugins: [
    new webpack.DllPlugin({
      name: '[name]_library',
      path: path.join(__dirname, '[name]-manifest.json')
    })
  ]
};
```

**注意：** Webpack 5的持久化缓存已替代DLL，不推荐使用

---

## 2. Vite性能优化 ⭐⭐⭐⭐⭐

**口诀：预构建、按需编译、Rollup打包**

### 1) Vite vs Webpack对比

| 对比项 | Webpack | Vite |
|--------|---------|------|
| **开发模式** | Bundle（打包） | ESM（原生模块） |
| **冷启动** | 慢（20-60s） | 快（1-3s） |
| **热更新** | 慢（需重新打包） | 快（只编译改动文件） |
| **生产构建** | Webpack | Rollup |
| **适用场景** | 大型项目、复杂配置 | 现代浏览器、快速开发 |

### Vite快的原因
1. **开发时**：不打包，利用浏览器原生ESM
2. **按需编译**：只编译当前页面需要的模块
3. **预构建**：依赖预构建（esbuild，比Webpack快10-100倍）

---

### 2) Vite优化配置

#### 依赖预构建优化
```javascript
// vite.config.js
export default {
  optimizeDeps: {
    // 强制预构建的依赖
    include: [
      'vue',
      'vue-router',
      'pinia',
      'axios',
      'lodash-es'
    ],
    // 排除预构建
    exclude: ['your-local-package']
  }
};
```

#### 构建优化
```javascript
// vite.config.js
export default {
  build: {
    // 代码分割
    rollupOptions: {
      output: {
        manualChunks: {
          // 提取Vue全家桶
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          // 提取UI库
          'ui-vendor': ['element-plus'],
          // 提取工具库
          'utils': ['axios', 'dayjs', 'lodash-es']
        }
      }
    },
    // 压缩
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    },
    // chunk大小警告
    chunkSizeWarningLimit: 1000,
    // 小于4KB的图片转base64
    assetsInlineLimit: 4096
  }
};
```

#### 开发服务器优化
```javascript
// vite.config.js
export default {
  server: {
    // 预热常用文件
    warmup: {
      clientFiles: [
        './src/components/**/*.vue',
        './src/views/**/*.vue'
      ]
    },
    // 文件系统缓存
    fs: {
      cachedChecks: true
    }
  }
};
```

---

### 3) Vite插件优化

#### 自动导入
```javascript
// vite.config.js
import AutoImport from 'unplugin-auto-import/vite';
import Components from 'unplugin-vue-components/vite';
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers';

export default {
  plugins: [
    // 自动导入Vue API
    AutoImport({
      imports: ['vue', 'vue-router', 'pinia'],
      resolvers: [ElementPlusResolver()]
    }),
    // 自动导入组件
    Components({
      resolvers: [ElementPlusResolver()]
    })
  ]
};
```

**效果：** 不需要手动import，自动按需引入

#### 图片优化插件
```javascript
// vite.config.js
import { ViteImageOptimizer } from 'vite-plugin-image-optimizer';

export default {
  plugins: [
    ViteImageOptimizer({
      // 图片压缩
      png: { quality: 80 },
      jpeg: { quality: 80 },
      webp: { quality: 80 }
    })
  ]
};
```

#### gzip压缩插件
```javascript
// vite.config.js
import viteCompression from 'vite-plugin-compression';

export default {
  plugins: [
    viteCompression({
      algorithm: 'gzip',
      ext: '.gz',
      threshold: 10240  // 大于10KB才压缩
    })
  ]
};
```

---

### 4) Vite常见问题优化

#### 问题1：首次启动慢
**原因：** 依赖预构建耗时

**解决：**
```javascript
// vite.config.js
export default {
  optimizeDeps: {
    // 强制预构建，避免二次预构建
    include: ['vue', 'vue-router', 'pinia', 'element-plus']
  }
};
```

#### 问题2：热更新慢
**原因：** 大量文件监听

**解决：**
```javascript
// vite.config.js
export default {
  server: {
    watch: {
      // 忽略不需要监听的文件
      ignored: ['**/node_modules/**', '**/.git/**']
    }
  }
};
```

#### 问题3：打包体积大
**原因：** 第三方库体积大

**解决：**
```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      external: ['vue', 'element-plus'],  // 外部化
      output: {
        globals: {
          vue: 'Vue',
          'element-plus': 'ElementPlus'
        }
      }
    }
  }
};

// index.html引入CDN
<script src="https://cdn.jsdelivr.net/npm/vue@3.3.4"></script>
```

---

## 3. Webpack vs Vite选择建议 ⭐⭐⭐⭐

### 选择Webpack的场景
- ✅ 大型项目（>1000个模块）
- ✅ 需要兼容IE11
- ✅ 复杂的构建需求
- ✅ 成熟的生态和插件

### 选择Vite的场景
- ✅ 新项目（推荐）
- ✅ Vue3/React项目
- ✅ 现代浏览器（ES2015+）
- ✅ 快速开发体验

---

## 4. 面试高频题 ⭐⭐⭐⭐⭐

### Q1: Webpack构建速度优化？

**答案（5个方面）：**

1. **缓存**
   - cache: 'filesystem'持久化缓存
   - babel-loader的cacheDirectory

2. **多进程**
   - thread-loader多进程loader
   - TerserPlugin并行压缩

3. **缩小范围**
   - include/exclude精确匹配
   - resolve.modules指定查找目录

4. **DLL预编译**（已过时）
   - 第三方库预编译
   - Webpack 5用cache替代

5. **按需加载**
   - 动态import
   - splitChunks代码分割

---

### Q2: Vite为什么比Webpack快？

**答案（3个核心原因）：**

1. **开发时不打包**
   - Webpack：所有模块打包成bundle
   - Vite：利用浏览器原生ESM

2. **按需编译**
   - Webpack：启动时全量编译
   - Vite：只编译当前页面需要的

3. **esbuild预构建**
   - Webpack：JavaScript编译（慢）
   - Vite：esbuild编译（Go语言，快10-100倍）

**对比：**
- Webpack冷启动：30-60s
- Vite冷启动：1-3s

---

### Q3: Tree Shaking原理？

**答案：**

**原理：** 基于ES6 Module的静态分析，删除未使用的代码

**工作流程：**
1. **标记阶段**：标记所有使用的导出
2. **清除阶段**：删除未使用的导出

**要求：**
- 使用ES6 Module（import/export）
- 不要用CommonJS（require/module.exports）
- package.json设置sideEffects

**效果：** lodash从70KB降到5KB（只用了1个函数）

---

### Q4: splitChunks如何配置？

**答案（最佳实践）：**

```javascript
splitChunks: {
  chunks: 'all',
  cacheGroups: {
    // 第三方库
    vendor: {
      test: /[\\/]node_modules[\\/]/,
      name: 'vendors',
      priority: 10
    },
    // 公共代码
    common: {
      minChunks: 2,
      name: 'common',
      priority: 5
    }
  }
}
```

**效果：**
- 第三方库单独打包，可长期缓存
- 公共代码提取，避免重复打包
- 首屏加载更快

---

**记忆口诀：**
```
Webpack优化：缓存分割、多进程并行、缩小范围
Vite优化：预构建依赖、代码分割、插件自动化
Vite快三点：不打包、按需编译、esbuild预构建
```

---

# 八、性能监控

## 1. 性能指标 ⭐⭐⭐⭐⭐

**口诀：FCP首绘、LCP最大、FID交互、CLS偏移、TTFB首字节**

### 核心Web指标（Core Web Vitals）

| 指标 | 含义 | 目标值 | 影响因素 |
|------|------|--------|----------|
| **FCP** | 首次内容绘制 | <1.8s | HTML、CSS加载速度 |
| **LCP** | 最大内容绘制 | <2.5s | 图片、视频加载 |
| **FID** | 首次输入延迟 | <100ms | JavaScript执行 |
| **CLS** | 累积布局偏移 | <0.1 | 动态内容加载 |
| **TTFB** | 首字节时间 | <600ms | 服务器响应速度 |

### 使用Performance API监控
```javascript
// 1. 获取性能指标
window.addEventListener('load', () => {
  const perfData = performance.timing;
  const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
  const domReadyTime = perfData.domContentLoadedEventEnd - perfData.navigationStart;
  const ttfb = perfData.responseStart - perfData.navigationStart;

  console.log('页面加载时间:', pageLoadTime);
  console.log('DOM解析时间:', domReadyTime);
  console.log('首字节时间:', ttfb);
});

// 2. 使用Web Vitals库
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

getCLS(console.log);
getFID(console.log);
getFCP(console.log);
getLCP(console.log);
getTTFB(console.log);
```

---

## 2. 性能监控工具 ⭐⭐⭐⭐

### 1) Chrome DevTools
```
1. Performance面板：录制性能
2. Lighthouse：性能评分
3. Network面板：网络瀑布图
4. Coverage：代码覆盖率
```

### 2) 前端监控平台
- **Sentry** - 错误监控
- **Google Analytics** - 用户行为
- **阿里云ARMS** - 性能监控
- **神策数据** - 埋点分析

**记忆口诀：**
```
性能指标记五个：FCP、LCP、FID、CLS、TTFB
首绘最大交互偏移首字节、DevTools和Lighthouse是好工具
```

---

# 九、面试答题模板

## 面试题：如何进行前端性能优化？⭐⭐⭐⭐⭐

### 答题结构（总-分-总）

**第一步：总述（六大方向）**
```
前端性能优化可以从6个方向入手：
1. 资源加载优化
2. 渲染性能优化
3. JavaScript优化
4. 网络优化
5. 图片优化
6. 框架层面优化
```

**第二步：分述（3-4个重点，带代码示例）**

**1. 资源加载优化（必说）**
- 减少HTTP请求：合并文件、CSS雪碧图
- 资源压缩：Gzip/Brotli压缩
- 按需加载：路由懒加载、组件异步加载
- 代码示例：
```javascript
// 路由懒加载
const Home = () => import('./Home.vue');
```

**2. 渲染性能优化（必说）**
- 避免重排重绘：批量修改DOM、读写分离
- 使用transform代替top/left
- 虚拟滚动优化长列表
- 代码示例：
```javascript
// transform代替left
transform: translateX(100px);  // 不触发重排
```

**3. 网络优化（推荐说）**
- CDN加速
- HTTP缓存策略：强缓存+协商缓存
- DNS预解析、资源预加载
- 代码示例：
```html
<link rel="preload" href="main.js" as="script">
```

**4. 图片优化（可选）**
- 格式选择：WebP优先
- 图片懒加载：IntersectionObserver
- 响应式图片：srcset

**第三步：总结（监控和度量）**
```
最后，性能优化要有数据支撑，通过：
1. Chrome DevTools、Lighthouse评估
2. 监控FCP、LCP、FID等核心指标
3. 建立性能监控平台，持续优化
```

---

## 其他常见追问

### Q1: 重排和重绘的区别？⭐⭐⭐⭐⭐

**答案：**
- **重排（Reflow）**：元素位置、大小变化，需重新计算布局，**影响性能**
  - 触发：修改width/height、添加删除元素、改变字体大小
- **重绘（Repaint）**：元素外观变化，**不影响布局**，性能影响较小
  - 触发：修改color、background、visibility

**优化：**
- 批量修改DOM
- 使用transform/opacity（只触发合成层，不重排不重绘）
- 读写分离

---

### Q2: 虚拟滚动原理？⭐⭐⭐⭐⭐

**答案：**
只渲染可视区域的元素，大幅减少DOM数量

**核心步骤：**
1. 计算可见区域：根据scrollTop和容器高度
2. 只渲染可见元素：如10000条数据只渲染20个
3. 用padding/transform撑起总高度
4. 监听scroll事件更新可见区域

**效果：** 10000条数据从渲染10000个DOM降到20个

---

### Q3: 防抖和节流的区别？⭐⭐⭐⭐⭐

**答案：**

| 特性 | 防抖 | 节流 |
|------|------|------|
| **原理** | 等待停止触发后执行 | 固定时间间隔执行 |
| **执行次数** | 1次 | 多次 |
| **场景** | 搜索框、resize | 滚动、mousemove |
| **比喻** | 电梯等人齐了再走 | 地铁固定时间发车 |

---

### Q4: 如何优化首屏加载速度？⭐⭐⭐⭐⭐

**答案（5个方面）：**

1. **资源优化**
   - 路由懒加载、代码分割
   - 图片懒加载、WebP格式
   - Gzip压缩、Tree Shaking

2. **加载策略**
   - 关键CSS内联
   - 异步加载非关键资源
   - preload/prefetch

3. **渲染优化**
   - SSR服务端渲染
   - 骨架屏、Loading优化

4. **网络优化**
   - CDN加速
   - HTTP/2多路复用
   - 强缓存静态资源

5. **监控优化**
   - 监控FCP、LCP指标
   - Lighthouse评分优化

---

## 🎯 必背金句

```
1. "性能优化遵循2-8原则：20%的优化带来80%的提升"
2. "优先优化首屏，懒加载其他资源"
3. "避免过早优化，先测量再优化"
4. "性能优化是持续过程，需要监控和迭代"
```

---

## 📊 优化效果对比

| 优化项 | 优化前 | 优化后 | 提升 |
|--------|--------|--------|------|
| 首屏加载时间 | 5s | 1.5s | 70% |
| 首屏资源大小 | 2MB | 500KB | 75% |
| 首屏请求数 | 50个 | 15个 | 70% |
| LCP | 4s | 2s | 50% |
| Lighthouse分数 | 60分 | 95分 | +35分 |

---

## 💡 学习建议

### 必须掌握（面试必考）
1. ✅ 重排重绘原理和优化
2. ✅ 防抖节流实现
3. ✅ 虚拟滚动原理
4. ✅ 图片懒加载实现
5. ✅ HTTP缓存策略

### 加分项
1. ⭐ Web Worker使用
2. ⭐ SSR服务端渲染
3. ⭐ PWA性能优化
4. ⭐ 性能监控平台搭建

### 实战练习
1. 用Lighthouse分析真实项目
2. 实现一个虚拟滚动组件
3. 优化一个真实页面，对比优化前后数据

---

**🎉 掌握这份文档，性能优化面试题轻松拿下！记得结合实际项目经验回答，更有说服力！💪**
