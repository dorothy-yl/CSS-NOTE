# 前端事件机制面试题-精简版 ⭐⭐⭐⭐⭐

> 💡 **核心口诀**:
> - 原生：捕获目标冒泡、父代子减内存、stop阻冒泡prevent阻默认、passive优化滚动signal批量清
> - Vue：修饰符串联、自定义指令mounted绑unmounted解
> - React：合成事件跨浏览器、箭头函数绑this、17+根容器16是document

---

## 📋 快速导航

| 主题 | 核心内容 | 记忆口诀 |
|------|---------|---------|
| 事件流 | 捕获→目标→冒泡 | 外到内再到外 |
| 事件委托 | 父元素代理子元素 | 父代子、减内存、动态绑 |
| 事件对象 | target vs currentTarget | target是源、currentTarget是绑 |
| addEventListener | type、listener、options | capture、once、passive、signal |
| Vue事件 | 修饰符、自定义指令 | stop/prevent/once、mounted绑unmounted解 |
| React事件 | 合成事件、事件委托 | 跨浏览器、根容器委托、箭头函数绑 |

---

## 一、事件流三阶段

### 核心概念
事件传播分三个阶段：**捕获阶段（外→内）→ 目标阶段 → 冒泡阶段（内→外）**

```javascript
// 捕获阶段触发（true）
parent.addEventListener('click', () => console.log('父捕获'), true);

// 冒泡阶段触发（false，默认）
child.addEventListener('click', () => console.log('子冒泡'), false);

// 点击子元素输出：父捕获 → 子冒泡
```

### 阻止传播
```javascript
element.addEventListener('click', (e) => {
  e.stopPropagation();              // 阻止冒泡
  e.preventDefault();                // 阻止默认行为
  e.stopImmediatePropagation();     // 立即停止（同级也不执行）
});
```

---

## 二、事件委托

### 核心原理
利用事件冒泡，在父元素绑定一个事件，通过 `event.target` 判断事件源

### 优点
- ✅ 减少内存消耗（只绑定一个监听器）
- ✅ 动态元素自动有事件
- ✅ 代码简洁

### 实现示例
```javascript
// ❌ 不好：每个元素都绑定
document.querySelectorAll('.item').forEach(item => {
  item.addEventListener('click', handleClick);
});

// ✅ 好：事件委托
document.querySelector('#list').addEventListener('click', (e) => {
  if (e.target.matches('.item')) {
    handleClick(e);
  }
});
```

### 完整实现
```javascript
class EventDelegate {
  constructor(parent, selector, eventType, handler) {
    parent.addEventListener(eventType, (e) => {
      let target = e.target;
      // 向上查找匹配元素
      while (target && target !== parent) {
        if (target.matches(selector)) {
          handler.call(target, e);
          break;
        }
        target = target.parentElement;
      }
    });
  }
}

// 使用
new EventDelegate(
  document.getElementById('list'),
  '.item',
  'click',
  function(e) {
    console.log('点击了:', this.textContent);
  }
);
```

---

## 三、事件对象

### target vs currentTarget
```javascript
// HTML: <div id="parent"><button id="child">点击</button></div>

document.getElementById('parent').addEventListener('click', (e) => {
  console.log(e.target.id);        // 'child' (真正点击的元素)
  console.log(e.currentTarget.id); // 'parent' (绑定事件的元素)
  console.log(this.id);            // 'parent' (this === currentTarget)
});
```

### 常用属性
```javascript
element.addEventListener('click', (event) => {
  event.type           // 事件类型：'click'
  event.target         // 事件源
  event.currentTarget  // 绑定元素（this）
  event.clientX/Y      // 相对视口坐标
  event.pageX/Y        // 相对页面坐标
  event.key            // 按键值
  event.ctrlKey        // 是否按下Ctrl
});
```

---

## 四、addEventListener 详解

### 基本语法
```javascript
element.addEventListener(type, listener, options);
```

### listener 参数的多种形式
```javascript
// 1. 函数引用
function handleClick(e) { console.log('clicked'); }
element.addEventListener('click', handleClick);

// 2. 匿名函数（this 指向 element）
element.addEventListener('click', function(e) {
  console.log(this); // element
});

// 3. 箭头函数（this 不指向 element）
element.addEventListener('click', (e) => {
  console.log(this); // 外层作用域的 this
});

// 4. 对象形式（需实现 handleEvent 方法）
const handler = {
  handleEvent(e) {
    console.log('clicked', this); // this 指向 handler 对象
  }
};
element.addEventListener('click', handler);
```

### 参数详解

**1. options.capture - 控制事件阶段**
```javascript
// false: 冒泡阶段（默认）
// true: 捕获阶段
element.addEventListener('click', handler, { capture: true });
```

**2. options.once - 只触发一次**
```javascript
button.addEventListener('click', () => {
  console.log('只执行一次');
}, { once: true });
```

**3. options.passive - 性能优化（重要）**
```javascript
// 告诉浏览器不会调用preventDefault()，提升滚动性能
window.addEventListener('scroll', handleScroll, { passive: true });

// 问题：滚动事件中可能调用 preventDefault() 会阻塞渲染导致卡顿
element.addEventListener('touchstart', (e) => {
  e.preventDefault(); // 浏览器必须等待确认是否阻止
});

// 解决：使用 passive: true 告诉浏览器不会阻止，可立即滚动
element.addEventListener('touchstart', (e) => {
  console.log('触摸开始');
  // 不能调用 preventDefault()，否则会警告
}, { passive: true });

// 注意：Chrome 56+ 默认 window/document/body 的 touchstart/touchmove 为 passive: true
// 如需阻止默认行为，必须显式设置 passive: false
document.addEventListener('touchstart', handler, { passive: false });
```

**4. options.signal - 批量移除监听器**
```javascript
const controller = new AbortController();

// 添加多个监听器
element.addEventListener('click', handler1, { signal: controller.signal });
element.addEventListener('mouseover', handler2, { signal: controller.signal });

// 一次性移除所有
controller.abort();
```

### 组合使用
```javascript
// 实战：首次交互检测
const controller = new AbortController();

['click', 'keydown', 'scroll'].forEach(type => {
  document.addEventListener(type, () => {
    console.log('首次交互');
    controller.abort(); // 触发后立即移除所有监听
  }, {
    once: true,
    passive: true,
    capture: true,
    signal: controller.signal
  });
});
```

---

## 五、自定义事件

### CustomEvent
```javascript
// 创建自定义事件
const event = new CustomEvent('myEvent', {
  detail: { message: 'Hello' },
  bubbles: true,
  cancelable: true
});

// 监听
element.addEventListener('myEvent', (e) => {
  console.log(e.detail.message); // 'Hello'
});

// 触发
element.dispatchEvent(event);
```

### EventEmitter 实现
```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(event, callback) {
    (this.events[event] ||= []).push(callback);
    return this;
  }

  emit(event, ...args) {
    this.events[event]?.forEach(cb => cb(...args));
    return this;
  }

  off(event, callback) {
    if (!callback) {
      delete this.events[event];
    } else {
      this.events[event] = this.events[event]?.filter(cb => cb !== callback);
    }
    return this;
  }

  once(event, callback) {
    const wrapper = (...args) => {
      callback(...args);
      this.off(event, wrapper);
    };
    this.on(event, wrapper);
    return this;
  }
}

// 使用
const emitter = new EventEmitter();
emitter.on('login', (user) => console.log(`${user} 登录`));
emitter.emit('login', '张三');
```

---

## 六、Vue 事件机制

### 事件修饰符
```vue
<template>
  <!-- 阻止冒泡 -->
  <div @click.stop="handle">阻止冒泡</div>

  <!-- 阻止默认行为 -->
  <form @submit.prevent="submit">提交</form>

  <!-- 只触发一次 -->
  <button @click.once="handle">只触发一次</button>

  <!-- 捕获阶段 -->
  <div @click.capture="handle">捕获</div>

  <!-- 只有点击自身才触发 -->
  <div @click.self="handle">只自身</div>

  <!-- 修饰符串联 -->
  <a @click.stop.prevent="handle">阻止冒泡和默认</a>

  <!-- 按键修饰符 -->
  <input @keyup.enter="submit">
  <input @keyup.ctrl="handleCtrl">
</template>
```

### 组件通信
```javascript
// 1. Props + Emit（父子）
// 父组件
<Child :msg="parentMsg" @update="handleUpdate" />

// 子组件
props: ['msg']
methods: {
  sendToParent() {
    this.$emit('update', 'data');
  }
}

// 2. v-model（Vue3）
// 父组件
<Child v-model:title="title" v-model:content="content" />

// 子组件
props: ['title', 'content']
emits: ['update:title', 'update:content']
this.$emit('update:title', newTitle);

// 3. provide/inject（跨级）
// 祖先
provide() {
  return { theme: this.theme };
}
// 后代
inject: ['theme']
```

### 自定义指令处理事件
```javascript
// Vue3 - 点击外部关闭指令
app.directive('click-outside', {
  mounted(el, binding) {
    el.clickOutsideEvent = (event) => {
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event);
      }
    };
    document.addEventListener('click', el.clickOutsideEvent);
  },
  unmounted(el) {
    document.removeEventListener('click', el.clickOutsideEvent);
  }
});

// 使用
<div v-click-outside="closeMenu">菜单</div>

// Vue2 版本
Vue.directive('click-outside', {
  bind(el, binding) {
    el.clickOutsideEvent = (event) => {
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event);
      }
    };
    document.body.addEventListener('click', el.clickOutsideEvent);
  },
  unbind(el) {
    document.body.removeEventListener('click', el.clickOutsideEvent);
  }
});
```

---

## 七、React 事件机制

### 合成事件（SyntheticEvent）
```javascript
// React 的合成事件是原生 DOM 事件的跨浏览器封装
function Component() {
  const handleClick = (e) => {
    console.log(e); // SyntheticEvent 对象
    console.log(e.nativeEvent); // 原生事件对象

    e.preventDefault();  // 阻止默认行为
    e.stopPropagation(); // 阻止冒泡
  };

  return <button onClick={handleClick}>点击</button>;
}
```

### React 事件特点
- **跨浏览器兼容**：抹平不同浏览器差异
- **事件委托**：React17+ 事件绑定到根容器，React16 绑定到 document
- **自动清理**：组件卸载时自动移除监听器

### React 事件绑定方式
```javascript
// 类组件
class MyComponent extends React.Component {
  // ✅ 推荐：箭头函数（自动绑定 this）
  handleClick = () => {
    console.log(this.state);
  }

  // ✅ 推荐：constructor 中 bind
  constructor() {
    super();
    this.handleClick2 = this.handleClick2.bind(this);
  }
  handleClick2() {
    console.log(this.state);
  }

  // ❌ 不推荐：每次 render 创建新函数
  render() {
    return (
      <>
        <button onClick={this.handleClick}>好</button>
        <button onClick={this.handleClick2}>好</button>
        <button onClick={(e) => this.handleClick3(e)}>差</button>
        <button onClick={this.handleClick4.bind(this)}>差</button>
      </>
    );
  }
}

// 函数组件
function MyComponent() {
  // ✅ 直接定义
  const handleClick = () => {
    console.log('clicked');
  };

  // ✅ useCallback 缓存（配合 React.memo 优化）
  const handleClick2 = useCallback(() => {
    console.log('clicked');
  }, []);

  return <button onClick={handleClick}>点击</button>;
}
```

### React17 事件系统改变
```javascript
// React16: 事件绑定到 document
// React17+: 事件绑定到根容器

// 执行顺序（React17+）：
// 1. 原生捕获事件
// 2. React 捕获事件
// 3. React 冒泡事件
// 4. 原生冒泡事件

// React16 执行顺序：
// 1. 原生捕获事件
// 2. 原生冒泡事件
// 3. React 捕获事件
// 4. React 冒泡事件
```

---

## 八、常见面试题

### 1. 实现点击外部关闭
```javascript
function useClickOutside(elementRef, callback) {
  const handleClick = (e) => {
    if (elementRef.current && !elementRef.current.contains(e.target)) {
      callback();
    }
  };

  document.addEventListener('click', handleClick);
  return () => document.removeEventListener('click', handleClick);
}
```

### 2. 防抖节流
```javascript
// 防抖：等待一段时间后执行
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 节流：固定时间间隔执行
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}
```

### 3. 移除事件监听器的坑
```javascript
// ❌ 错误：匿名函数无法移除
element.addEventListener('click', () => console.log('click'));
element.removeEventListener('click', () => console.log('click')); // 无效

// ✅ 正确：保存函数引用
const handler = () => console.log('click');
element.addEventListener('click', handler);
element.removeEventListener('click', handler); // 有效

// ✅ 或使用 once
element.addEventListener('click', () => console.log('click'), { once: true });

// ✅ 或使用 signal
const controller = new AbortController();
element.addEventListener('click', () => console.log('click'), {
  signal: controller.signal
});
controller.abort(); // 移除
```

---

## 九、最佳实践

### 1. 避免内存泄漏
```javascript
class Component {
  constructor() {
    this.controller = new AbortController();
    this.handleResize = this.handleResize.bind(this);
  }

  mount() {
    window.addEventListener('resize', this.handleResize, {
      signal: this.controller.signal
    });
  }

  unmount() {
    this.controller.abort(); // 清理所有监听器
  }

  handleResize() {
    // 处理逻辑
  }
}
```

### 2. React 中的事件处理
```javascript
function MyComponent() {
  useEffect(() => {
    const controller = new AbortController();

    window.addEventListener('resize', handleResize, {
      signal: controller.signal
    });

    return () => controller.abort(); // 组件卸载时清理
  }, []);
}
```

### 3. 事件委托最佳实践
```javascript
// 使用 closest 向上查找
container.addEventListener('click', (e) => {
  const item = e.target.closest('.item');
  if (item) {
    handleClick(item);
  }
});
```

---

## 📌 核心知识点速记

### 原生事件
1. **事件流**：捕获(外→内) → 目标 → 冒泡(内→外)
2. **事件委托**：父元素代理子元素，减少内存，支持动态元素
3. **target vs currentTarget**：target是事件源，currentTarget是绑定元素
4. **addEventListener**：推荐使用，支持多个监听器和高级选项
5. **options 重要参数**：
   - `capture`: 控制阶段（捕获/冒泡）
   - `once`: 只触发一次，自动移除
   - `passive`: 性能优化（告诉浏览器不调用preventDefault，提升滚动性能）
   - `signal`: 批量移除监听器（AbortController）
6. **阻止传播**：`stopPropagation()`、`preventDefault()`、`stopImmediatePropagation()`
7. **listener 形式**：函数引用、匿名函数、箭头函数、对象（handleEvent）

### Vue 事件
1. **事件修饰符**：`.stop`、`.prevent`、`.capture`、`.self`、`.once`、`.passive`
2. **按键修饰符**：`.enter`、`.tab`、`.delete`、`.esc`、`.ctrl`、`.alt`、`.shift`
3. **自定义指令**：在 `mounted/bind` 绑定事件，在 `unmounted/unbind` 移除事件
4. **组件通信**：Props + Emit、v-model、provide/inject

### React 事件
1. **合成事件**：跨浏览器兼容的事件封装，自动清理
2. **事件委托**：React17+ 绑定到根容器，React16 绑定到 document
3. **绑定方式**：箭头函数（推荐）、constructor bind、useCallback
4. **执行顺序**：React17+ 遵循原生事件流，React16 原生事件先于 React 事件

### 最佳实践
1. **内存管理**：组件销毁时必须移除监听器，使用 signal 批量清理
2. **性能优化**：滚动/触摸事件使用 `passive: true`
3. **事件委托**：使用 `closest()` 向上查找目标元素
4. **防抖节流**：高频事件使用 debounce/throttle 优化
