# 前端事件机制面试题-精简版 ⭐⭐⭐⭐⭐

> 💡 **核心口诀**: 捕获目标冒泡、父代子减内存、stop阻冒泡prevent阻默认

---

## 📋 快速导航

| 主题 | 核心内容 | 记忆口诀 |
|------|---------|---------|
| 事件流 | 捕获→目标→冒泡 | 外到内再到外 |
| 事件委托 | 父元素代理子元素 | 父代子、减内存、动态绑 |
| 事件对象 | target vs currentTarget | target是源、currentTarget是绑 |
| addEventListener | type、listener、options | capture、once、passive、signal |

---

## 一、事件流三阶段

### 核心概念
事件传播分三个阶段：**捕获阶段（外→内）→ 目标阶段 → 冒泡阶段（内→外）**

```javascript
// 捕获阶段触发（true）
parent.addEventListener('click', () => console.log('父捕获'), true);

// 冒泡阶段触发（false，默认）
child.addEventListener('click', () => console.log('子冒泡'), false);

// 点击子元素输出：父捕获 → 子冒泡
```

### 阻止传播
```javascript
element.addEventListener('click', (e) => {
  e.stopPropagation();              // 阻止冒泡
  e.preventDefault();                // 阻止默认行为
  e.stopImmediatePropagation();     // 立即停止（同级也不执行）
});
```

---

## 二、事件委托

### 核心原理
利用事件冒泡，在父元素绑定一个事件，通过 `event.target` 判断事件源

### 优点
- ✅ 减少内存消耗（只绑定一个监听器）
- ✅ 动态元素自动有事件
- ✅ 代码简洁

### 实现示例
```javascript
// ❌ 不好：每个元素都绑定
document.querySelectorAll('.item').forEach(item => {
  item.addEventListener('click', handleClick);
});

// ✅ 好：事件委托
document.querySelector('#list').addEventListener('click', (e) => {
  if (e.target.matches('.item')) {
    handleClick(e);
  }
});
```

### 完整实现
```javascript
class EventDelegate {
  constructor(parent, selector, eventType, handler) {
    parent.addEventListener(eventType, (e) => {
      let target = e.target;
      // 向上查找匹配元素
      while (target && target !== parent) {
        if (target.matches(selector)) {
          handler.call(target, e);
          break;
        }
        target = target.parentElement;
      }
    });
  }
}

// 使用
new EventDelegate(
  document.getElementById('list'),
  '.item',
  'click',
  function(e) {
    console.log('点击了:', this.textContent);
  }
);
```

---

## 三、事件对象

### target vs currentTarget
```javascript
// HTML: <div id="parent"><button id="child">点击</button></div>

document.getElementById('parent').addEventListener('click', (e) => {
  console.log(e.target.id);        // 'child' (真正点击的元素)
  console.log(e.currentTarget.id); // 'parent' (绑定事件的元素)
  console.log(this.id);            // 'parent' (this === currentTarget)
});
```

### 常用属性
```javascript
element.addEventListener('click', (event) => {
  event.type           // 事件类型：'click'
  event.target         // 事件源
  event.currentTarget  // 绑定元素（this）
  event.clientX/Y      // 相对视口坐标
  event.pageX/Y        // 相对页面坐标
  event.key            // 按键值
  event.ctrlKey        // 是否按下Ctrl
});
```

---

## 四、addEventListener 详解

### 基本语法
```javascript
element.addEventListener(type, listener, options);
```

### 参数详解

**1. options.capture - 控制事件阶段**
```javascript
// false: 冒泡阶段（默认）
// true: 捕获阶段
element.addEventListener('click', handler, { capture: true });
```

**2. options.once - 只触发一次**
```javascript
button.addEventListener('click', () => {
  console.log('只执行一次');
}, { once: true });
```

**3. options.passive - 性能优化（重要）**
```javascript
// 告诉浏览器不会调用preventDefault()，提升滚动性能
window.addEventListener('scroll', handleScroll, { passive: true });
```

**4. options.signal - 批量移除监听器**
```javascript
const controller = new AbortController();

// 添加多个监听器
element.addEventListener('click', handler1, { signal: controller.signal });
element.addEventListener('mouseover', handler2, { signal: controller.signal });

// 一次性移除所有
controller.abort();
```

### 组合使用
```javascript
// 实战：首次交互检测
const controller = new AbortController();

['click', 'keydown', 'scroll'].forEach(type => {
  document.addEventListener(type, () => {
    console.log('首次交互');
    controller.abort(); // 触发后立即移除所有监听
  }, {
    once: true,
    passive: true,
    capture: true,
    signal: controller.signal
  });
});
```

---

## 五、自定义事件

### CustomEvent
```javascript
// 创建自定义事件
const event = new CustomEvent('myEvent', {
  detail: { message: 'Hello' },
  bubbles: true,
  cancelable: true
});

// 监听
element.addEventListener('myEvent', (e) => {
  console.log(e.detail.message); // 'Hello'
});

// 触发
element.dispatchEvent(event);
```

### EventEmitter 实现
```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(event, callback) {
    (this.events[event] ||= []).push(callback);
    return this;
  }

  emit(event, ...args) {
    this.events[event]?.forEach(cb => cb(...args));
    return this;
  }

  off(event, callback) {
    if (!callback) {
      delete this.events[event];
    } else {
      this.events[event] = this.events[event]?.filter(cb => cb !== callback);
    }
    return this;
  }

  once(event, callback) {
    const wrapper = (...args) => {
      callback(...args);
      this.off(event, wrapper);
    };
    this.on(event, wrapper);
    return this;
  }
}

// 使用
const emitter = new EventEmitter();
emitter.on('login', (user) => console.log(`${user} 登录`));
emitter.emit('login', '张三');
```

---

## 六、Vue 事件机制

### 事件修饰符
```vue
<template>
  <!-- 阻止冒泡 -->
  <div @click.stop="handle">阻止冒泡</div>

  <!-- 阻止默认行为 -->
  <form @submit.prevent="submit">提交</form>

  <!-- 只触发一次 -->
  <button @click.once="handle">只触发一次</button>

  <!-- 捕获阶段 -->
  <div @click.capture="handle">捕获</div>

  <!-- 只有点击自身才触发 -->
  <div @click.self="handle">只自身</div>

  <!-- 修饰符串联 -->
  <a @click.stop.prevent="handle">阻止冒泡和默认</a>

  <!-- 按键修饰符 -->
  <input @keyup.enter="submit">
  <input @keyup.ctrl="handleCtrl">
</template>
```

### 组件通信
```javascript
// 1. Props + Emit（父子）
// 父组件
<Child :msg="parentMsg" @update="handleUpdate" />

// 子组件
props: ['msg']
methods: {
  sendToParent() {
    this.$emit('update', 'data');
  }
}

// 2. v-model（Vue3）
// 父组件
<Child v-model:title="title" v-model:content="content" />

// 子组件
props: ['title', 'content']
emits: ['update:title', 'update:content']
this.$emit('update:title', newTitle);

// 3. provide/inject（跨级）
// 祖先
provide() {
  return { theme: this.theme };
}
// 后代
inject: ['theme']
```

---

## 七、常见面试题

### 1. 实现点击外部关闭
```javascript
function useClickOutside(elementRef, callback) {
  const handleClick = (e) => {
    if (elementRef.current && !elementRef.current.contains(e.target)) {
      callback();
    }
  };

  document.addEventListener('click', handleClick);
  return () => document.removeEventListener('click', handleClick);
}
```

### 2. 防抖节流
```javascript
// 防抖：等待一段时间后执行
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 节流：固定时间间隔执行
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}
```

### 3. 移除事件监听器的坑
```javascript
// ❌ 错误：匿名函数无法移除
element.addEventListener('click', () => console.log('click'));
element.removeEventListener('click', () => console.log('click')); // 无效

// ✅ 正确：保存函数引用
const handler = () => console.log('click');
element.addEventListener('click', handler);
element.removeEventListener('click', handler); // 有效

// ✅ 或使用 once
element.addEventListener('click', () => console.log('click'), { once: true });

// ✅ 或使用 signal
const controller = new AbortController();
element.addEventListener('click', () => console.log('click'), {
  signal: controller.signal
});
controller.abort(); // 移除
```

---

## 八、最佳实践

### 1. 避免内存泄漏
```javascript
class Component {
  constructor() {
    this.controller = new AbortController();
    this.handleResize = this.handleResize.bind(this);
  }

  mount() {
    window.addEventListener('resize', this.handleResize, {
      signal: this.controller.signal
    });
  }

  unmount() {
    this.controller.abort(); // 清理所有监听器
  }

  handleResize() {
    // 处理逻辑
  }
}
```

### 2. React 中的事件处理
```javascript
function MyComponent() {
  useEffect(() => {
    const controller = new AbortController();

    window.addEventListener('resize', handleResize, {
      signal: controller.signal
    });

    return () => controller.abort(); // 组件卸载时清理
  }, []);
}
```

### 3. 事件委托最佳实践
```javascript
// 使用 closest 向上查找
container.addEventListener('click', (e) => {
  const item = e.target.closest('.item');
  if (item) {
    handleClick(item);
  }
});
```

---

## 📌 核心知识点速记

1. **事件流**：捕获(外→内) → 目标 → 冒泡(内→外)
2. **事件委托**：父元素代理子元素，减少内存，支持动态元素
3. **target vs currentTarget**：target是事件源，currentTarget是绑定元素
4. **addEventListener**：推荐使用，支持多个监听器和高级选项
5. **options重要参数**：
   - `capture`: 控制阶段
   - `once`: 只触发一次
   - `passive`: 性能优化（滚动）
   - `signal`: 批量移除
6. **阻止传播**：`stopPropagation()`、`preventDefault()`
7. **内存管理**：组件销毁时必须移除监听器
