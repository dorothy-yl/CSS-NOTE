# 前端事件机制高频面试题汇总 ⭐⭐⭐⭐⭐

> 💡 **重要程度**: 高频必考
> 📌 **记忆口诀**:
> - 事件流：**捕获目标冒泡（capture、target、bubble）**
> - 事件委托：**父代子、减内存、动态绑**
> - 阻止传播：**stopPropagation阻冒泡、preventDefault阻默认**

---

## 📋 快速导航

| 章节 | 重要级别 | 核心内容 | 记忆口诀 |
|------|---------|---------|---------|
| [一、JavaScript原生事件机制](#一javascript原生事件机制-) | ⭐⭐⭐⭐⭐ | 事件流、事件委托、事件对象 | 捕获目标冒泡 |
| [├─ 1. 事件流](#1-事件流-) | ⭐⭐⭐⭐⭐ | 捕获→目标→冒泡三阶段 | 外到内再到外 |
| [├─ 2. 事件委托/代理](#2-事件委托代理-) | ⭐⭐⭐⭐⭐ | 原理、优缺点、实现 | 父代子、减内存、动态绑 |
| [├─ 3. 事件对象](#3-事件对象-) | ⭐⭐⭐⭐ | target vs currentTarget | target是源、currentTarget是绑 |
| [├─ 4. 自定义事件](#4-自定义事件) | ⭐⭐⭐⭐ | CustomEvent、EventEmitter | 创建监听触发 |
| [└─ 5. 事件性能优化](#5-事件性能优化-) | ⭐⭐⭐⭐ | 防抖节流、passive | 防抖等待、节流间隔 |
| [二、Vue事件机制](#二vue事件机制-) | ⭐⭐⭐⭐⭐ | 事件修饰符、组件通信 | stop、prevent、once |
| [三、React事件机制](#三react事件机制-) | ⭐⭐⭐⭐ | 合成事件、事件池 | 合成统一、自动绑定 |
| [四、框架事件机制对比](#四框架事件机制对比-) | ⭐⭐⭐ | 原生vs Vue vs React | 各有特色、按需选择 |
| [五、经典面试题实战](#五经典面试题实战-) | ⭐⭐⭐⭐⭐ | 综合应用题 | 实战演练 |
| [六、addEventListener 深入解析](#六addeventlistener-深入解析-) | ⭐⭐⭐⭐⭐ | 参数详解、最佳实践 | type、listener、options |@

---

## 🎯 记忆口诀

### 事件机制核心口诀
```
事件流三阶段：捕获→目标→冒泡
事件委托优势：父代子、减内存、动态绑
阻止传播方法：stopPropagation、preventDefault、return false
事件对象区别：target是源、currentTarget是绑定者
```

### 详细口诀

**事件流口诀：**
```
捕获阶段从外到内（window → document → body → div → button）
目标阶段到达目标
冒泡阶段从内到外（button → div → body → document → window）
记住：捕获少用、冒泡常用
```

**事件委托口诀：**
```
父代子、减内存（一个监听器管多个子元素）
动态绑（新增元素自动有事件）
精确判（event.target判断点击源）
向上找（matches配合closest）
```

**addEventListener口诀：**
```
三参数：type、listener、options/useCapture
options包含：capture、once、passive、signal
capture为true捕获、false冒泡（默认false）
once为true只触发一次
passive为true不会调用preventDefault（优化滚动）
```

**事件对象属性口诀：**
```
target是真正点击的元素（事件源）
currentTarget是绑定监听器的元素（this指向它）
type是事件类型（click、input等）
preventDefault阻止默认行为
stopPropagation阻止冒泡
stopImmediatePropagation立即停止（同级也不执行）
```

**自定义事件口诀：**
```
new CustomEvent创建（可传detail数据）
addEventListener监听
dispatchEvent触发
记住：创建→监听→触发三步走
```

**Vue事件口诀：**
```
@click绑定、.stop阻冒泡、.prevent阻默认
.once只一次、.capture捕获、.self只自己
.native原生、$emit子传父、v-on监听
```

**React事件口诀：**
```
合成事件统一管理、驼峰命名（onClick）
自动绑定this需箭头、事件池复用提性能
阻止冒泡用stopPropagation、原生事件用nativeEvent
```

---

## 一、JavaScript原生事件机制 ⭐⭐⭐⭐⭐

### 1. 事件流
#### 热度：⭐⭐⭐⭐⭐

#### 题目1：什么是事件流？事件流的三个阶段是什么？

**通俗概述：**
想象你点击了一个按钮，这个点击事件不是直接就到按钮上的，而是像水流一样有个传播过程。事件流就是描述这个点击事件是怎么从浏览器窗口一层层传到按钮，然后再一层层传回去的过程。就像扔石头到水里，水波会先向外扩散，然后再回来一样。

**答案：**
事件流描述的是从页面中接收事件的顺序。当一个事件发生时，会在元素之间按照特定的顺序传播，这个传播过程就是事件流。

**事件流的三个阶段：**
1. **捕获阶段（Capture Phase）**：事件从window对象向目标元素传播
2. **目标阶段（Target Phase）**：事件到达目标元素
3. **冒泡阶段（Bubble Phase）**：事件从目标元素向window对象传播

```javascript
// 事件流示例
document.getElementById('parent').addEventListener('click', function(e) {
  console.log('父元素捕获');
}, true); // true表示在捕获阶段触发

document.getElementById('child').addEventListener('click', function(e) {
  console.log('子元素冒泡');
}, false); // false表示在冒泡阶段触发（默认）

// 点击子元素时的输出顺序：
// 1. 父元素捕获
// 2. 子元素冒泡
```

#### 题目2：如何阻止事件冒泡和捕获？

**通俗概述：**
有时候我们不希望事件像水波一样传播，比如点击了子元素，不想让父元素也收到这个点击。就像在传话游戏中，我们可以让某个人停止往下传话。阻止冒泡就是让事件不再向上传播，阻止捕获就是让事件不再向下传播。

**答案：**

**口述要点：**

这些方法都需要在 **addEventListener 的第二个参数（回调函数）中**调用，通过事件对象（event）来使用：

1. **阻止事件冒泡** - 使用 `event.stopPropagation()` 方法，阻止事件继续向父元素传播，但当前元素上的其他同类型监听器仍会执行
2. **立即停止传播** - 使用 `event.stopImmediatePropagation()` 方法，不仅阻止冒泡和捕获，还会阻止当前元素上其他同类型监听器的执行
3. **阻止默认行为** - 使用 `event.preventDefault()` 方法，阻止元素的默认行为（如 `<a>` 标签跳转、`<form>` 表单提交、右键菜单等）
4. **return false** - 在传统的 `onclick` 属性绑定中可以同时阻止冒泡和默认行为，但在 `addEventListener` 中无效

**核心区别：**
- `stopPropagation()` 只阻止传播，不影响默认行为
- `preventDefault()` 只阻止默认行为，不影响传播
- `stopImmediatePropagation()` 最彻底，连同级监听器都不执行

```javascript
element.addEventListener('click', function(e) {
  // 阻止事件冒泡
  e.stopPropagation();

  // 阻止事件捕获和冒泡（立即停止，同级别的其他监听器也不会执行）
  e.stopImmediatePropagation();

  // 阻止默认行为（如链接跳转、表单提交）
  e.preventDefault();

  // 在旧版本中，返回false可以同时阻止冒泡和默认行为
  // 但只在onclick等属性绑定中有效，addEventListener中无效
  return false;
});
```

#### 题目3：事件冒泡和事件捕获的实际应用场景？

**通俗概述：**
事件冒泡最常用的场景是"事件委托"，就像班长代表全班同学一样。比如有100个按钮，我们不用给每个按钮都绑定事件，只需要给它们的父容器绑定一个事件就行了，利用冒泡机制来处理。事件捕获则常用于全局拦截，比如在最外层拦截所有点击，做权限检查。

**答案：**

事件冒泡和捕获在实际开发中有两个主要应用场景：

**事件冒泡的应用 - 事件委托：** 这是最常用的场景。当页面有大量相同类型的子元素需要绑定事件时，不用给每个子元素单独绑定，而是将事件监听器绑定在父元素上，利用冒泡机制，在父元素中通过 `event.target` 判断实际触发的子元素。这样做可以减少内存消耗，而且动态添加的子元素也会自动拥有事件处理能力。

**事件捕获的应用 - 全局事件拦截：** 在捕获阶段可以最早拦截到事件，常用于全局权限控制、埋点统计等场景。通过在 `addEventListener` 的第三个参数设置为 `true` 来监听捕获阶段，可以在事件到达目标元素之前进行拦截处理，如果不符合条件就阻止事件继续传播。

```javascript
// 1. 事件冒泡应用：事件委托
// 不好的做法：为每个li绑定事件
const lis = document.querySelectorAll('li');
lis.forEach(li => {
  li.addEventListener('click', handleClick);
});

// 好的做法：利用冒泡，只在父元素绑定一次
document.querySelector('ul').addEventListener('click', function(e) {
  if (e.target.tagName === 'LI') {
    handleClick(e);
  }
});

// 2. 事件捕获应用：全局事件拦截
// 在捕获阶段拦截所有点击事件
document.addEventListener('click', function(e) {
  // 可以在这里做权限验证、埋点统计等
  if (!hasPermission()) {
    e.stopPropagation(); // 阻止事件继续传播
    e.preventDefault();
    showNoPermissionDialog();
  }
}, true);
```

### 2. 事件委托/代理
#### 热度：⭐⭐⭐⭐⭐

#### 题目1：什么是事件委托？原理和优缺点是什么？

**通俗概述：**
事件委托就像是"代理人"的概念。比如一个班级里有30个学生，老师不用跟每个学生单独说话，只需要跟班长说，班长再转达给其他同学。在网页中，我们不给每个子元素绑定事件，而是给父元素绑定一个事件，让父元素来"代理"处理所有子元素的事件。这样做的好处是省内存、代码简洁，新增的子元素也自动有事件处理能力。

**答案：**
事件委托是利用事件冒泡机制，将事件监听器绑定在父元素上，通过判断事件目标来处理子元素的事件。

**原理：**
基于事件冒泡机制，子元素的事件会冒泡到父元素，在父元素的监听器中通过event.target判断事件源。

**优点：**
1. **减少内存消耗**：只需要绑定一个事件监听器
2. **动态元素支持**：新添加的子元素自动有事件处理
3. **简化代码**：避免重复绑定

**缺点：**
1. **不支持不冒泡的事件**：如focus、blur等
2. **可能误触发**：需要准确判断事件目标
3. **阻止冒泡会失效**：如果中间元素阻止冒泡

```javascript
// 完整的事件委托实现
class EventDelegate {
  constructor(parent, selector, eventType, handler) {
    this.parent = parent;
    this.selector = selector;
    this.handler = handler;

    parent.addEventListener(eventType, this.handleEvent.bind(this));
  }

  handleEvent(e) {
    let target = e.target;

    // 向上查找匹配的元素
    while (target && target !== this.parent) {
      if (target.matches(this.selector)) {
        this.handler.call(target, e);
        break;
      }
      target = target.parentElement;
    }
  }
}

// 使用示例
new EventDelegate(
  document.getElementById('list'),
  '.item',
  'click',
  function(e) {
    console.log('点击了:', this.textContent);
  }
);
```

#### 题目2：事件委托的经典面试题

**通俗概述：**
这是一个实际应用题，要求用事件委托实现一个待办事项列表。关键思路是：不给每个按钮单独绑定事件，而是给整个容器绑定一个事件，然后通过判断点击的是哪个按钮来执行对应的操作（删除、编辑、标记完成等）。

**答案：**

使用事件委托实现待办事项列表的核心思路是：在父容器上绑定一个统一的点击事件监听器，通过 `event.target` 判断实际点击的是哪个按钮，再通过 `dataset.action` 属性识别操作类型，最后用 `closest()` 方法找到对应的待办项元素执行相应操作。这样做的好处是只需要一个监听器就能处理所有按钮的事件，而且动态添加的新待办项也会自动拥有事件处理能力，大大减少了内存占用和代码量。

```javascript
// 题目：实现一个todolist，支持添加、删除、标记完成
class TodoList {
  constructor(container) {
    this.container = container;
    this.init();
  }

  init() {
    // 使用事件委托处理所有事件
    this.container.addEventListener('click', (e) => {
      const target = e.target;
      const action = target.dataset.action;
      const todoItem = target.closest('.todo-item');

      if (!action || !todoItem) return;

      switch(action) {
        case 'delete':
          this.deleteTodo(todoItem);
          break;
        case 'toggle':
          this.toggleTodo(todoItem);
          break;
        case 'edit':
          this.editTodo(todoItem);
          break;
      }
    });
  }

  addTodo(text) {
    const html = `
      <div class="todo-item">
        <input type="checkbox" data-action="toggle">
        <span class="todo-text">${text}</span>
        <button data-action="edit">编辑</button>
        <button data-action="delete">删除</button>
      </div>
    `;
    this.container.insertAdjacentHTML('beforeend', html);
  }

  deleteTodo(item) {
    item.remove();
  }

  toggleTodo(item) {
    item.classList.toggle('completed');
  }

  editTodo(item) {
    const textElement = item.querySelector('.todo-text');
    const newText = prompt('编辑任务:', textElement.textContent);
    if (newText) {
      textElement.textContent = newText;
    }
  }
}
```

### 3. 事件对象
#### 热度：⭐⭐⭐⭐

#### 题目1：事件对象的常用属性和方法？

**通俗概述：**
当事件发生时，浏览器会创建一个"事件对象"，里面包含了这次事件的所有信息，就像是事件的"身份证"。比如点击事件的对象会告诉你：点击的是哪个元素、鼠标在哪个位置、按了哪些键等等。掌握这些属性和方法，就能获取事件的详细信息并进行相应处理。

**答案：**

事件对象包含三类重要的属性和方法：

**通用属性：** `type` 表示事件类型，`target` 是触发事件的元素，`currentTarget` 是绑定事件的元素，`eventPhase` 表示当前事件处于捕获、目标还是冒泡阶段，`bubbles` 表示是否冒泡，`timeStamp` 是事件发生的时间戳，`isTrusted` 用于判断是否是用户真实触发的事件。

**鼠标事件特有属性：** `clientX/clientY` 是相对于浏览器视口的坐标，`pageX/pageY` 是相对于整个页面的坐标（包含滚动距离），`screenX/screenY` 是相对于屏幕的坐标，`offsetX/offsetY` 是相对于目标元素的坐标。

**键盘事件特有属性：** `key` 表示按键的值，`code` 表示按键的物理位置，`altKey/ctrlKey/shiftKey/metaKey` 用于判断组合键是否按下。

**常用方法：** `preventDefault()` 阻止默认行为，`stopPropagation()` 阻止冒泡，`stopImmediatePropagation()` 立即停止传播并阻止同级监听器执行。

```javascript
element.addEventListener('click', function(event) {
  // 常用属性
  console.log(event.type);           // 事件类型：'click'
  console.log(event.target);         // 触发事件的元素（事件源）
  console.log(event.currentTarget);  // 绑定事件的元素（this）
  console.log(event.eventPhase);     // 事件阶段：1(捕获) 2(目标) 3(冒泡)
  console.log(event.bubbles);        // 是否冒泡
  console.log(event.cancelable);     // 是否可取消默认行为
  console.log(event.timeStamp);      // 事件发生的时间戳
  console.log(event.isTrusted);      // 是否是用户触发的事件

  // 鼠标事件特有属性
  console.log(event.clientX, event.clientY); // 相对于视口的坐标
  console.log(event.pageX, event.pageY);     // 相对于页面的坐标
  console.log(event.screenX, event.screenY); // 相对于屏幕的坐标
  console.log(event.offsetX, event.offsetY); // 相对于目标元素的坐标

  // 键盘事件特有属性
  console.log(event.key);      // 按键的值
  console.log(event.code);     // 按键的物理位置
  console.log(event.keyCode);  // 按键编码（已废弃）
  console.log(event.altKey);   // 是否按下Alt键
  console.log(event.ctrlKey);  // 是否按下Ctrl键
  console.log(event.shiftKey); // 是否按下Shift键
  console.log(event.metaKey);  // 是否按下Meta键（Mac的Command键）

  // 常用方法
  event.preventDefault();        // 阻止默认行为
  event.stopPropagation();       // 阻止冒泡
  event.stopImmediatePropagation(); // 立即停止传播
});
```

#### 题目2：event.target和event.currentTarget的区别？

**通俗概述：**
这是一个容易混淆的概念。简单说：target是"真正被点击的元素"，currentTarget是"绑定事件处理函数的元素"。就像你点击了一个按钮里的文字，target是那个文字，currentTarget是按钮。在事件委托中，target是子元素，currentTarget是父元素。

**答案：**

`event.target` 和 `event.currentTarget` 的核心区别在于指向的元素不同：

**event.target** 是实际触发事件的元素，也就是用户真正点击或操作的那个元素。它在事件流的整个传播过程中都指向同一个元素（事件源）。

**event.currentTarget** 是绑定事件监听器的元素，也就是当前正在执行事件处理函数的元素。它会随着事件流的传播而变化，在不同的元素上执行时会指向不同的元素。另外，`this` 关键字总是等于 `currentTarget`。

在事件委托场景中，当点击子元素时，`target` 指向被点击的子元素，而 `currentTarget` 指向绑定了事件监听器的父元素。这个区别在事件委托中非常关键，我们通常通过判断 `target` 来确定具体是哪个子元素被点击了。

```javascript
// HTML结构
// <div id="parent">
//   <button id="child">点击我</button>
// </div>

document.getElementById('parent').addEventListener('click', function(e) {
  console.log('target:', e.target.id);             // 'child'（点击的元素）
  console.log('currentTarget:', e.currentTarget.id); // 'parent'（绑定事件的元素）
  console.log('this:', this.id);                   // 'parent'（this === currentTarget）
});
```

### 4. 自定义事件
#### 热度：⭐⭐⭐⭐

#### 题目1：如何创建和触发自定义事件？

**通俗概述：**
除了点击、输入这些浏览器内置的事件，我们还可以创建自己的事件，比如"用户登录成功"、"数据加载完成"等。就像自己定义一个暗号，当某个条件满足时就"喊"这个暗号，其他地方听到这个暗号就执行相应的操作。这在组件间通信中非常有用。

**答案：**

**方法1：使用 CustomEvent（推荐）**
- 创建自定义事件时，第一个参数是事件名称，第二个参数是配置对象
- `detail` 属性用来传递自定义数据，可以是任意类型
- `bubbles` 控制事件是否冒泡（默认 false）
- `cancelable` 控制事件是否可以被取消（默认 false）
- 使用 `addEventListener` 监听自定义事件，通过 `e.detail` 获取传递的数据
- 使用 `dispatchEvent` 方法触发事件

```javascript
// 方法1：使用CustomEvent（推荐）
const customEvent = new CustomEvent('myEvent', {
  detail: { message: 'Hello World' }, // 自定义数据
  bubbles: true,                      // 是否冒泡
  cancelable: true                    // 是否可取消
});

// 监听自定义事件
element.addEventListener('myEvent', function(e) {
  console.log('自定义事件触发:', e.detail.message);
});

// 触发自定义事件
element.dispatchEvent(customEvent);

// 方法2：使用Event构造函数
const event = new Event('build', { bubbles: true });
element.dispatchEvent(event);

// 方法3：旧版本兼容写法
const event = document.createEvent('CustomEvent');
event.initCustomEvent('myEvent', true, true, { message: 'Hello' });
element.dispatchEvent(event);
```

#### 题目2：实现一个完整的事件发布订阅系统

**通俗概述：**
这是一个经典的设计模式题。发布订阅就像是"广播电台"，有人可以"订阅"（监听）某个频道，有人可以"发布"（广播）消息到这个频道。所有订阅了这个频道的人都能收到消息。这个模式在前端开发中非常常用，用于解耦不同模块间的通信。

**答案：**

**口述要点：**

发布订阅系统需要实现四个核心方法：

1. **on 方法（订阅）** - 接收事件名和回调函数，将回调函数存储到对应事件名的数组中，如果该事件名不存在则先创建空数组
2. **emit 方法（发布）** - 接收事件名和参数，找到该事件名对应的所有回调函数，依次执行并传入参数
3. **off 方法（取消订阅）** - 接收事件名和回调函数，如果没有传回调函数则删除该事件的所有监听器，否则只删除指定的回调函数
4. **once 方法（一次性订阅）** - 创建一个包装函数，在执行完原回调后立即调用 off 取消订阅

**实现要点：**
- 使用对象存储事件，key 为事件名，value 为回调函数数组
- 支持链式调用，每个方法都返回 this
- once 方法的关键是创建包装函数，执行后自动移除

```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }

  // 订阅事件
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
    return this; // 支持链式调用
  }

  // 触发事件
  emit(eventName, ...args) {
    if (!this.events[eventName]) {
      return this;
    }
    this.events[eventName].forEach(callback => {
      callback.apply(this, args);
    });
    return this;
  }

  // 取消订阅
  off(eventName, callback) {
    if (!this.events[eventName]) {
      return this;
    }
    if (!callback) {
      // 如果没有提供callback，移除所有监听器
      delete this.events[eventName];
    } else {
      this.events[eventName] = this.events[eventName].filter(
        cb => cb !== callback
      );
    }
    return this;
  }

  // 一次性订阅
  once(eventName, callback) {
    const onceWrapper = (...args) => {
      callback.apply(this, args);
      this.off(eventName, onceWrapper);
    };
    this.on(eventName, onceWrapper);
    return this;
  }
}

// 使用示例
const emitter = new EventEmitter();

emitter.on('login', (user) => {
  console.log(`${user} 登录了`);
});

emitter.once('logout', (user) => {
  console.log(`${user} 登出了`);
});

emitter.emit('login', '张三'); // 张三 登录了
emitter.emit('logout', '张三'); // 张三 登出了
emitter.emit('logout', '李四'); // 不会输出，因为是once
```

### 5. 事件性能优化
#### 热度：⭐⭐⭐⭐

#### 题目1：如何优化大量事件监听器的性能？

**通俗概述：**
当页面上有很多元素需要绑定事件时，如果每个都单独绑定会很消耗内存和性能。就像管理一个大公司，不能老板直接管每个员工，而是要分层管理。优化方法包括：事件委托（让父元素代理）、防抖节流（控制触发频率）、及时清理不用的事件等。

**答案：**

**口述要点：**

优化大量事件监听器有五种主要方法：

1. **事件委托** - 将事件监听器绑定在父元素上，通过 `event.target` 判断实际点击的子元素，而不是给每个子元素都绑定监听器，可以大幅减少监听器数量

2. **防抖（debounce）** - 在事件被触发 n 秒后再执行回调，如果 n 秒内又被触发则重新计时。适用于搜索框输入、窗口 resize 等场景

3. **节流（throttle）** - 规定时间内只执行一次回调函数。通过记录上次执行时间，只有超过指定间隔才执行。适用于滚动、鼠标移动等高频事件

4. **使用 passive 选项** - 在 addEventListener 的第三个参数中设置 `{ passive: true }`，告诉浏览器不会调用 preventDefault，可以优化滚动性能

5. **及时移除监听器** - 在组件销毁或不需要时使用 removeEventListener 移除监听器，避免内存泄漏。注意需要保存函数引用才能正确移除

**额外优化选项：**
- `once: true` - 监听器只执行一次后自动移除
- `capture: false` - 控制在捕获还是冒泡阶段触发

```javascript
// 1. 使用事件委托
// 不好的做法
for (let i = 0; i < 1000; i++) {
  document.getElementById(`item-${i}`).addEventListener('click', handleClick);
}

// 好的做法
document.getElementById('container').addEventListener('click', (e) => {
  if (e.target.classList.contains('item')) {
    handleClick(e);
  }
});

// 2. 使用防抖和节流
// 防抖
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 节流
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 3. 使用passive选项优化滚动性能
document.addEventListener('scroll', handleScroll, { passive: true });

// 4. 及时移除不需要的事件监听器
class Component {
  constructor() {
    this.handleClick = this.handleClick.bind(this);
  }

  mount() {
    document.addEventListener('click', this.handleClick);
  }

  unmount() {
    document.removeEventListener('click', this.handleClick);
  }

  handleClick(e) {
    // 处理点击
  }
}

// 5. 使用事件监听器选项
element.addEventListener('click', handler, {
  once: true,    // 只触发一次
  passive: true, // 不会调用preventDefault
  capture: false // 冒泡阶段触发
});
```

## 二、Vue事件机制 ⭐⭐⭐⭐⭐

### 1. Vue事件基础
#### 热度：⭐⭐⭐⭐⭐

#### 题目1：Vue中的事件绑定方式有哪些？

**通俗概述：**
Vue提供了多种绑定事件的方式，最常用的是@click这种语法糖。你可以直接在模板里写简单的表达式，也可以调用methods里的方法，还可以传参数。Vue让事件绑定变得非常直观和灵活，比原生JavaScript简洁很多。

**答案：**

Vue 中有五种主要的事件绑定方式：

第一种是**内联事件处理器**，可以直接在模板中写简单的 JavaScript 表达式，比如 `@click="count++"` 直接改变数据。

第二种是**方法事件处理器**，使用 `@click="increment"` 这种方式调用 methods 中定义的方法，Vue 会自动将原生事件对象作为第一个参数传入。

第三种是**带参数的方法调用**，像 `@click="say('hello')"` 这样可以在调用方法时传入自定义参数。

第四种是**访问原生 DOM 事件**，当需要同时传递自定义参数和原生事件对象时，可以使用 `$event` 变量，比如 `@click="warn('警告', $event)"`，这样在方法中就能同时接收到自定义参数和事件对象。

第五种是**多个方法处理器**，可以在一个事件中用逗号分隔调用多个方法，像 `@click="one($event), two($event)"` 这样依次执行多个处理函数。

另外，`@click` 是 `v-on:click` 的缩写形式，两者完全等价，但在实际开发中更推荐使用 `@` 这种简写方式。

**官方文档：**
- Vue 3: https://cn.vuejs.org/guide/essentials/event-handling.html
- Vue 2: https://v2.cn.vuejs.org/v2/guide/events.html

```vue
<template>
  <!-- 1. 内联事件处理器 -->
  <button @click="count++">增加</button>

  <!-- 2. 方法事件处理器 -->
  <button @click="increment">增加</button>

  <!-- 3. 带参数的方法调用 -->
  <button @click="say('hello')">打招呼</button>

  <!-- 4. 访问原生DOM事件 -->
  <button @click="warn('警告', $event)">警告</button>

  <!-- 5. 多个方法处理器 -->
  <button @click="one($event), two($event)">多个处理器</button>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    };
  },
  methods: {
    increment() {
      this.count++;
    },
    say(message) {
      alert(message);
    },
    warn(message, event) {
      if (event) {
        event.preventDefault();
      }
      alert(message);
    },
    one(event) {
      console.log('第一个处理器');
    },
    two(event) {
      console.log('第二个处理器');
    }
  }
};
</script>
```

#### 题目2：Vue事件修饰符有哪些？各自的作用是什么？

**通俗概述：**
Vue的事件修饰符是它的一大特色，让事件处理变得超级简单。比如想阻止冒泡，只需要加个.stop；想阻止默认行为，加个.prevent。这些修饰符可以串联使用，让代码变得非常简洁易读，不用在方法里写一堆preventDefault()这样的代码。

**答案：**

Vue事件修饰符分为四类：事件修饰符（.stop 阻止冒泡、.prevent 阻止默认行为、.capture 捕获阶段触发、.self 只在自身触发、.once 只触发一次、.passive 优化滚动性能）；按键修饰符（.enter、.tab、.delete、.esc、.space、.up、.down、.left、.right）；系统修饰键（.ctrl、.alt、.shift、.meta）；鼠标按钮修饰符（.left、.right、.middle）。这些修饰符可以串联使用，比如 `@click.stop.prevent` 同时阻止冒泡和默认行为，大大简化了事件处理代码。

**官方文档：**
- Vue 3: https://cn.vuejs.org/guide/essentials/event-handling.html#event-modifiers
- Vue 2: https://v2.cn.vuejs.org/v2/guide/events.html#事件修饰符
```vue
<template>
  <!-- 阻止事件冒泡 -->
  <div @click.stop="handleClick">阻止冒泡</div>

  <!-- 阻止默认行为 -->
  <form @submit.prevent="handleSubmit">提交</form>

  <!-- 事件捕获模式 -->
  <div @click.capture="handleClick">捕获阶段触发</div>

  <!-- 只触发自身，不包括子元素 -->
  <div @click.self="handleClick">只有点击自身才触发</div>

  <!-- 只触发一次 -->
  <button @click.once="handleClick">只触发一次</button>

  <!-- 滚动事件的passive模式 -->
  <div @scroll.passive="handleScroll">优化滚动性能</div>

  <!-- 修饰符可以串联 -->
  <a @click.stop.prevent="handleClick">阻止冒泡和默认行为</a>

  <!-- 按键修饰符 -->
  <input @keyup.enter="submit">
  <input @keyup.tab="next">
  <input @keyup.delete="remove">
  <input @keyup.esc="cancel">
  <input @keyup.space="space">
  <input @keyup.up="up">
  <input @keyup.down="down">
  <input @keyup.left="left">
  <input @keyup.right="right">

  <!-- 系统修饰键 -->
  <input @keyup.ctrl="handleCtrl">
  <input @keyup.alt="handleAlt">
  <input @keyup.shift="handleShift">
  <input @keyup.meta="handleMeta">

  <!-- 精确修饰符 -->
  <button @click.ctrl.exact="handleCtrlClick">只有Ctrl</button>

  <!-- 鼠标按钮修饰符 -->
  <button @click.left="handleLeftClick">左键</button>
  <button @click.right="handleRightClick">右键</button>
  <button @click.middle="handleMiddleClick">中键</button>
</template>
```

#### 题目3：Vue中的.sync修饰符是什么？Vue3中如何替代？

**通俗概述：**
.sync修饰符是Vue2中的一个语法糖，用于实现父子组件间的双向数据绑定。就像是父子之间的"对讲机"，子组件可以直接修改父组件的数据。Vue3中移除了.sync，改用更强大的v-model来实现，而且可以有多个v-model，功能更强大。

**答案：**
**官方文档：**
- Vue 3 v-model: https://cn.vuejs.org/guide/components/v-model.html
- Vue 2 .sync: https://v2.cn.vuejs.org/v2/guide/components-custom-events.html#sync-修饰符
```vue
<!-- Vue 2.x 中的.sync修饰符 -->
<template>
  <!-- 父组件 -->
  <ChildComponent :title.sync="pageTitle" />

  <!-- 等价于 -->
  <ChildComponent
    :title="pageTitle"
    @update:title="pageTitle = $event"
  />
</template>

<script>
// 子组件
export default {
  props: ['title'],
  methods: {
    updateTitle() {
      this.$emit('update:title', '新标题');
    }
  }
};
</script>

<!-- Vue 3.x 中使用v-model替代 -->
<template>
  <!-- 父组件 -->
  <ChildComponent v-model:title="pageTitle" />

  <!-- 多个v-model -->
  <ChildComponent
    v-model:title="pageTitle"
    v-model:content="pageContent"
  />
</template>

<script>
// Vue 3 子组件
export default {
  props: ['title', 'content'],
  emits: ['update:title', 'update:content'],
  methods: {
    updateTitle() {
      this.$emit('update:title', '新标题');
    },
    updateContent() {
      this.$emit('update:content', '新内容');
    }
  }
};
</script>
```

### 2. Vue组件通信

#### 题目1：Vue组件间通信方式有哪些？

**通俗概述：**
Vue组件间通信就像是不同房间的人要说话，有很多种方式：父子组件用props和emit（像父母和孩子对话）；跨级组件用provide/inject（像祖父母直接和孙子对话）；任意组件用EventBus（像广播）；全局状态用Vuex/Pinia（像公共告示板）。每种方式适用于不同的场景。

**答案：**
**官方文档：**
- Props/Emit: https://cn.vuejs.org/guide/components/props.html
- Provide/Inject: https://cn.vuejs.org/guide/components/provide-inject.html
- Pinia: https://pinia.vuejs.org/zh/
- Vuex: https://vuex.vuejs.org/zh/
```javascript
// 1. Props和$emit（父子组件）
// 父组件
<ChildComponent :message="parentMsg" @update="handleUpdate" />

// 子组件
props: ['message'],
methods: {
  sendToParent() {
    this.$emit('update', 'child data');
  }
}

// 2. provide/inject（跨级组件）
// 祖先组件
provide() {
  return {
    theme: this.theme,
    // 提供响应式数据
    user: computed(() => this.user)
  };
}

// 后代组件
inject: ['theme', 'user']

// 3. EventBus（任意组件）
// Vue2 - 使用Vue实例作为事件总线
import Vue from 'vue';
export const EventBus = new Vue();

// 发送事件
EventBus.$emit('user-login', userData);

// 监听事件
EventBus.$on('user-login', (data) => {
  console.log('用户登录:', data);
});

// 移除监听（组件销毁时记得移除）
EventBus.$off('user-login');

// Vue3 - 需要使用第三方库或自己实现
import mitt from 'mitt';
export const EventBus = mitt();

// 4. Vuex/Pinia（全局状态管理）
// Vuex
this.$store.dispatch('updateUser', userData);
this.$store.commit('SET_USER', userData);

// Pinia
import { useUserStore } from '@/stores/user';
const userStore = useUserStore();
userStore.updateUser(userData);

// 5. $attrs和$listeners（属性和事件透传）- Vue2
// 中间组件
<GrandChild v-bind="$attrs" v-on="$listeners" />

// Vue3中使用$attrs（包含了事件）
<GrandChild v-bind="$attrs" />

// 6. $parent/$children（直接访问）- 不推荐
this.$parent.parentMethod();
this.$children[0].childMethod();

// 7. ref（获取组件实例）
<ChildComponent ref="child" />
this.$refs.child.childMethod();

// 8. Vue3 Composition API
// 使用composables共享逻辑
// useUser.js
import { ref, computed } from 'vue';

export function useUser() {
  const user = ref(null);
  const isLoggedIn = computed(() => !!user.value);

  function login(userData) {
    user.value = userData;
  }

  function logout() {
    user.value = null;
  }

  return {
    user,
    isLoggedIn,
    login,
    logout
  };
}
```

#### 题目2：Vue2和Vue3的事件总线实现有什么区别？

**通俗概述：**
Vue2中可以直接用Vue实例作为事件总线，因为Vue实例自带$on、$emit等方法，就像内置了一个"广播电台"。但Vue3把这些方法移除了，需要自己实现或使用第三方库（如mitt）。这是Vue3为了减小体积和复杂度做的改变。

**答案：**
**官方文档：**
- Vue 2 实例方法: https://v2.cn.vuejs.org/v2/api/#实例方法-事件
- Vue 3 迁移指南: https://v3-migration.vuejs.org/zh/breaking-changes/events-api.html
- mitt库: https://github.com/developit/mitt

**Vue2内置事件总线：**
Vue2中可以直接使用Vue实例作为事件总线，因为Vue2实例提供了`$on`、`$emit`、`$off`、`$once`等方法。

```javascript
// Vue2 - 方法1：使用空的Vue实例作为事件总线
import Vue from 'vue';
export const EventBus = new Vue();

// 发送事件
EventBus.$emit('user-login', userData);

// 监听事件
EventBus.$on('user-login', (data) => {
  console.log('用户登录:', data);
});

// 移除监听
EventBus.$off('user-login');

// 一次性监听
EventBus.$once('user-logout', (data) => {
  console.log('用户登出:', data);
});

// Vue2 - 方法2：挂载到Vue原型上（全局事件总线）
// main.js
Vue.prototype.$bus = new Vue();

// 组件中使用
this.$bus.$emit('event-name', data);
this.$bus.$on('event-name', callback);

// 在组件销毁时移除监听
beforeDestroy() {
  this.$bus.$off('event-name');
}
```

**Vue3移除了事件API：**
Vue3中移除了`$on`、`$off`、`$once`等实例方法，因此需要自己实现或使用第三方库。

```javascript
// Vue3中没有内置的事件总线，需要自己实现或使用第三方库

// 方法1：使用mitt库
import mitt from 'mitt';

const emitter = mitt();

// 在main.js中全局注册
app.config.globalProperties.$emitter = emitter;

// 或者通过provide/inject
app.provide('emitter', emitter);

// 使用
// 发送事件
emitter.emit('custom-event', data);

// 监听事件
emitter.on('custom-event', (data) => {
  console.log(data);
});

// 移除监听
emitter.off('custom-event');

// 方法2：自定义事件总线
class EventBus {
  constructor() {
    this.events = {};
  }

  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  emit(event, ...args) {
    if (this.events[event]) {
      this.events[event].forEach(callback => {
        callback(...args);
      });
    }
  }

  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}

// 创建单例
export default new EventBus();

// 方法3：使用Composition API实现
import { ref, readonly } from 'vue';

function useEventBus() {
  const events = ref(new Map());

  function on(event, callback) {
    if (!events.value.has(event)) {
      events.value.set(event, []);
    }
    events.value.get(event).push(callback);
  }

  function emit(event, ...args) {
    if (events.value.has(event)) {
      events.value.get(event).forEach(callback => {
        callback(...args);
      });
    }
  }

  function off(event, callback) {
    if (events.value.has(event)) {
      const callbacks = events.value.get(event);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }

  return {
    on,
    emit,
    off,
    events: readonly(events)
  };
}

export default useEventBus();
```

### 3. Vue自定义指令中的事件

#### 面试回答思路：

当面试官问到Vue自定义指令时，建议按照以下结构回答：

**第一步：概念理解（说明你懂是什么）**
- 自定义指令是Vue提供的一种封装DOM操作的机制
- 用于直接操作DOM元素，实现可复用的DOM行为
- 本质是在元素的生命周期钩子中执行特定逻辑

**第二步：使用场景（说明你知道何时用）**
- 需要直接操作DOM时（如聚焦、拖拽、懒加载）
- 封装通用的DOM行为（如权限控制、埋点统计）
- 第三方库集成（如图表初始化、富文本编辑器）
- 性能优化场景（如图片懒加载、虚拟滚动）

**第三步：生命周期钩子（说明你掌握核心API）**
Vue2和Vue3的钩子不同，需要区分：

| Vue2 | Vue3 | 说明 |
|------|------|------|
| bind | beforeMount | 指令绑定到元素时 |
| inserted | mounted | 元素插入父节点时 |
| update | beforeUpdate | 组件更新前 |
| componentUpdated | updated | 组件更新后 |
| unbind | beforeUnmount/unmounted | 指令解绑时 |

**第四步：实际案例（说明你会用）**
准备2-3个常见案例，能够现场手写代码。

---

#### 题目1：如何在自定义指令中处理事件？

**通俗概述：**
自定义指令就像是给HTML元素添加"超能力"的工具。在指令中处理事件很常见，比如实现"点击外部关闭"、"长按触发"等功能。关键是在指令的生命周期钩子中绑定和解绑事件，确保不会造成内存泄漏。

**面试标准回答：**

我会从三个方面来说明如何在自定义指令中处理事件：

**1. 事件绑定时机**
- 在 `mounted`/`inserted` 钩子中绑定事件
- 在 `unmounted`/`unbind` 钩子中解绑事件
- 确保事件引用可以被正确移除（存储在元素上）

**2. 事件处理注意事项**
- 将事件处理函数存储在元素自身（`el._clickHandler`）
- 使用闭包保存指令参数和修饰符
- 避免重复绑定（在update时判断）
- 及时清理，防止内存泄漏

**3. 实际代码实现**

**官方文档：**
- Vue 3: https://cn.vuejs.org/guide/reusability/custom-directives.html
- Vue 2: https://v2.cn.vuejs.org/v2/guide/custom-directive.html

```javascript
// ========== Vue2 自定义指令 ==========
Vue.directive('click-outside', {
  bind(el, binding, vnode) {
    el.clickOutsideEvent = function(event) {
      // 检查点击是否在元素外部
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event);
      }
    };
    document.body.addEventListener('click', el.clickOutsideEvent);
  },
  unbind(el) {
    document.body.removeEventListener('click', el.clickOutsideEvent);
  }
});

// ========== Vue3 自定义指令 ==========
app.directive('click-outside', {
  mounted(el, binding) {
    el.clickOutsideEvent = function(event) {
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event);
      }
    };
    document.addEventListener('click', el.clickOutsideEvent);
  },
  unmounted(el) {
    document.removeEventListener('click', el.clickOutsideEvent);
  }
});

// 使用示例
<template>
  <div v-click-outside="handleClose">
    弹窗内容
  </div>
</template>

<script>
export default {
  methods: {
    handleClose() {
      console.log('点击了外部区域');
    }
  }
}
</script>
```

---

#### 题目2：常见自定义指令案例实现（必背）

**面试时建议准备以下几个经典案例，能够快速手写：**

**案例1：v-focus 自动聚焦指令**
```javascript
// Vue3 版本
app.directive('focus', {
  mounted(el) {
    el.focus();
  }
});

// 使用
<input v-focus />
```

**案例2：v-debounce 防抖指令**
```javascript
// Vue3 版本
app.directive('debounce', {
  mounted(el, binding) {
    const { value, arg } = binding;
    const delay = parseInt(arg) || 300;
    let timer = null;

    el._debounceHandler = function(...args) {
      if (timer) clearTimeout(timer);
      timer = setTimeout(() => {
        value.apply(this, args);
      }, delay);
    };

    el.addEventListener('click', el._debounceHandler);
  },
  unmounted(el) {
    el.removeEventListener('click', el._debounceHandler);
  }
});

// 使用：300ms 防抖
<button v-debounce:300="handleClick">提交</button>
```

**案例3：v-lazy 图片懒加载指令**
```javascript
// Vue3 版本
app.directive('lazy', {
  mounted(el, binding) {
    // 创建 IntersectionObserver
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // 图片进入视口
          el.src = binding.value;
          observer.unobserve(el);
        }
      });
    }, {
      rootMargin: '0px 0px 200px 0px' // 提前200px加载
    });

    // 开始观察
    observer.observe(el);

    // 保存observer以便清理
    el._lazyObserver = observer;
  },
  unmounted(el) {
    if (el._lazyObserver) {
      el._lazyObserver.disconnect();
    }
  }
});

// 使用
<img v-lazy="imageUrl" />
```

**案例4：v-longpress 长按指令**
```javascript
// Vue3 版本
app.directive('longpress', {
  mounted(el, binding) {
    const { value, arg } = binding;
    const duration = parseInt(arg) || 1000;
    let timer = null;

    const startHandler = () => {
      timer = setTimeout(() => {
        value();
      }, duration);
    };

    const cancelHandler = () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };

    el._longpressHandlers = { startHandler, cancelHandler };

    el.addEventListener('mousedown', startHandler);
    el.addEventListener('mouseup', cancelHandler);
    el.addEventListener('mouseleave', cancelHandler);
    // 移动端
    el.addEventListener('touchstart', startHandler);
    el.addEventListener('touchend', cancelHandler);
    el.addEventListener('touchcancel', cancelHandler);
  },
  unmounted(el) {
    const { startHandler, cancelHandler } = el._longpressHandlers || {};
    if (startHandler && cancelHandler) {
      el.removeEventListener('mousedown', startHandler);
      el.removeEventListener('mouseup', cancelHandler);
      el.removeEventListener('mouseleave', cancelHandler);
      el.removeEventListener('touchstart', startHandler);
      el.removeEventListener('touchend', cancelHandler);
      el.removeEventListener('touchcancel', cancelHandler);
    }
  }
});

// 使用：长按1500ms触发
<button v-longpress:1500="handleLongPress">长按我</button>
```

**案例5：v-permission 权限控制指令**
```javascript
// Vue3 版本
app.directive('permission', {
  mounted(el, binding) {
    const { value } = binding;
    const permissions = store.getters.permissions; // 假设从store获取权限

    if (!permissions.includes(value)) {
      // 无权限：移除元素
      el.parentNode?.removeChild(el);
      // 或者禁用元素
      // el.disabled = true;
      // el.style.display = 'none';
    }
  }
});

// 使用
<button v-permission="'admin:delete'">删除</button>
```

---

#### 题目3：自定义指令的参数和修饰符如何使用？

**通俗概述：**
指令可以接收动态参数、静态值和修饰符，就像 `v-on:click.prevent="handler"` 一样。理解如何获取和使用这些参数，能让指令更加灵活强大。

**答案：**

**binding 对象包含的属性：**
```javascript
app.directive('demo', {
  mounted(el, binding, vnode) {
    console.log(binding);
    // {
    //   value: 指令绑定的值,
    //   oldValue: 上一个值（仅update可用）,
    //   arg: 指令参数,
    //   modifiers: 修饰符对象,
    //   instance: 组件实例,
    //   dir: 指令定义对象
    // }
  }
});
```

**实战案例：带参数和修饰符的指令**
```javascript
// v-scroll:[direction].throttle.immediate="handler"
app.directive('scroll', {
  mounted(el, binding) {
    const { value, arg, modifiers } = binding;

    // 获取参数：direction
    const direction = arg || 'vertical'; // 'horizontal' 或 'vertical'

    // 获取修饰符
    const useThrottle = modifiers.throttle;
    const immediate = modifiers.immediate;

    let handler = value;

    // 根据修饰符处理逻辑
    if (useThrottle) {
      handler = throttle(value, 300);
    }

    if (immediate) {
      handler(); // 立即执行一次
    }

    // 根据参数选择监听目标
    const target = direction === 'horizontal'
      ? el.querySelector('.scroll-x')
      : el.querySelector('.scroll-y');

    el._scrollHandler = handler;
    target.addEventListener('scroll', handler);
  },
  unmounted(el) {
    const target = el.querySelector('.scroll-x, .scroll-y');
    target?.removeEventListener('scroll', el._scrollHandler);
  }
});

// 使用
<div v-scroll:vertical.throttle.immediate="onScroll">
  滚动容器
</div>
```

**动态指令值更新处理：**
```javascript
app.directive('color', {
  mounted(el, binding) {
    el.style.color = binding.value;
  },
  updated(el, binding) {
    // 只在值变化时更新
    if (binding.value !== binding.oldValue) {
      el.style.color = binding.value;
    }
  }
});

// 使用
<p v-color="currentColor">文本</p>
```

---

#### 题目4：自定义指令与组件的区别和选择？

**通俗概述：**
新手常困惑什么时候用指令，什么时候用组件。简单来说：指令用于DOM操作，组件用于UI封装。

**答案：**

**核心区别：**

| 特性 | 自定义指令 | 组件 |
|-----|----------|------|
| **主要用途** | DOM 操作 | UI 逻辑封装 |
| **模板** | 无 | 有 |
| **数据驱动** | 手动操作 DOM | 响应式自动更新 |
| **样式** | 需手动添加 | 可包含样式 |
| **复杂度** | 简单行为 | 复杂 UI |
| **生命周期** | 指令钩子 | 组件生命周期 |

**选择原则：**

```javascript
// ✅ 使用指令的场景
// 1. 纯 DOM 操作（聚焦、拖拽、滚动监听）
<input v-focus />

// 2. 不需要模板的简单行为
<div v-loading="isLoading"></div>

// 3. 全局通用的 DOM 增强
<img v-lazy="src" />

// 4. 第三方库集成
<div v-chart="chartOptions"></div>


// ✅ 使用组件的场景
// 1. 有 UI 结构和交互
<Modal v-model="visible">
  <template #header>标题</template>
  <p>内容</p>
</Modal>

// 2. 需要管理内部状态
<Pagination :total="100" @change="handleChange" />

// 3. 需要插槽和样式
<Card>
  <template #header>卡片头部</template>
  卡片内容
</Card>
```

**实际案例对比：**
```javascript
// ❌ 错误：用指令实现复杂 UI
app.directive('modal', {
  mounted(el, binding) {
    // 尝试用指令创建弹窗... 代码会很复杂且难维护
  }
});

// ✅ 正确：用组件实现
const Modal = {
  template: `
    <div class="modal" v-if="visible">
      <div class="modal-content">
        <slot></slot>
      </div>
    </div>
  `,
  props: ['visible']
};

// ✅ 正确：用指令做简单 DOM 操作
app.directive('click-outside', {
  mounted(el, binding) {
    // 简洁清晰
    el._handler = (e) => {
      if (!el.contains(e.target)) binding.value();
    };
    document.addEventListener('click', el._handler);
  },
  unmounted(el) {
    document.removeEventListener('click', el._handler);
  }
});
```

---

#### 题目5：自定义指令的常见坑和最佳实践？

**通俗概述：**
写指令容易，写好指令难。需要注意内存泄漏、性能问题、事件委托等细节。

**答案：**

**常见问题和解决方案：**

**1. 内存泄漏问题**
```javascript
// ❌ 错误：未清理事件监听
app.directive('bad-scroll', {
  mounted(el, binding) {
    window.addEventListener('scroll', binding.value);
    // 忘记保存引用，无法在 unmounted 中移除
  }
});

// ✅ 正确：保存引用并清理
app.directive('good-scroll', {
  mounted(el, binding) {
    el._scrollHandler = binding.value;
    window.addEventListener('scroll', el._scrollHandler);
  },
  unmounted(el) {
    window.removeEventListener('scroll', el._scrollHandler);
    delete el._scrollHandler; // 清理引用
  }
});
```

**2. 重复绑定问题**
```javascript
// ❌ 错误：updated 时重复绑定
app.directive('bad-click', {
  mounted(el, binding) {
    el.addEventListener('click', binding.value);
  },
  updated(el, binding) {
    // 每次更新都添加新监听器！内存泄漏！
    el.addEventListener('click', binding.value);
  }
});

// ✅ 正确：先移除再添加
app.directive('good-click', {
  mounted(el, binding) {
    this.bind(el, binding);
  },
  updated(el, binding) {
    if (binding.value !== binding.oldValue) {
      this.unbind(el, binding.oldValue);
      this.bind(el, binding);
    }
  },
  unmounted(el) {
    this.unbind(el);
  },
  bind(el, binding) {
    el._handler = binding.value;
    el.addEventListener('click', el._handler);
  },
  unbind(el) {
    if (el._handler) {
      el.removeEventListener('click', el._handler);
      delete el._handler;
    }
  }
});
```

**3. 性能优化**
```javascript
// ✅ 使用防抖/节流
app.directive('scroll', {
  mounted(el, binding) {
    const throttledHandler = throttle(binding.value, 200);
    el._scrollHandler = throttledHandler;
    el.addEventListener('scroll', throttledHandler, { passive: true });
  },
  unmounted(el) {
    el.removeEventListener('scroll', el._scrollHandler);
  }
});

// ✅ 使用 IntersectionObserver 代替 scroll 监听
app.directive('visible', {
  mounted(el, binding) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          binding.value(true);
        } else {
          binding.value(false);
        }
      });
    });
    observer.observe(el);
    el._observer = observer;
  },
  unmounted(el) {
    el._observer?.disconnect();
  }
});
```

**4. SSR 兼容性**
```javascript
// ✅ 检查浏览器环境
app.directive('clipboard', {
  mounted(el, binding) {
    // SSR 时 document 不存在
    if (typeof document === 'undefined') return;

    el._copyHandler = () => {
      navigator.clipboard.writeText(binding.value);
    };
    el.addEventListener('click', el._copyHandler);
  },
  unmounted(el) {
    if (typeof document === 'undefined') return;
    el.removeEventListener('click', el._copyHandler);
  }
});
```

**5. 使用命名空间避免冲突**
```javascript
// ✅ 使用命名空间存储数据
app.directive('my-directive', {
  mounted(el, binding) {
    if (!el._myDirective) {
      el._myDirective = {};
    }
    el._myDirective.handler = binding.value;
    el._myDirective.timer = null;
  }
});
```

**最佳实践总结：**
1. ✅ 始终在 `unmounted` 中清理资源
2. ✅ 将处理函数存储在元素上（`el._handler`）
3. ✅ 使用 `passive: true` 优化滚动性能
4. ✅ 使用 IntersectionObserver 代替 scroll 事件
5. ✅ 防抖/节流高频事件
6. ✅ 检查 SSR 环境
7. ✅ 避免在指令中修改组件状态（单向数据流）
8. ✅ 使用命名空间避免属性冲突

## 六、addEventListener 深入解析 ⭐⭐⭐⭐⭐

### 1. addEventListener 基础用法

#### 题目1：addEventListener 的基本语法和参数详解？

**通俗概述：**
addEventListener 是现代 Web 开发中绑定事件的标准方法，取代了旧的 onclick 方式。它就像是"订阅通知"，可以为同一个事件绑定多个处理函数，还可以精确控制事件是在捕获阶段还是冒泡阶段触发。掌握它的参数非常重要，尤其是第三个参数的各种选项。

**答案：**
**官方文档：**
- MDN: https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener

**基本语法：**
```javascript
target.addEventListener(type, listener, options);
target.addEventListener(type, listener, useCapture);
```

**参数详解：**

1. **type（事件类型）**：字符串，表示监听的事件类型
```javascript
// 常见事件类型
element.addEventListener('click', handler);      // 点击
element.addEventListener('input', handler);      // 输入
element.addEventListener('keydown', handler);    // 键盘按下
element.addEventListener('scroll', handler);     // 滚动
element.addEventListener('resize', handler);     // 窗口大小改变
element.addEventListener('load', handler);       // 加载完成
element.addEventListener('DOMContentLoaded', handler); // DOM 加载完成
```

2. **listener（事件处理函数）**：函数或实现了 EventListener 接口的对象
```javascript
// 方式1：函数引用
function handleClick(event) {
  console.log('clicked', event);
}
element.addEventListener('click', handleClick);

// 方式2：匿名函数
element.addEventListener('click', function(event) {
  console.log('clicked', this); // this 指向 element
});

// 方式3：箭头函数
element.addEventListener('click', (event) => {
  console.log('clicked'); // this 不指向 element
});

// 方式4：对象形式（需要实现 handleEvent 方法）
const handler = {
  handleEvent(event) {
    console.log('clicked from object', this); // this 指向 handler 对象
  }
};
element.addEventListener('click', handler);
```

3. **options（选项对象）或 useCapture（布尔值）**：

**useCapture（旧版写法）：**
```javascript
// 冒泡阶段触发（默认）
element.addEventListener('click', handler, false);

// 捕获阶段触发
element.addEventListener('click', handler, true);
```

**options 对象（推荐写法）：**
```javascript
element.addEventListener('click', handler, {
  capture: false,  // 是否在捕获阶段触发，默认 false
  once: false,     // 是否只触发一次，默认 false
  passive: false,  // 是否永不调用 preventDefault()，默认 false
  signal: null     // AbortSignal 对象，用于移除监听器
});
```

#### 题目2：addEventListener 的 options 参数详解和应用场景？

**通俗概述：**
options 参数是 addEventListener 的高级功能，每个选项都有特定的使用场景：capture 控制事件阶段，once 用于一次性事件，passive 优化滚动性能，signal 提供了新的移除事件方式。理解这些选项能让你的事件处理更高效、更优雅。

**答案：**

**1. capture - 控制事件触发阶段**
```javascript
// 场景：需要在捕获阶段拦截事件
document.addEventListener('click', (e) => {
  console.log('document 捕获');
  // 可以在这里做全局的权限检查、埋点等
  if (!hasPermission()) {
    e.stopPropagation(); // 阻止事件继续传播
    e.preventDefault();
    return;
  }
}, { capture: true });

element.addEventListener('click', () => {
  console.log('element 冒泡'); // 如果上面阻止了，这里不会执行
});
```

**2. once - 只触发一次**
```javascript
// 场景1：首次加载提示
window.addEventListener('scroll', () => {
  showTip('你可以滚动查看更多内容');
}, { once: true });

// 场景2：一次性按钮点击
button.addEventListener('click', async () => {
  await submitForm();
  console.log('表单已提交，此监听器已自动移除');
}, { once: true });

// 场景3：资源加载
image.addEventListener('load', () => {
  console.log('图片加载完成');
  // 自动移除监听器，不需要手动 removeEventListener
}, { once: true });

// 等价于传统写法（更简洁）
function handleLoad() {
  console.log('图片加载完成');
  image.removeEventListener('load', handleLoad);
}
image.addEventListener('load', handleLoad);
```

**3. passive - 性能优化（重要）**
```javascript
// 场景：优化滚动性能
// 问题：滚动事件中调用 preventDefault() 会阻塞渲染
element.addEventListener('touchstart', (e) => {
  // 浏览器不确定你是否会调用 preventDefault()
  // 必须等待事件处理完成才能开始滚动，导致卡顿
  e.preventDefault(); // 如果设置了 passive: true，这行会被忽略并警告
});

// 解决方案：使用 passive: true 告诉浏览器你不会阻止默认行为
element.addEventListener('touchstart', (e) => {
  // 浏览器知道你不会阻止默认行为，可以立即开始滚动
  console.log('触摸开始', e.touches[0]);
}, { passive: true });

// 实际应用：滚动监听
window.addEventListener('scroll', () => {
  const scrollTop = window.pageYOffset;
  // 只做监听，不阻止滚动
  updateScrollIndicator(scrollTop);
}, { passive: true });

// 注意：如果需要阻止默认行为，不能使用 passive
element.addEventListener('touchmove', (e) => {
  if (shouldPrevent) {
    e.preventDefault(); // 需要阻止默认行为，不能设置 passive: true
  }
});

// Chrome 默认行为
// Chrome 56+ 默认将 window、document、body 的 touchstart 和 touchmove 设置为 passive: true
// 如果要改变默认行为，必须显式设置
document.addEventListener('touchstart', handler, { passive: false });
```

**4. signal - 使用 AbortController 移除监听器**
```javascript
// 场景：批量移除多个事件监听器
const controller = new AbortController();
const { signal } = controller;

// 添加多个监听器
element.addEventListener('click', handler1, { signal });
element.addEventListener('mouseover', handler2, { signal });
element.addEventListener('mouseout', handler3, { signal });

// 一次性移除所有监听器
controller.abort();

// 实际应用：组件卸载时清理
class Component {
  constructor() {
    this.controller = new AbortController();
  }

  mount() {
    const { signal } = this.controller;

    window.addEventListener('resize', this.handleResize, { signal });
    window.addEventListener('scroll', this.handleScroll, { signal });
    document.addEventListener('click', this.handleClick, { signal });
  }

  unmount() {
    // 一行代码移除所有事件监听器
    this.controller.abort();
  }

  handleResize = () => { /* ... */ }
  handleScroll = () => { /* ... */ }
  handleClick = () => { /* ... */ }
}

// 在 React 中使用
function MyComponent() {
  useEffect(() => {
    const controller = new AbortController();
    const { signal } = controller;

    window.addEventListener('resize', handleResize, { signal });
    window.addEventListener('keydown', handleKeyDown, { signal });

    return () => {
      controller.abort(); // 组件卸载时自动清理
    };
  }, []);
}

// 场景：超时取消
const controller = new AbortController();
const { signal } = controller;

element.addEventListener('click', handler, { signal });

// 10秒后自动移除监听器
setTimeout(() => {
  controller.abort();
}, 10000);
```

**5. 组合使用多个选项**
```javascript
// 实际案例：优化的滚动到底部加载
function setupInfiniteScroll() {
  const controller = new AbortController();

  window.addEventListener('scroll',
    throttle(() => {
      if (isNearBottom()) {
        loadMoreData();
      }
    }, 200),
    {
      passive: true,  // 不阻止滚动，提升性能
      signal: controller.signal  // 支持取消
    }
  );

  return () => controller.abort();
}

// 实际案例：首次交互检测
function detectFirstInteraction() {
  const controller = new AbortController();
  const events = ['click', 'keydown', 'scroll', 'touchstart'];

  events.forEach(eventType => {
    document.addEventListener(
      eventType,
      () => {
        console.log('用户首次交互');
        sendAnalytics('first_interaction');
        controller.abort(); // 立即移除所有监听器
      },
      {
        once: true,      // 只触发一次
        passive: true,   // 性能优化
        capture: true,   // 捕获阶段触发，更早检测
        signal: controller.signal
      }
    );
  });
}
```

### 2. addEventListener vs 其他事件绑定方式

#### 题目1：addEventListener、onclick 和内联事件的区别？

**通俗概述：**
事件绑定有三种主要方式：内联事件（HTML 属性）、DOM0 级（onclick）和 DOM2 级（addEventListener）。它们就像三代技术：内联最原始但最不推荐；onclick 简单但有限制；addEventListener 最现代最强大。现代开发几乎都用 addEventListener。

**答案：**

**对比表格：**

| 特性 | 内联事件 | onclick (DOM0) | addEventListener (DOM2) |
|------|---------|----------------|------------------------|
| **写法** | `<button onclick="fn()">` | `element.onclick = fn` | `element.addEventListener('click', fn)` |
| **多个处理器** | ❌ 不支持 | ❌ 会被覆盖 | ✅ 支持多个 |
| **移除监听** | 修改 HTML | `element.onclick = null` | `removeEventListener` |
| **事件阶段** | 冒泡 | 冒泡 | 可选捕获/冒泡 |
| **this 指向** | window | element | element |
| **性能** | 一般 | 好 | 最好 |
| **维护性** | ❌ 差 | 一般 | ✅ 好 |
| **推荐程度** | ❌ 不推荐 | ⚠️ 简单场景可用 | ✅ 强烈推荐 |

**详细对比：**

```javascript
// 1. 内联事件（不推荐）
<button onclick="handleClick()">点击我</button>

// 问题：
// - HTML 和 JS 耦合，难以维护
// - 全局作用域污染
// - 不能绑定多个处理器
// - CSP 策略可能阻止内联脚本

// 2. DOM0 级事件（onclick）
const button = document.getElementById('btn');

button.onclick = function(e) {
  console.log('第一个处理器');
};

button.onclick = function(e) {
  console.log('第二个处理器'); // 会覆盖第一个
};

// 优点：
// - 简单直观
// - 兼容性好（所有浏览器）
// - this 自动指向元素

// 缺点：
// - 只能绑定一个处理器
// - 只能在冒泡阶段触发
// - 无法使用 once、passive 等选项

// 移除事件
button.onclick = null;

// 3. DOM2 级事件（addEventListener）- 推荐
const button = document.getElementById('btn');

button.addEventListener('click', function(e) {
  console.log('第一个处理器');
});

button.addEventListener('click', function(e) {
  console.log('第二个处理器'); // 都会执行
});

// 优点：
// - 可以绑定多个处理器
// - 可以选择捕获或冒泡阶段
// - 支持 options 参数（once、passive 等）
// - 更好的性能和内存管理
// - 符合 W3C 标准

// 移除事件（需要保存函数引用）
const handler = function(e) {
  console.log('clicked');
};
button.addEventListener('click', handler);
button.removeEventListener('click', handler);
```

**实际场景对比：**

```javascript
// 场景1：简单的单次点击处理
// onclick 写法
button.onclick = () => alert('Hello');

// addEventListener 写法（推荐）
button.addEventListener('click', () => alert('Hello'));

// 场景2：需要移除监听器
// onclick 写法
function handleClick() {
  console.log('clicked');
  button.onclick = null; // 移除
}
button.onclick = handleClick;

// addEventListener 写法（推荐）
function handleClick() {
  console.log('clicked');
  button.removeEventListener('click', handleClick);
}
button.addEventListener('click', handleClick);

// 或使用 once 选项（更简洁）
button.addEventListener('click', () => {
  console.log('clicked');
}, { once: true });

// 场景3：需要多个处理器
// onclick 无法实现（会覆盖）
button.onclick = () => console.log('1');
button.onclick = () => console.log('2'); // 只会执行这个

// addEventListener 完美支持
button.addEventListener('click', () => console.log('1'));
button.addEventListener('click', () => console.log('2'));
button.addEventListener('click', () => console.log('3'));
// 点击后输出：1 2 3

// 场景4：需要在捕获阶段拦截
// onclick 无法实现

// addEventListener 支持
document.addEventListener('click', (e) => {
  console.log('全局捕获');
  // 可以在这里做权限检查
  if (!authorized) {
    e.stopPropagation();
  }
}, { capture: true });

// 场景5：性能优化
// onclick 无优化选项

// addEventListener 支持 passive 优化
window.addEventListener('scroll', handleScroll, { passive: true });
```

### 3. addEventListener 常见问题和最佳实践

#### 题目1：addEventListener 使用中的常见陷阱和解决方案？

**通俗概述：**
addEventListener 虽然强大，但使用不当也会踩坑。最常见的问题是：忘记移除监听器导致内存泄漏、匿名函数无法移除、this 指向问题、重复绑定相同事件。了解这些陷阱和解决方案，能让你写出更健壮的代码。

**答案：**

**问题1：内存泄漏 - 忘记移除事件监听器**
```javascript
// ❌ 错误写法：组件销毁时未移除监听器
class Component {
  constructor() {
    window.addEventListener('resize', () => {
      this.handleResize();
    });
  }

  destroy() {
    // 忘记移除监听器，导致内存泄漏
  }
}

// ✅ 正确写法1：保存函数引用并移除
class Component {
  constructor() {
    this.handleResize = this.handleResize.bind(this);
    window.addEventListener('resize', this.handleResize);
  }

  destroy() {
    window.removeEventListener('resize', this.handleResize);
  }

  handleResize() {
    // 处理逻辑
  }
}

// ✅ 正确写法2：使用 AbortController
class Component {
  constructor() {
    this.controller = new AbortController();
    window.addEventListener('resize', () => {
      this.handleResize();
    }, { signal: this.controller.signal });
  }

  destroy() {
    this.controller.abort(); // 自动移除所有监听器
  }
}

// ✅ 正确写法3：React 中的最佳实践
function MyComponent() {
  useEffect(() => {
    const handleResize = () => {
      console.log('resized');
    };

    window.addEventListener('resize', handleResize);

    // 清理函数
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
}
```

**问题2：匿名函数无法移除**
```javascript
// ❌ 错误写法：匿名函数无法移除
element.addEventListener('click', () => {
  console.log('clicked');
});

// 无法移除，因为每次都是新的函数
element.removeEventListener('click', () => {
  console.log('clicked');
});

// ✅ 正确写法1：使用命名函数
function handleClick() {
  console.log('clicked');
}
element.addEventListener('click', handleClick);
element.removeEventListener('click', handleClick); // 可以移除

// ✅ 正确写法2：保存函数引用
const handleClick = () => {
  console.log('clicked');
};
element.addEventListener('click', handleClick);
element.removeEventListener('click', handleClick); // 可以移除

// ✅ 正确写法3：使用 once 选项（不需要手动移除）
element.addEventListener('click', () => {
  console.log('clicked');
}, { once: true });

// ✅ 正确写法4：使用 signal
const controller = new AbortController();
element.addEventListener('click', () => {
  console.log('clicked');
}, { signal: controller.signal });
controller.abort(); // 移除监听器
```

**问题3：this 指向问题**
```javascript
class MyClass {
  constructor() {
    this.value = 42;

    // ❌ 错误写法1：普通函数，this 指向 element
    element.addEventListener('click', function() {
      console.log(this.value); // undefined（this 是 element）
    });

    // ❌ 错误写法2：箭头函数无法移除
    element.addEventListener('click', () => {
      console.log(this.value); // 42（正确）
      // 但无法移除，因为是匿名函数
    });

    // ✅ 正确写法1：bind
    this.handleClick = this.handleClick.bind(this);
    element.addEventListener('click', this.handleClick);

    // ✅ 正确写法2：箭头函数属性
    element.addEventListener('click', this.handleClickArrow);
  }

  handleClick() {
    console.log(this.value); // 42
  }

  handleClickArrow = () => {
    console.log(this.value); // 42
  }

  destroy() {
    element.removeEventListener('click', this.handleClick);
    element.removeEventListener('click', this.handleClickArrow);
  }
}

// React 中的最佳实践
function MyComponent() {
  const [count, setCount] = useState(0);

  // ✅ 使用 useCallback 避免重复创建函数
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  return <button onClick={handleClick}>Count: {count}</button>;
}
```

**问题4：重复绑定相同的监听器**
```javascript
// ❌ 错误写法：重复绑定
for (let i = 0; i < 5; i++) {
  element.addEventListener('click', handleClick);
}
// 点击时 handleClick 会执行 5 次

// ✅ 正确写法1：检查是否已绑定
const boundListeners = new WeakMap();

function addListener(element, type, listener) {
  if (!boundListeners.has(element)) {
    boundListeners.set(element, new Set());
  }

  const listeners = boundListeners.get(element);
  const key = `${type}_${listener.name}`;

  if (!listeners.has(key)) {
    element.addEventListener(type, listener);
    listeners.add(key);
  }
}

// ✅ 正确写法2：移除旧的再添加新的
element.removeEventListener('click', handleClick);
element.addEventListener('click', handleClick);

// ✅ 正确写法3：使用标志位
if (!element._hasClickListener) {
  element.addEventListener('click', handleClick);
  element._hasClickListener = true;
}
```

**问题5：事件监听器中的闭包陷阱**
```javascript
// ❌ 错误写法：循环中的闭包问题
for (var i = 0; i < 3; i++) {
  buttons[i].addEventListener('click', function() {
    console.log(i); // 都输出 3
  });
}

// ✅ 正确写法1：使用 let
for (let i = 0; i < 3; i++) {
  buttons[i].addEventListener('click', function() {
    console.log(i); // 输出 0, 1, 2
  });
}

// ✅ 正确写法2：使用 IIFE
for (var i = 0; i < 3; i++) {
  (function(index) {
    buttons[index].addEventListener('click', function() {
      console.log(index); // 输出 0, 1, 2
    });
  })(i);
}

// ✅ 正确写法3：使用 data 属性
for (var i = 0; i < 3; i++) {
  buttons[i].dataset.index = i;
  buttons[i].addEventListener('click', function() {
    console.log(this.dataset.index); // 输出 0, 1, 2
  });
}

// ✅ 正确写法4：事件委托
container.addEventListener('click', function(e) {
  if (e.target.matches('button')) {
    const index = Array.from(buttons).indexOf(e.target);
    console.log(index);
  }
});
```

**问题6：异步操作中的事件对象**
```javascript
// ❌ 错误写法：异步中访问事件对象（React 16 及之前）
element.addEventListener('click', (e) => {
  setTimeout(() => {
    console.log(e.target); // 可能已被回收
    e.preventDefault(); // 可能报错
  }, 1000);
});

// ✅ 正确写法1：提前保存需要的属性
element.addEventListener('click', (e) => {
  const target = e.target;
  const value = e.target.value;

  setTimeout(() => {
    console.log(target, value); // 安全
  }, 1000);
});

// ✅ 正确写法2：立即调用 preventDefault
element.addEventListener('click', (e) => {
  e.preventDefault(); // 立即调用

  setTimeout(() => {
    // 异步操作
  }, 1000);
});
```

**最佳实践总结：**
```javascript
// 完整的事件监听器管理类
class EventManager {
  constructor() {
    this.listeners = new Map();
    this.controller = new AbortController();
  }

  // 添加监听器
  addEventListener(element, type, listener, options = {}) {
    // 合并 signal
    const mergedOptions = {
      ...options,
      signal: this.controller.signal
    };

    element.addEventListener(type, listener, mergedOptions);

    // 记录监听器（用于调试）
    const key = `${element}_${type}`;
    if (!this.listeners.has(key)) {
      this.listeners.set(key, []);
    }
    this.listeners.get(key).push(listener);
  }

  // 移除所有监听器
  removeAllListeners() {
    this.controller.abort();
    this.listeners.clear();
  }

  // 获取监听器数量（调试用）
  getListenerCount() {
    let count = 0;
    for (const listeners of this.listeners.values()) {
      count += listeners.length;
    }
    return count;
  }
}

// 使用示例
const eventManager = new EventManager();

// 添加监听器
eventManager.addEventListener(button, 'click', handleClick);
eventManager.addEventListener(window, 'resize', handleResize, { passive: true });
eventManager.addEventListener(input, 'input', handleInput, { once: true });

// 组件卸载时
eventManager.removeAllListeners();
```

// 使用
<div v-click-outside="handleClickOutside">
  点击外部关闭
</div>

// 复杂示例：长按指令
app.directive('longpress', {
  mounted(el, binding) {
    if (typeof binding.value !== 'function') {
      throw 'callback must be a function';
    }

    let pressTimer = null;
    const duration = binding.arg || 500; // 默认500ms

    const start = (e) => {
      if (e.type === 'click' && e.button !== 0) {
        return;
      }
      if (pressTimer === null) {
        pressTimer = setTimeout(() => {
          handler(e);
        }, duration);
      }
    };

    const cancel = () => {
      if (pressTimer !== null) {
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    };

    const handler = (e) => {
      binding.value(e);
    };

    el.addEventListener('mousedown', start);
    el.addEventListener('touchstart', start);
    el.addEventListener('click', cancel);
    el.addEventListener('mouseout', cancel);
    el.addEventListener('touchend', cancel);
    el.addEventListener('touchcancel', cancel);

    // 保存事件处理器以便卸载
    el._longpress = { start, cancel };
  },
  unmounted(el) {
    const { start, cancel } = el._longpress;
    el.removeEventListener('mousedown', start);
    el.removeEventListener('touchstart', start);
    el.removeEventListener('click', cancel);
    el.removeEventListener('mouseout', cancel);
    el.removeEventListener('touchend', cancel);
    el.removeEventListener('touchcancel', cancel);
  }
});

// 使用
<button v-longpress:1000="handleLongPress">长按我</button>
```

### 4. Vue事件相关原理

#### 题目1：Vue是如何实现事件绑定的？

**通俗概述：**
Vue在编译模板时会把@click这样的事件绑定转换成原生的addEventListener。就像是一个"翻译官"，把Vue的语法糖翻译成浏览器能理解的原生代码。Vue还会做一些优化，比如事件代理，让性能更好。

**答案：**

Vue事件绑定的实现分为三个阶段：首先在编译阶段，模板编译器会将 `@click` 等指令解析为事件处理器并存储在 VNode 的 props 中；然后在创建 VNode 时，将事件信息保存到虚拟节点上；最后在 patch 过程中，通过 `addEventListener` 将事件真正绑定到 DOM 元素上。Vue2 使用 WeakMap 管理事件监听器，在组件卸载时自动清理，避免内存泄漏。整个过程中，Vue 会处理事件修饰符并统一事件的管理。

```javascript
// Vue在编译模板时，会将@click等事件绑定转换为事件处理器

// 模板
<button @click="handleClick">点击</button>

// 编译后（简化版）
function render() {
  return h('button', {
    onClick: handleClick
  }, '点击');
}

// Vue内部处理流程
// 1. 编译阶段：将@click转换为onClick
// 2. 创建VNode时，将事件存储在VNode的props中
// 3. patch过程中，调用原生addEventListener绑定事件

// 事件代理实现（Vue2）
// Vue2使用事件代理优化性能
class EventManager {
  constructor() {
    this.events = {};
  }

  add(el, event, handler) {
    if (!this.events[event]) {
      this.events[event] = new WeakMap();
    }
    this.events[event].set(el, handler);
    el.addEventListener(event, handler);
  }

  remove(el, event) {
    if (this.events[event]) {
      const handler = this.events[event].get(el);
      if (handler) {
        el.removeEventListener(event, handler);
        this.events[event].delete(el);
      }
    }
  }
}
```

#### 题目2：Vue的v-model原理是什么？Vue2和Vue3的v-model有什么区别？

**通俗概述：**
v-model是Vue中实现双向数据绑定的语法糖，本质上是属性绑定+事件监听的组合。就像是"自动同步器"，当输入框的值变化时自动更新数据，当数据变化时自动更新输入框。Vue3对v-model做了增强，支持多个v-model，功能更强大。

**简洁答案（面试用）：**

**v-model原理：**
v-model是语法糖，在原生元素上等价于`:value`绑定加`@input`事件。在Vue2组件上是`:value`+`@input`，在Vue3组件上是`:modelValue`+`@update:modelValue`。

**Vue2和Vue3的主要区别：**
1. **prop和事件名不同**：Vue2用`value`和`input`，Vue3改为`modelValue`和`update:modelValue`
2. **多个v-model**：Vue2只支持一个v-model（其他需要用`.sync`），Vue3原生支持多个（如`v-model:title`、`v-model:content`）
3. **自定义方式**：Vue2需要配置`model`选项，Vue3直接使用`v-model:参数名`的形式
4. **修饰符**：Vue3新增支持自定义修饰符，可通过`modelModifiers` prop接收并处理

---

**详细答案：**
**官方文档：**
- Vue 3: https://cn.vuejs.org/guide/components/v-model.html
- Vue 2: https://v2.cn.vuejs.org/v2/guide/components.html#在组件上使用-v-model
- 迁移指南: https://v3-migration.vuejs.org/zh/breaking-changes/v-model.html

**v-model的基本原理：**
v-model是语法糖，本质是属性绑定和事件监听的结合。

```javascript
// 原始写法
<input :value="message" @input="message = $event.target.value">

// v-model写法
<input v-model="message">
```

**Vue2和Vue3的v-model区别：**

**1. 组件上的默认prop和事件名称不同**
```javascript
// Vue2
<CustomInput v-model="searchText" />
// 等价于
<CustomInput :value="searchText" @input="searchText = $event" />

// Vue3
<CustomInput v-model="searchText" />
// 等价于
<CustomInput :modelValue="searchText" @update:modelValue="searchText = $event" />
```

**2. 支持多个v-model绑定**
```vue
<!-- Vue2：只能有一个v-model，需要用.sync实现多个双向绑定 -->
<UserForm
  v-model="name"
  :age.sync="age"
  :email.sync="email"
/>

<!-- Vue3：支持多个v-model -->
<UserForm
  v-model:name="name"
  v-model:age="age"
  v-model:email="email"
/>
```

**3. 自定义v-model的实现方式**
```javascript
// Vue2 - 需要配置model选项
export default {
  model: {
    prop: 'checked',  // 自定义prop名称
    event: 'change'   // 自定义事件名称
  },
  props: {
    checked: Boolean
  },
  methods: {
    handleChange(e) {
      this.$emit('change', e.target.checked);
    }
  }
};

// Vue3 - 直接使用v-model:propName
export default {
  props: {
    modelValue: String,  // 默认
    title: String,       // 自定义
    content: String      // 自定义
  },
  emits: ['update:modelValue', 'update:title', 'update:content'],
  methods: {
    updateValue(value) {
      this.$emit('update:modelValue', value);
    },
    updateTitle(value) {
      this.$emit('update:title', value);
    },
    updateContent(value) {
      this.$emit('update:content', value);
    }
  }
};

// 使用
<MyComponent
  v-model="value"          // 默认的modelValue
  v-model:title="title"    // 自定义的title
  v-model:content="content" // 自定义的content
/>
```

**4. v-model修饰符的变化**
```javascript
// Vue2：内置修饰符
<input v-model.trim="text">
<input v-model.number="age">
<input v-model.lazy="msg">

// Vue3：除了内置修饰符，还支持自定义修饰符
<input v-model.trim="text">
<input v-model.number="age">
<input v-model.lazy="msg">
<CustomInput v-model.capitalize="text" />  // 自定义修饰符

// 组件内处理自定义修饰符（Vue3新特性）
export default {
  props: {
    modelValue: String,
    modelModifiers: {  // 接收修饰符
      default: () => ({})
    }
  },
  emits: ['update:modelValue'],
  methods: {
    emitValue(value) {
      if (this.modelModifiers.capitalize) {
        value = value.charAt(0).toUpperCase() + value.slice(1);
      }
      if (this.modelModifiers.lowercase) {
        value = value.toLowerCase();
      }
      this.$emit('update:modelValue', value);
    }
  }
};
```

**5. 完整对比示例**
```javascript
// === Vue2实现 ===
// 父组件
<template>
  <CustomInput v-model="text" :age.sync="age" />
</template>

// 子组件
export default {
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: String,
    age: Number
  },
  methods: {
    updateValue(val) {
      this.$emit('change', val);  // 对应v-model
    },
    updateAge(val) {
      this.$emit('update:age', val);  // 对应.sync
    }
  }
};

// === Vue3实现 ===
// 父组件
<template>
  <CustomInput v-model="text" v-model:age="age" />
</template>

// 子组件
export default {
  props: {
    modelValue: String,
    age: Number
  },
  emits: ['update:modelValue', 'update:age'],
  methods: {
    updateValue(val) {
      this.$emit('update:modelValue', val);
    },
    updateAge(val) {
      this.$emit('update:age', val);
    }
  }
};
```

**总结主要区别：**
1. **默认prop名称**：Vue2使用`value`，Vue3使用`modelValue`
2. **默认事件名称**：Vue2使用`input`，Vue3使用`update:modelValue`
3. **多个双向绑定**：Vue2需要v-model + .sync，Vue3统一使用v-model:xxx
4. **自定义修饰符**：Vue3新增支持自定义修饰符
5. **.sync修饰符**：Vue3中被移除，功能由v-model:xxx替代

## 三、React事件机制 ⭐⭐⭐⭐

### 1. React事件基础
#### 热度：⭐⭐⭐⭐

#### 题目1：React的合成事件是什么？为什么要使用合成事件？

**通俗概述：**
React的合成事件就像是给原生事件穿了一件"标准化外套"，让所有浏览器的事件行为都变得一致。就像不同品牌的手机都用同一个充电接口一样，React把不同浏览器的事件差异抹平了，还做了性能优化，所有事件都统一管理。

**答案：**
**官方文档：**
- React事件处理: https://zh-hans.react.dev/learn/responding-to-events
- 合成事件: https://zh-hans.react.dev/reference/react-dom/components/common#react-event-object
React的合成事件（SyntheticEvent）是React自己实现的一套事件系统，它是原生DOM事件的跨浏览器封装。

**为什么使用合成事件：**
1. **跨浏览器兼容性**：抹平不同浏览器的差异
2. **性能优化**：通过事件委托，所有事件都绑定到document上
3. **事件池**：React16及之前版本使用事件池复用事件对象
4. **更好的控制**：可以控制事件的触发顺序和行为

```javascript
class Component extends React.Component {
  handleClick = (e) => {
    // e是合成事件对象
    console.log(e); // SyntheticEvent
    console.log(e.nativeEvent); // 原生事件对象

    // 合成事件的属性和方法
    e.preventDefault(); // 阻止默认行为
    e.stopPropagation(); // 阻止冒泡
    e.persist(); // React16及之前，保持事件引用

    // 异步访问事件对象（React16及之前需要persist）
    setTimeout(() => {
      console.log(e.type); // React17+可以直接访问
    }, 1000);
  };

  render() {
    return <button onClick={this.handleClick}>点击</button>;
  }
}
```

#### 题目2：React事件绑定的几种方式？

**通俗概述：**
React中绑定事件有好几种写法，主要区别在于this指向和性能。类组件中推荐用箭头函数或在constructor中绑定，避免在render中绑定（会影响性能）。函数组件中就简单多了，直接定义函数即可，配合useCallback还能优化性能。

**答案：**

React事件绑定主要有四种方式。类组件中：第一种是在 constructor 中用 bind 绑定 this，性能最好；第二种是使用箭头函数定义方法，自动绑定 this，推荐使用；第三种是在 JSX 中使用 bind，但每次 render 都会创建新函数，不推荐；第四种是在 JSX 中使用箭头函数，同样每次创建新函数，不推荐。函数组件中更简单，直接定义函数或使用 useCallback 缓存函数引用即可，配合 React.memo 可以避免子组件不必要的重渲染。

**官方文档：**
- 事件处理: https://zh-hans.react.dev/learn/responding-to-events
- Hook文档: https://zh-hans.react.dev/reference/react/hooks
```javascript
class EventBinding extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };

    // 方式1：构造函数中绑定
    this.handleClick1 = this.handleClick1.bind(this);
  }

  // 方式1：普通方法 + constructor绑定
  handleClick1() {
    this.setState({ count: this.state.count + 1 });
  }

  // 方式2：箭头函数定义方法
  handleClick2 = () => {
    this.setState({ count: this.state.count + 1 });
  }

  // 方式3：普通方法
  handleClick3() {
    this.setState({ count: this.state.count + 1 });
  }

  // 方式4：带参数的方法
  handleClick4(param, e) {
    console.log(param, e);
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        {/* 方式1：constructor中绑定 */}
        <button onClick={this.handleClick1}>方式1</button>

        {/* 方式2：箭头函数方法 */}
        <button onClick={this.handleClick2}>方式2</button>

        {/* 方式3：render中bind（不推荐，每次render创建新函数） */}
        <button onClick={this.handleClick3.bind(this)}>方式3</button>

        {/* 方式4：render中箭头函数（不推荐，每次render创建新函数） */}
        <button onClick={() => this.handleClick3()}>方式4</button>

        {/* 方式5：传参 - 使用箭头函数 */}
        <button onClick={(e) => this.handleClick4('参数', e)}>方式5</button>

        {/* 方式6：传参 - 使用bind */}
        <button onClick={this.handleClick4.bind(this, '参数')}>方式6</button>
      </div>
    );
  }
}

// 函数组件中的事件绑定
function FunctionComponent() {
  const [count, setCount] = useState(0);

  // 直接定义事件处理函数
  const handleClick = () => {
    setCount(count + 1);
  };

  // 使用useCallback优化
  const handleClickMemo = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);

  // 带参数的事件处理
  const handleClickWithParam = (param) => {
    console.log(param);
    setCount(count + 1);
  };

  return (
    <div>
      <button onClick={handleClick}>点击</button>
      <button onClick={handleClickMemo}>优化的点击</button>
      <button onClick={() => handleClickWithParam('参数')}>带参数</button>
    </div>
  );
}
```

#### 题目3：React事件和原生事件的执行顺序？

**通俗概述：**
这是一个经典的面试题。React事件和原生事件混合使用时，执行顺序会让人困惑。简单记住：React17之前，原生事件先执行，然后才是React事件；React17之后，顺序更接近原生事件流。这个变化是为了让React事件行为更符合预期。

**答案：**

React事件和原生事件的执行顺序在不同版本有所不同。React17 及以后版本，执行顺序遵循原生事件流：先捕获阶段的原生事件，然后 React 捕获事件，接着 React 冒泡事件，再是冒泡阶段的原生事件，最后是 document 上的原生事件。而 React16 及之前版本，由于所有事件都绑定在 document 上，所以执行顺序是：元素上的原生事件全部执行完毕后，才会执行 React 合成事件。这个改变让 React17+ 的事件行为更接近原生，也解决了多版本 React 共存时的冲突问题。

```javascript
class EventOrder extends React.Component {
  componentDidMount() {
    // 原生事件绑定
    document.getElementById('native-btn').addEventListener('click', () => {
      console.log('原生事件（冒泡）');
    });

    document.getElementById('native-btn').addEventListener('click', () => {
      console.log('原生事件（捕获）');
    }, true);

    document.addEventListener('click', () => {
      console.log('document原生事件');
    });
  }

  handleReactClick = () => {
    console.log('React合成事件');
  };

  handleReactClickCapture = () => {
    console.log('React合成事件（捕获）');
  };

  render() {
    return (
      <button
        id="native-btn"
        onClick={this.handleReactClick}
        onClickCapture={this.handleReactClickCapture}
      >
        点击测试顺序
      </button>
    );
  }
}

// 点击按钮后的执行顺序（React 17+）：
// 1. 原生事件（捕获）
// 2. React合成事件（捕获）
// 3. React合成事件
// 4. 原生事件（冒泡）
// 5. document原生事件

// React 16及之前的执行顺序：
// 1. 原生事件（捕获）
// 2. 原生事件（冒泡）
// 3. React合成事件（捕获）
// 4. React合成事件
// 5. document原生事件
```

### 2. React事件系统原理

#### 题目1：React17对事件系统做了哪些改变？

**通俗概述：**
React17对事件系统做了重要升级：把事件绑定从document改到了根容器上，这样多个React版本可以共存不冲突；移除了事件池，事件对象不再复用，使用起来更直观。这些改变让React更好地与其他库集成，行为也更接近原生事件。

**答案：**

React17 对事件系统做了两个重大改变：第一，事件委托的位置从 document 改到了 ReactDOM.render 的根容器节点上，这样可以让多个不同版本的 React 应用共存而不会相互干扰，也更容易与其他框架集成；第二，移除了事件池机制，不再复用事件对象，这意味着开发者可以在异步代码中直接访问事件对象属性，不需要调用 `event.persist()` 方法。这些改变让 React 事件行为更接近原生 DOM 事件，降低了开发者的心智负担。

**官方文档：**
- React 17发布说明: https://zh-hans.react.dev/blog/2020/10/20/react-v17
- React 18升级指南: https://zh-hans.react.dev/blog/2022/03/08/react-18-upgrade-guide
```javascript
// React 16及之前
// 1. 所有事件都绑定在document上
// 2. 使用事件池复用事件对象

// React 17+的改变
// 1. 事件绑定在根容器上（ReactDOM.render的容器）
// 2. 移除事件池，事件对象不再复用
// 3. 更接近原生事件行为

// 示例：多个React版本共存
// React 16
ReactDOM.render(<App16 />, document.getElementById('root16'));
// 事件绑定在document上

// React 17+
ReactDOM.render(<App17 />, document.getElementById('root17'));
// 事件绑定在#root17上

// 好处：
// 1. 多版本React共存不会冲突
// 2. 更好的与第三方库集成
// 3. 事件处理更接近原生行为

// 事件委托示例
function EventDelegation() {
  useEffect(() => {
    // React 17+中，这个原生事件可能先于React事件执行
    document.addEventListener('click', (e) => {
      // 可以阻止React事件
      e.stopPropagation();
    });
  }, []);

  return (
    <div onClick={() => console.log('React事件')}>
      点击测试
    </div>
  );
}
```

#### 题目2：React事件池是什么？为什么React17移除了事件池？

**通俗概述：**
事件池是React16及之前版本的一个优化机制，就像"共享单车"一样，事件对象用完后会被回收再利用，避免频繁创建销毁。但这导致异步访问事件对象时会出问题，需要调用persist()保持引用。React17移除了事件池，因为现代浏览器性能提升了，这个优化的收益不大，反而增加了复杂度。

**答案：**

事件池是 React16 及之前版本的性能优化机制，合成事件对象在事件回调执行完后会被清空并放回事件池复用，避免频繁创建和销毁。但这导致在异步代码（如 setTimeout、Promise）中访问事件对象时，属性都会变成 null，必须调用 `event.persist()` 保持引用。React17 移除事件池的原因有四点：一是现代浏览器垃圾回收性能大幅提升，创建事件对象的成本降低；二是简化了开发者的心智模型，不用考虑异步访问的问题；三是减少了因误用导致的 bug；四是让行为更符合原生事件的预期。

```javascript
// React 16及之前的事件池机制
class EventPoolExample extends React.Component {
  handleClick = (e) => {
    // e是从事件池中取出的合成事件对象
    console.log(e.type); // 'click'

    // 异步访问会失败（事件对象被重置）
    setTimeout(() => {
      console.log(e.type); // null（React16）
    }, 1000);

    // 需要使用persist保持引用
    e.persist();
    setTimeout(() => {
      console.log(e.type); // 'click'
    }, 1000);
  };

  render() {
    return <button onClick={this.handleClick}>点击</button>;
  }
}

// React 17+移除事件池
function ModernEventExample() {
  const handleClick = (e) => {
    // 不需要persist，可以直接异步访问
    setTimeout(() => {
      console.log(e.type); // 'click'
    }, 1000);

    // 可以保存事件对象引用
    const eventType = e.type;
    fetchData().then(() => {
      console.log(eventType); // 'click'
    });
  };

  return <button onClick={handleClick}>点击</button>;
}

// 为什么移除事件池：
// 1. 现代浏览器性能提升，创建事件对象成本降低
// 2. 简化心智模型，避免persist的困惑
// 3. 更符合开发者预期，减少bug
// 4. 与原生事件行为一致
```

### 3. React事件优化

#### 题目1：如何优化React中的事件处理性能？

**通俗概述：**
React中事件处理的性能优化主要围绕"避免不必要的重新渲染"。就像避免重复做同样的工作一样：用useCallback缓存事件处理函数，用React.memo避免子组件无意义的重渲染，用事件委托处理大量元素，用防抖节流控制触发频率。

**答案：**
**官方文档：**
- useCallback: https://zh-hans.react.dev/reference/react/useCallback
- React.memo: https://zh-hans.react.dev/reference/react/memo
- useMemo: https://zh-hans.react.dev/reference/react/useMemo
```javascript
// 1. 使用useCallback缓存事件处理函数
function OptimizedComponent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  // 没有优化：每次render创建新函数
  const handleClick = () => {
    setCount(count + 1);
  };

  // 使用useCallback优化
  const handleClickOptimized = useCallback(() => {
    setCount(prev => prev + 1);
  }, []); // 依赖项为空，函数永不改变

  // 依赖特定值的处理函数
  const handleTextChange = useCallback((e) => {
    setText(e.target.value);
    // 处理依赖text的逻辑
  }, [text]);

  return (
    <div>
      <ExpensiveChild onClick={handleClickOptimized} />
      <input value={text} onChange={handleTextChange} />
    </div>
  );
}

// 2. 使用React.memo避免不必要的重渲染
const ExpensiveChild = React.memo(({ onClick }) => {
  console.log('ExpensiveChild render');
  return <button onClick={onClick}>点击</button>;
});

// 3. 事件委托优化大量元素
function ListWithDelegation() {
  const [items, setItems] = useState(Array.from({ length: 1000 }, (_, i) => ({
    id: i,
    text: `Item ${i}`
  })));

  // 使用事件委托而不是为每个item绑定事件
  const handleClick = useCallback((e) => {
    const id = e.target.dataset.id;
    if (id) {
      console.log('Clicked item:', id);
    }
  }, []);

  return (
    <ul onClick={handleClick}>
      {items.map(item => (
        <li key={item.id} data-id={item.id}>
          {item.text}
        </li>
      ))}
    </ul>
  );
}

// 4. 防抖和节流
function SearchComponent() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  // 使用useMemo创建防抖函数
  const debouncedSearch = useMemo(
    () => debounce((searchQuery) => {
      // 执行搜索
      fetchResults(searchQuery).then(setResults);
    }, 500),
    []
  );

  const handleSearch = useCallback((e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  }, [debouncedSearch]);

  return (
    <div>
      <input value={query} onChange={handleSearch} placeholder="搜索..." />
      <ResultsList results={results} />
    </div>
  );
}

// 5. 使用ref避免闭包陷阱
function TimerComponent() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  useEffect(() => {
    countRef.current = count;
  }, [count]);

  const handleClick = useCallback(() => {
    setTimeout(() => {
      // 使用ref获取最新值，避免闭包陷阱
      console.log('Current count:', countRef.current);
      setCount(countRef.current + 1);
    }, 3000);
  }, []); // 依赖项为空，但仍能获取最新的count

  return (
    <button onClick={handleClick}>Count: {count}</button>
  );
}
```

### 4. React事件相关Hooks

#### 题目1：如何使用Hooks处理复杂的事件逻辑？

**通俗概述：**
自定义Hook是封装复杂事件逻辑的最佳方式，就像把常用的功能打包成"工具箱"。比如监听鼠标移动、点击外部关闭、按键监听等，都可以封装成Hook，在不同组件中复用。关键是要正确处理事件的绑定和清理，避免内存泄漏。

**答案：**
**官方文档：**
- 自定义Hook: https://zh-hans.react.dev/learn/reusing-logic-with-custom-hooks
- useEffect: https://zh-hans.react.dev/reference/react/useEffect
- useRef: https://zh-hans.react.dev/reference/react/useRef
```javascript
// 1. 自定义Hook封装事件逻辑
function useEventListener(eventName, handler, element = window) {
  const savedHandler = useRef();

  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);

  useEffect(() => {
    const isSupported = element && element.addEventListener;
    if (!isSupported) return;

    const eventListener = (event) => savedHandler.current(event);
    element.addEventListener(eventName, eventListener);

    return () => {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}

// 使用示例
function Component() {
  const [coords, setCoords] = useState({ x: 0, y: 0 });

  useEventListener('mousemove', (e) => {
    setCoords({ x: e.clientX, y: e.clientY });
  });

  return <div>鼠标位置: {coords.x}, {coords.y}</div>;
}

// 2. useClickOutside Hook
function useClickOutside(ref, callback) {
  useEffect(() => {
    function handleClickOutside(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        callback();
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('touchstart', handleClickOutside);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('touchstart', handleClickOutside);
    };
  }, [ref, callback]);
}

// 使用示例
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef();

  useClickOutside(dropdownRef, () => {
    setIsOpen(false);
  });

  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(!isOpen)}>
        Toggle Dropdown
      </button>
      {isOpen && <div>Dropdown Content</div>}
    </div>
  );
}

// 3. useKeyPress Hook
function useKeyPress(targetKey, callback) {
  const [keyPressed, setKeyPressed] = useState(false);

  useEffect(() => {
    function downHandler({ key }) {
      if (key === targetKey) {
        setKeyPressed(true);
        callback && callback();
      }
    }

    function upHandler({ key }) {
      if (key === targetKey) {
        setKeyPressed(false);
      }
    }

    window.addEventListener('keydown', downHandler);
    window.addEventListener('keyup', upHandler);

    return () => {
      window.removeEventListener('keydown', downHandler);
      window.removeEventListener('keyup', upHandler);
    };
  }, [targetKey, callback]);

  return keyPressed;
}

// 使用示例
function Game() {
  const arrowUpPressed = useKeyPress('ArrowUp', () => {
    console.log('向上移动');
  });

  return (
    <div>
      {arrowUpPressed && <div>正在按上箭头</div>}
    </div>
  );
}

// 4. useLongPress Hook
function useLongPress(callback, delay = 500) {
  const [startLongPress, setStartLongPress] = useState(false);
  const timeout = useRef();

  useEffect(() => {
    if (startLongPress) {
      timeout.current = setTimeout(callback, delay);
    } else {
      timeout.current && clearTimeout(timeout.current);
    }

    return () => {
      timeout.current && clearTimeout(timeout.current);
    };
  }, [startLongPress, callback, delay]);

  return {
    onMouseDown: () => setStartLongPress(true),
    onMouseUp: () => setStartLongPress(false),
    onMouseLeave: () => setStartLongPress(false),
    onTouchStart: () => setStartLongPress(true),
    onTouchEnd: () => setStartLongPress(false),
  };
}

// 使用示例
function LongPressButton() {
  const longPressProps = useLongPress(() => {
    alert('长按触发！');
  }, 1000);

  return (
    <button {...longPressProps}>
      长按我
    </button>
  );
}
```

## 四、框架事件机制对比 ⭐⭐⭐

### 1. 三大框架事件机制对比
#### 热度：⭐⭐⭐

#### 题目1：Vue、React、原生JavaScript事件机制的区别？

**通俗概述：**
这是一个经典的对比题。简单说：原生JavaScript最基础但最灵活；Vue提供了丰富的事件修饰符，写起来很简洁；React用合成事件统一了浏览器差异，但语法相对复杂一些。每个都有自己的特色，选择哪个主要看项目需求和团队偏好。

**答案：**

| 特性 | 原生JavaScript | Vue | React |
|------|---------------|-----|-------|
| **事件系统** | 原生DOM事件 | 原生DOM事件 + 自定义事件 | 合成事件系统 |
| **事件绑定** | addEventListener | @事件名 或 v-on | on事件名（驼峰） |
| **事件委托** | 手动实现 | 自动（组件级） | 自动（根容器级） |
| **事件对象** | 原生Event | 原生Event | SyntheticEvent |
| **阻止冒泡** | stopPropagation() | .stop修饰符 | stopPropagation() |
| **阻止默认** | preventDefault() | .prevent修饰符 | preventDefault() |
| **事件修饰符** | 无 | 丰富的修饰符 | 无 |
| **自定义事件** | CustomEvent | $emit | 通过props回调 |

```javascript
// 原生JavaScript
element.addEventListener('click', (e) => {
  e.stopPropagation();
  e.preventDefault();
});

// Vue
<button @click.stop.prevent="handleClick">点击</button>

// React
<button onClick={(e) => {
  e.stopPropagation();
  e.preventDefault();
}}>点击</button>
```

#### 题目2：不同框架中实现相同功能的对比

**通俗概述：**
通过实际例子来对比不同框架的写法差异，比如实现一个删除确认功能。可以看出：原生JavaScript代码最多但最直接；Vue的模板语法很直观；React的函数式写法很现代。每种写法都有自己的优势，关键是要理解各自的设计思路。

**答案：**
```javascript
// 功能：实现一个带确认的删除按钮

// 原生JavaScript
document.getElementById('deleteBtn').addEventListener('click', function(e) {
  e.preventDefault();
  if (confirm('确定要删除吗？')) {
    deleteItem(this.dataset.id);
  }
});

// Vue 3
<template>
  <button @click="handleDelete" :data-id="item.id">
    删除
  </button>
</template>

<script>
export default {
  methods: {
    handleDelete(e) {
      if (confirm('确定要删除吗？')) {
        this.deleteItem(e.target.dataset.id);
      }
    }
  }
};
</script>

// React
function DeleteButton({ itemId, onDelete }) {
  const handleClick = useCallback(() => {
    if (confirm('确定要删除吗？')) {
      onDelete(itemId);
    }
  }, [itemId, onDelete]);

  return (
    <button onClick={handleClick}>
      删除
    </button>
  );
}

// 功能：实现输入框实时搜索（带防抖）

// 原生JavaScript
let timer = null;
const input = document.getElementById('search');
input.addEventListener('input', function(e) {
  clearTimeout(timer);
  timer = setTimeout(() => {
    search(e.target.value);
  }, 500);
});

// Vue 3 Composition API
<template>
  <input v-model="searchQuery" @input="debouncedSearch">
</template>

<script>
import { ref } from 'vue';
import { debounce } from 'lodash';

export default {
  setup() {
    const searchQuery = ref('');

    const debouncedSearch = debounce((e) => {
      search(e.target.value);
    }, 500);

    return {
      searchQuery,
      debouncedSearch
    };
  }
};
</script>

// React
function SearchInput() {
  const [query, setQuery] = useState('');

  const debouncedSearch = useMemo(
    () => debounce((value) => {
      search(value);
    }, 500),
    []
  );

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };

  return (
    <input value={query} onChange={handleChange} />
  );
}
```

### 2. 面试高频问题总结

#### 题目1：事件处理相关的常见性能问题和解决方案？

**通俗概述：**
事件处理中最常见的性能问题就是"太多"和"太频繁"：太多事件监听器会占用内存，太频繁的事件触发会卡顿页面。解决方案就是"合并"和"控制"：用事件委托合并多个监听器，用防抖节流控制触发频率，及时清理不用的监听器避免内存泄漏。

**答案：**
```javascript
// 1. 大量事件监听器问题
// 问题：为1000个按钮绑定点击事件
// 解决：使用事件委托

// 不好
for (let i = 0; i < 1000; i++) {
  document.getElementById(`btn-${i}`).addEventListener('click', handleClick);
}

// 好
document.getElementById('container').addEventListener('click', (e) => {
  if (e.target.matches('.btn')) {
    handleClick(e);
  }
});

// 2. 频繁触发的事件
// 问题：scroll、resize、mousemove等事件触发频率过高
// 解决：防抖或节流

// 防抖 - 适合输入框搜索
const debounce = (fn, delay) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  };
};

// 节流 - 适合滚动、拖拽
const throttle = (fn, delay) => {
  let last = 0;
  return (...args) => {
    const now = Date.now();
    if (now - last >= delay) {
      fn(...args);
      last = now;
    }
  };
};

// 3. 内存泄漏问题
// 问题：未及时移除事件监听器
// 解决：组件卸载时清理

// React
useEffect(() => {
  const handler = () => {};
  window.addEventListener('resize', handler);
  return () => {
    window.removeEventListener('resize', handler);
  };
}, []);

// Vue
export default {
  mounted() {
    window.addEventListener('resize', this.handleResize);
  },
  beforeUnmount() {
    window.removeEventListener('resize', this.handleResize);
  }
};

// 4. 事件处理函数重复创建
// 问题：每次render创建新函数
// 解决：使用useCallback或将函数定义在组件外

// React - 使用useCallback
const handleClick = useCallback(() => {
  // 处理逻辑
}, [dependencies]);

// Vue - 方法自动缓存
methods: {
  handleClick() {
    // 处理逻辑
  }
}
```

#### 题目2：跨框架的事件通信如何实现？

**通俗概述：**
当一个项目中同时使用多个框架时（比如Vue和React共存），它们之间的通信就需要用到"中间人"。最常用的方法是使用原生的CustomEvent或者全局事件总线，就像不同语言的人通过翻译官交流一样。还可以用PostMessage进行iframe间的通信。

**答案：**
```javascript
// 使用原生CustomEvent实现跨框架通信

// 事件总线
class CrossFrameworkEventBus {
  constructor() {
    this.element = document.createElement('div');
    document.body.appendChild(this.element);
  }

  emit(eventName, data) {
    const event = new CustomEvent(eventName, {
      detail: data,
      bubbles: true,
      cancelable: true
    });
    this.element.dispatchEvent(event);
  }

  on(eventName, callback) {
    this.element.addEventListener(eventName, (e) => {
      callback(e.detail);
    });
  }

  off(eventName, callback) {
    this.element.removeEventListener(eventName, callback);
  }
}

const globalBus = new CrossFrameworkEventBus();

// React组件中使用
function ReactComponent() {
  useEffect(() => {
    const handler = (data) => {
      console.log('React received:', data);
    };

    globalBus.on('vue-message', handler);

    return () => {
      globalBus.off('vue-message', handler);
    };
  }, []);

  const sendMessage = () => {
    globalBus.emit('react-message', { from: 'React' });
  };

  return <button onClick={sendMessage}>Send from React</button>;
}

// Vue组件中使用
export default {
  mounted() {
    globalBus.on('react-message', this.handleReactMessage);
  },
  beforeUnmount() {
    globalBus.off('react-message', this.handleReactMessage);
  },
  methods: {
    handleReactMessage(data) {
      console.log('Vue received:', data);
    },
    sendMessage() {
      globalBus.emit('vue-message', { from: 'Vue' });
    }
  }
};

// 使用PostMessage进行iframe通信
// 父窗口
window.addEventListener('message', (e) => {
  if (e.origin !== 'https://trusted-origin.com') return;
  console.log('Received:', e.data);
});

iframe.contentWindow.postMessage({ type: 'HELLO' }, '*');

// 子窗口（iframe）
window.addEventListener('message', (e) => {
  if (e.data.type === 'HELLO') {
    e.source.postMessage({ type: 'RESPONSE' }, e.origin);
  }
});
```

## 五、经典面试题实战 ⭐⭐⭐⭐⭐

### 题目1：实现一个完整的拖拽功能 ⭐⭐⭐⭐⭐

**通俗概述：**
拖拽功能是前端开发中的经典需求，考查对鼠标事件、坐标计算、状态管理的综合运用。关键点是：监听mousedown开始拖拽，mousemove更新位置，mouseup结束拖拽。还要考虑触摸设备的兼容性。React中可以封装成自定义Hook，让逻辑更清晰。

**答案：**
```javascript
// 原生JavaScript实现
class Draggable {
  constructor(element) {
    this.element = element;
    this.isDragging = false;
    this.currentX = 0;
    this.currentY = 0;
    this.initialX = 0;
    this.initialY = 0;
    this.xOffset = 0;
    this.yOffset = 0;

    this.init();
  }

  init() {
    this.element.addEventListener('mousedown', this.dragStart.bind(this));
    document.addEventListener('mousemove', this.drag.bind(this));
    document.addEventListener('mouseup', this.dragEnd.bind(this));

    // 触摸事件支持
    this.element.addEventListener('touchstart', this.dragStart.bind(this));
    document.addEventListener('touchmove', this.drag.bind(this));
    document.addEventListener('touchend', this.dragEnd.bind(this));
  }

  dragStart(e) {
    e.preventDefault();

    if (e.type === 'touchstart') {
      this.initialX = e.touches[0].clientX - this.xOffset;
      this.initialY = e.touches[0].clientY - this.yOffset;
    } else {
      this.initialX = e.clientX - this.xOffset;
      this.initialY = e.clientY - this.yOffset;
    }

    if (e.target === this.element) {
      this.isDragging = true;
      this.element.classList.add('dragging');
    }
  }

  drag(e) {
    if (!this.isDragging) return;

    e.preventDefault();

    if (e.type === 'touchmove') {
      this.currentX = e.touches[0].clientX - this.initialX;
      this.currentY = e.touches[0].clientY - this.initialY;
    } else {
      this.currentX = e.clientX - this.initialX;
      this.currentY = e.clientY - this.initialY;
    }

    this.xOffset = this.currentX;
    this.yOffset = this.currentY;

    this.setTranslate(this.currentX, this.currentY);
  }

  dragEnd(e) {
    this.initialX = this.currentX;
    this.initialY = this.currentY;
    this.isDragging = false;
    this.element.classList.remove('dragging');
  }

  setTranslate(xPos, yPos) {
    this.element.style.transform = `translate(${xPos}px, ${yPos}px)`;
  }
}

// React Hook实现
function useDraggable() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

  const handleMouseDown = useCallback((e) => {
    setIsDragging(true);
    setDragStart({
      x: e.clientX - position.x,
      y: e.clientY - position.y
    });
  }, [position]);

  useEffect(() => {
    if (!isDragging) return;

    const handleMouseMove = (e) => {
      setPosition({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y
      });
    };

    const handleMouseUp = () => {
      setIsDragging(false);
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging, dragStart]);

  return {
    position,
    isDragging,
    handleMouseDown,
    style: {
      transform: `translate(${position.x}px, ${position.y}px)`,
      cursor: isDragging ? 'grabbing' : 'grab'
    }
  };
}

// 使用
function DraggableComponent() {
  const { position, isDragging, handleMouseDown, style } = useDraggable();

  return (
    <div
      onMouseDown={handleMouseDown}
      style={style}
      className={isDragging ? 'dragging' : ''}
    >
      拖拽我
    </div>
  );
}
```

### 题目2：实现一个图片懒加载功能

**通俗概述：**
图片懒加载是优化页面性能的重要手段，只有当图片进入视口时才开始加载。现代做法是使用IntersectionObserver API，比传统的scroll事件监听性能更好。核心思路是：观察图片元素，当进入可视区域时，将data-src赋值给src属性开始加载。

**答案：**
```javascript
// 使用IntersectionObserver实现
class LazyLoad {
  constructor(options = {}) {
    this.options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1,
      ...options
    };

    this.observer = null;
    this.init();
  }

  init() {
    if (!('IntersectionObserver' in window)) {
      // 降级处理
      this.loadAllImages();
      return;
    }

    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      this.options
    );

    this.observeImages();
  }

  observeImages() {
    const images = document.querySelectorAll('[data-src]');
    images.forEach(img => this.observer.observe(img));
  }

  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadImage(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }

  loadImage(img) {
    const src = img.dataset.src;
    if (!src) return;

    // 创建新图片对象预加载
    const tempImg = new Image();
    tempImg.onload = () => {
      img.src = src;
      img.classList.add('loaded');
      delete img.dataset.src;
    };
    tempImg.onerror = () => {
      img.classList.add('error');
    };
    tempImg.src = src;
  }

  loadAllImages() {
    const images = document.querySelectorAll('[data-src]');
    images.forEach(img => this.loadImage(img));
  }

  destroy() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}

// React组件实现
function LazyImage({ src, placeholder, alt, ...props }) {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [isLoading, setIsLoading] = useState(true);
  const imgRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = new Image();
            img.onload = () => {
              setImageSrc(src);
              setIsLoading(false);
            };
            img.src = src;
            observer.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => {
      if (imgRef.current) {
        observer.unobserve(imgRef.current);
      }
    };
  }, [src]);

  return (
    <img
      ref={imgRef}
      src={imageSrc}
      alt={alt}
      className={isLoading ? 'loading' : 'loaded'}
      {...props}
    />
  );
}

// Vue 3指令实现
app.directive('lazy', {
  mounted(el, binding) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = binding.value;
          img.classList.add('loaded');
          observer.unobserve(img);
        }
      });
    });

    observer.observe(el);
    el._observer = observer;
  },
  unmounted(el) {
    if (el._observer) {
      el._observer.disconnect();
      delete el._observer;
    }
  }
});

// 使用
<img v-lazy="imageSrc" alt="Lazy loaded image">
```

### 题目3：实现一个虚拟滚动列表

**通俗概述：**
虚拟滚动是处理大量数据列表的经典方案，核心思想是"只渲染可见的部分"。就像看书一样，你只需要看当前这一页，不需要把整本书都摊开。通过监听滚动事件，动态计算哪些项目应该显示，大大提升了性能。

**答案：**
```javascript
// React实现虚拟滚动
function VirtualList({ items, itemHeight, containerHeight, renderItem }) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // 计算可见区域的起始和结束索引
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    items.length - 1,
    Math.floor((scrollTop + containerHeight) / itemHeight)
  );

  // 可见项
  const visibleItems = items.slice(startIndex, endIndex + 1);

  // 总高度
  const totalHeight = items.length * itemHeight;

  // 偏移量
  const offsetY = startIndex * itemHeight;

  const handleScroll = (e) => {
    setScrollTop(e.target.scrollTop);
  };

  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: 'auto',
        position: 'relative'
      }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div
          style={{
            transform: `translateY(${offsetY}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0
          }}
        >
          {visibleItems.map((item, index) => (
            <div
              key={startIndex + index}
              style={{ height: itemHeight }}
            >
              {renderItem(item, startIndex + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// 使用示例
function App() {
  const items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    text: `Item ${i}`
  }));

  return (
    <VirtualList
      items={items}
      itemHeight={50}
      containerHeight={500}
      renderItem={(item) => (
        <div style={{ padding: '10px', borderBottom: '1px solid #ccc' }}>
          {item.text}
        </div>
      )}
    />
  );
}
```

---

## 📚 核心知识点速记（10分钟复习版）

### 1. 事件流（必背）⭐⭐⭐⭐⭐
```
✅ 三个阶段：捕获阶段 → 目标阶段 → 冒泡阶段
✅ 传播路径：window → document → html → body → ... → 目标元素 → ... → body → html → document → window
✅ 默认阶段：addEventListener 默认在冒泡阶段（第三个参数false）
✅ 记忆口诀：外到内（捕获）→ 到达目标 → 内到外（冒泡）
```

### 2. 事件委托（必背）⭐⭐⭐⭐⭐
```
✅ 定义：将事件监听器绑定在父元素上，利用事件冒泡处理子元素事件
✅ 原理：事件冒泡 + event.target判断
✅ 优点：父代子、减内存、动态绑（新增子元素自动有事件）
✅ 缺点：不支持不冒泡事件（focus、blur、load、scroll等）
✅ 实现：parent.addEventListener → 判断e.target → 执行对应逻辑
```

### 3. 事件对象关键属性（必背）⭐⭐⭐⭐⭐
```
✅ target：触发事件的元素（真正被点击的）
✅ currentTarget：绑定监听器的元素（this指向它）
✅ type：事件类型（'click'、'input'等）
✅ preventDefault()：阻止默认行为（如链接跳转）
✅ stopPropagation()：阻止冒泡
✅ stopImmediatePropagation()：立即停止传播（同级监听器也不执行）
```

### 4. addEventListener 核心参数（必背）⭐⭐⭐⭐⭐
```
✅ 语法：addEventListener(type, listener, options)
✅ capture：false冒泡（默认）、true捕获
✅ once：true只触发一次（自动移除）
✅ passive：true不调用preventDefault（优化滚动性能）
✅ signal：AbortSignal对象（批量移除事件）
```

### 5. 自定义事件（重要）⭐⭐⭐⭐
```
✅ 创建：new CustomEvent('事件名', { detail: 数据, bubbles: true })
✅ 监听：addEventListener('事件名', handler)
✅ 触发：dispatchEvent(事件对象)
✅ 记忆：创建→监听→触发（三步走）
```

### 6. Vue事件修饰符（必背）⭐⭐⭐⭐⭐
```
✅ .stop：阻止冒泡
✅ .prevent：阻止默认行为
✅ .capture：捕获阶段触发
✅ .self：只在自身触发（不包括子元素）
✅ .once：只触发一次
✅ .passive：优化滚动性能
✅ 按键修饰符：.enter、.tab、.delete、.esc、.space等
✅ 系统修饰符：.ctrl、.alt、.shift、.meta
```

### 7. React事件特点（重要）⭐⭐⭐⭐
```
✅ 合成事件：统一包装原生事件，抹平浏览器差异
✅ 驼峰命名：onClick、onChange（原生是onclick、onchange）
✅ 事件委托：React 17前绑定到document，React 17+绑定到root容器
✅ 事件池：React 16及之前版本使用事件池（17+移除）
✅ this绑定：类组件需要手动绑定this（使用箭头函数或bind）
```

### 8. 性能优化（重要）⭐⭐⭐⭐
```
✅ 事件委托：减少监听器数量
✅ 防抖（debounce）：延迟执行，适合input搜索
✅ 节流（throttle）：固定频率执行，适合scroll、resize
✅ passive: true：优化滚动、触摸事件
✅ 及时移除：组件卸载时移除事件监听器
```

---

## 🔥 高频面试题 TOP 15

### 第1题：什么是事件流？事件流的三个阶段？⭐⭐⭐⭐⭐
**快速答案：**
- 事件流是事件在DOM树中的传播顺序
- 三个阶段：捕获阶段（外→内）、目标阶段（到达目标）、冒泡阶段（内→外）
- 口诀：**捕获目标冒泡**

### 第2题：什么是事件委托？有什么优缺点？⭐⭐⭐⭐⭐
**快速答案：**
- 将事件绑定在父元素上，利用事件冒泡处理子元素事件
- 优点：父代子、减内存、动态绑
- 缺点：不支持不冒泡事件、可能误触发
- 原理：事件冒泡 + event.target判断

### 第3题：event.target 和 event.currentTarget 的区别？⭐⭐⭐⭐⭐
**快速答案：**
- target：触发事件的元素（真正被点击的）
- currentTarget：绑定监听器的元素（this指向它）
- 口诀：**target是源、currentTarget是绑定者**

### 第4题：addEventListener 的第三个参数有哪些选项？⭐⭐⭐⭐⭐
**快速答案：**
- options对象：{ capture, once, passive, signal }
- capture：false冒泡（默认）、true捕获
- once：true只触发一次
- passive：true不调用preventDefault（优化滚动）
- signal：AbortSignal（批量移除）

### 第5题：如何阻止事件冒泡和默认行为？⭐⭐⭐⭐⭐
**快速答案：**
```javascript
e.stopPropagation();           // 阻止冒泡
e.preventDefault();            // 阻止默认行为
e.stopImmediatePropagation();  // 立即停止（同级也不执行）
return false;                  // onclick中有效，addEventListener中无效
```

### 第6题：Vue事件修饰符有哪些？⭐⭐⭐⭐⭐
**快速答案：**
- .stop（阻止冒泡）、.prevent（阻止默认）、.capture（捕获阶段）
- .self（只自身触发）、.once（只一次）、.passive（优化滚动）
- 按键：.enter、.tab、.delete、.esc、.space
- 系统：.ctrl、.alt、.shift、.meta

### 第7题：React合成事件是什么？为什么使用？⭐⭐⭐⭐
**快速答案：**
- 合成事件是React对原生事件的跨浏览器封装
- 优点：跨浏览器兼容、性能优化（事件委托）、事件池复用
- React 17前绑定到document，17+绑定到root容器

### 第8题：如何实现自定义事件？⭐⭐⭐⭐
**快速答案：**
```javascript
// 创建
const event = new CustomEvent('myEvent', { detail: { data } });
// 监听
element.addEventListener('myEvent', handler);
// 触发
element.dispatchEvent(event);
```

### 第9题：防抖和节流的区别？如何实现？⭐⭐⭐⭐⭐
**快速答案：**
- 防抖：延迟执行，频繁触发只执行最后一次（input搜索）
- 节流：固定频率执行（scroll、resize）
- 口诀：**防抖等待、节流间隔**

### 第10题：addEventListener 和 onclick 的区别？⭐⭐⭐⭐
**快速答案：**
- addEventListener：可绑定多个、支持捕获/冒泡、支持options
- onclick：只能绑定一个、只支持冒泡、会被覆盖
- 推荐：**现代开发统一使用addEventListener**

### 第11题：哪些事件不支持冒泡？⭐⭐⭐⭐
**快速答案：**
- focus、blur（使用focusin、focusout代替）
- load、unload、error
- mouseenter、mouseleave（使用mouseover、mouseout代替）
- scroll、resize（虽然有冒泡行为但不常用）

### 第12题：如何实现事件委托？⭐⭐⭐⭐⭐
**快速答案：**
```javascript
parent.addEventListener('click', (e) => {
  if (e.target.matches('.item')) {
    // 处理.item的点击
  }
});
```

### 第13题：Vue组件通信方式有哪些？⭐⭐⭐⭐⭐
**快速答案：**
- 父→子：props
- 子→父：$emit
- 跨级：provide/inject、Vuex、Pinia
- 兄弟：事件总线、Vuex

### 第14题：React如何解决事件中this指向问题？⭐⭐⭐⭐
**快速答案：**
```javascript
// 方法1：箭头函数（推荐）
handleClick = () => {}

// 方法2：bind绑定
constructor() { this.handleClick = this.handleClick.bind(this); }

// 方法3：箭头函数调用
<button onClick={(e) => this.handleClick(e)}>
```

### 第15题：passive选项有什么用？⭐⭐⭐⭐
**快速答案：**
- 告诉浏览器不会调用preventDefault()，可立即滚动
- 优化滚动、触摸事件性能，避免卡顿
- Chrome默认将touchstart/touchmove设为passive: true
- 如需阻止默认行为，必须设置passive: false

---

## 💡 答题模板和技巧

### 答题结构（推荐）
```
1. 简短定义（一句话说清楚是什么）
2. 核心原理（怎么实现的）
3. 使用场景（什么时候用）
4. 优缺点（如果有）
5. 代码示例（简洁清晰）
6. 注意事项（坑点）
```

### 高分答题技巧

#### 技巧1：使用记忆口诀快速回答
```
❌ 啊...事件流...就是...事件传播...然后...
✅ 事件流有三个阶段：捕获、目标、冒泡。记住口诀"外到内再到外"。
   捕获从window到目标，冒泡从目标到window。
```

#### 技巧2：对比回答更清晰
```
问：addEventListener 和 onclick 的区别？
✅ addEventListener支持绑定多个处理器，onclick会被覆盖；
   addEventListener可选择捕获或冒泡阶段，onclick只能冒泡；
   addEventListener支持once、passive等选项，更强大。
   所以现代开发推荐统一使用addEventListener。
```

#### 技巧3：联系实际项目
```
问：事件委托的应用场景？
✅ 我在项目中用事件委托做过待办列表：有上千个任务项，每个都有删除、编辑按钮。
   如果给每个按钮绑定事件，内存消耗大。
   我在父容器绑定一个点击事件，通过event.target判断点击的按钮类型，
   这样只有一个监听器，性能更好，新增任务也自动有事件。
```

#### 技巧4：说出底层原理
```
问：为什么passive可以优化滚动性能？
✅ 浏览器在处理滚动事件时，不确定是否会调用preventDefault()阻止滚动，
   必须等待事件处理完成才能开始滚动，导致卡顿。
   设置passive: true告诉浏览器不会阻止默认行为，可以立即开始滚动，
   从而提升性能。Chrome默认将touchstart/touchmove设为passive: true。
```

#### 技巧5：避免常见错误
```
❌ return false可以阻止冒泡
✅ return false在onclick中有效，但在addEventListener中无效。
   正确做法是用e.stopPropagation()。

❌ 所有事件都支持冒泡
✅ focus、blur、load等事件不支持冒泡。
   可以用focusin、focusout替代focus、blur。

❌ target和currentTarget是一样的
✅ target是触发事件的元素，currentTarget是绑定监听器的元素。
   在事件委托中，target是子元素，currentTarget是父元素。
```

---

## 🎯 记忆口诀汇总

### 事件流口诀
```
捕获目标冒泡（三阶段）
外到内再到外（传播方向）
捕获少用、冒泡常用（实际应用）
```

### 事件委托口诀
```
父代子（父元素代理子元素）
减内存（只需一个监听器）
动态绑（新增元素自动有事件）
精确判（event.target判断点击源）
```

### 阻止传播口诀
```
stopPropagation阻冒泡
preventDefault阻默认
stopImmediatePropagation立即停
return false看情况（onclick有效、addEventListener无效）
```

### addEventListener口诀
```
三参数：type、listener、options
capture控制阶段（false冒泡、true捕获）
once只触发一次（自动移除）
passive优化滚动（不阻止默认）
signal批量移除（AbortController）
```

### 事件对象口诀
```
target是源（真正点击的）
currentTarget是绑定者（this指向它）
type是类型（click、input等）
preventDefault阻默认
stopPropagation阻冒泡
```

### 自定义事件口诀
```
new CustomEvent创建
addEventListener监听
dispatchEvent触发
记住：创建→监听→触发（三步走）
```

### Vue事件口诀
```
@click绑定、.stop阻冒泡、.prevent阻默认
.once只一次、.capture捕获、.self只自己
.enter回车、.esc取消、.ctrl加Ctrl
$emit子传父、props父传子、provide/inject跨级传
```

### React事件口诀
```
合成事件统一管理（SyntheticEvent）
驼峰命名要记清（onClick、onChange）
this绑定用箭头（或者constructor中bind）
事件池已移除（React 17+）
nativeEvent访问原生（e.nativeEvent）
```

### 性能优化口诀
```
事件委托减监听
防抖等待节流间隔
passive优化滚动
及时移除避免泄漏
```

---

## 📖 总结

以上就是前端事件机制的高频面试题汇总，涵盖了JavaScript原生事件、Vue事件系统、React事件系统等核心知识点。掌握这些内容对于前端开发和面试都非常重要。

### 重点掌握：
1. ⭐⭐⭐⭐⭐ **事件流的三个阶段和事件委托原理**（最高频）
2. ⭐⭐⭐⭐⭐ **addEventListener的参数和options详解**（必考）
3. ⭐⭐⭐⭐⭐ **事件对象的常用属性和方法**（基础）
4. ⭐⭐⭐⭐⭐ **Vue的事件修饰符和组件通信**（Vue项目必备）
5. ⭐⭐⭐⭐ **React的合成事件系统**（React项目必备）
6. ⭐⭐⭐⭐ **自定义事件和发布订阅模式**（架构设计）
7. ⭐⭐⭐⭐ **事件性能优化技巧**（防抖节流、passive）
8. ⭐⭐⭐ **跨框架事件通信方案**（综合应用）

### 复习建议：
1. **第1遍**：通读全文，理解概念，背诵记忆口诀
2. **第2遍**：重点攻克高频题TOP 15，手写代码实现
3. **第3遍**：看核心知识点速记，10分钟快速复习
4. **面试前**：看记忆口诀汇总，快速唤醒记忆

### 学习路径：
```
基础 → 原生事件机制（事件流、事件委托、事件对象）
    ↓
进阶 → addEventListener深入（options参数详解）
    ↓
框架 → Vue事件机制（修饰符、组件通信）
    ↓
框架 → React事件机制（合成事件、this绑定）
    ↓
实战 → 经典面试题（拖拽、防抖节流、虚拟滚动）
    ↓
总结 → 核心知识点速记 + 高频题TOP 15
```

**祝你面试顺利！加油！💪**
```