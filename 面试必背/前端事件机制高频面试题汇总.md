# 前端事件机制高频面试题汇总

## 一、JavaScript原生事件机制

### 1. 事件流

#### 题目1：什么是事件流？事件流的三个阶段是什么？

**通俗概述：**
想象你点击了一个按钮，这个点击事件不是直接就到按钮上的，而是像水流一样有个传播过程。事件流就是描述这个点击事件是怎么从浏览器窗口一层层传到按钮，然后再一层层传回去的过程。就像扔石头到水里，水波会先向外扩散，然后再回来一样。

**答案：**
事件流描述的是从页面中接收事件的顺序。当一个事件发生时，会在元素之间按照特定的顺序传播，这个传播过程就是事件流。

**事件流的三个阶段：**
1. **捕获阶段（Capture Phase）**：事件从window对象向目标元素传播
2. **目标阶段（Target Phase）**：事件到达目标元素
3. **冒泡阶段（Bubble Phase）**：事件从目标元素向window对象传播

```javascript
// 事件流示例
document.getElementById('parent').addEventListener('click', function(e) {
  console.log('父元素捕获');
}, true); // true表示在捕获阶段触发

document.getElementById('child').addEventListener('click', function(e) {
  console.log('子元素冒泡');
}, false); // false表示在冒泡阶段触发（默认）

// 点击子元素时的输出顺序：
// 1. 父元素捕获
// 2. 子元素冒泡
```

#### 题目2：如何阻止事件冒泡和捕获？

**通俗概述：**
有时候我们不希望事件像水波一样传播，比如点击了子元素，不想让父元素也收到这个点击。就像在传话游戏中，我们可以让某个人停止往下传话。阻止冒泡就是让事件不再向上传播，阻止捕获就是让事件不再向下传播。

**答案：**
```javascript
element.addEventListener('click', function(e) {
  // 阻止事件冒泡
  e.stopPropagation();

  // 阻止事件捕获和冒泡（立即停止，同级别的其他监听器也不会执行）
  e.stopImmediatePropagation();

  // 阻止默认行为（如链接跳转、表单提交）
  e.preventDefault();

  // 在旧版本中，返回false可以同时阻止冒泡和默认行为
  // 但只在onclick等属性绑定中有效，addEventListener中无效
  return false;
});
```

#### 题目3：事件冒泡和事件捕获的实际应用场景？

**通俗概述：**
事件冒泡最常用的场景是"事件委托"，就像班长代表全班同学一样。比如有100个按钮，我们不用给每个按钮都绑定事件，只需要给它们的父容器绑定一个事件就行了，利用冒泡机制来处理。事件捕获则常用于全局拦截，比如在最外层拦截所有点击，做权限检查。

**答案：**
```javascript
// 1. 事件冒泡应用：事件委托
// 不好的做法：为每个li绑定事件
const lis = document.querySelectorAll('li');
lis.forEach(li => {
  li.addEventListener('click', handleClick);
});

// 好的做法：利用冒泡，只在父元素绑定一次
document.querySelector('ul').addEventListener('click', function(e) {
  if (e.target.tagName === 'LI') {
    handleClick(e);
  }
});

// 2. 事件捕获应用：全局事件拦截
// 在捕获阶段拦截所有点击事件
document.addEventListener('click', function(e) {
  // 可以在这里做权限验证、埋点统计等
  if (!hasPermission()) {
    e.stopPropagation(); // 阻止事件继续传播
    e.preventDefault();
    showNoPermissionDialog();
  }
}, true);
```

### 2. 事件委托/代理

#### 题目1：什么是事件委托？原理和优缺点是什么？

**通俗概述：**
事件委托就像是"代理人"的概念。比如一个班级里有30个学生，老师不用跟每个学生单独说话，只需要跟班长说，班长再转达给其他同学。在网页中，我们不给每个子元素绑定事件，而是给父元素绑定一个事件，让父元素来"代理"处理所有子元素的事件。这样做的好处是省内存、代码简洁，新增的子元素也自动有事件处理能力。

**答案：**
事件委托是利用事件冒泡机制，将事件监听器绑定在父元素上，通过判断事件目标来处理子元素的事件。

**原理：**
基于事件冒泡机制，子元素的事件会冒泡到父元素，在父元素的监听器中通过event.target判断事件源。

**优点：**
1. **减少内存消耗**：只需要绑定一个事件监听器
2. **动态元素支持**：新添加的子元素自动有事件处理
3. **简化代码**：避免重复绑定

**缺点：**
1. **不支持不冒泡的事件**：如focus、blur等
2. **可能误触发**：需要准确判断事件目标
3. **阻止冒泡会失效**：如果中间元素阻止冒泡

```javascript
// 完整的事件委托实现
class EventDelegate {
  constructor(parent, selector, eventType, handler) {
    this.parent = parent;
    this.selector = selector;
    this.handler = handler;

    parent.addEventListener(eventType, this.handleEvent.bind(this));
  }

  handleEvent(e) {
    let target = e.target;

    // 向上查找匹配的元素
    while (target && target !== this.parent) {
      if (target.matches(this.selector)) {
        this.handler.call(target, e);
        break;
      }
      target = target.parentElement;
    }
  }
}

// 使用示例
new EventDelegate(
  document.getElementById('list'),
  '.item',
  'click',
  function(e) {
    console.log('点击了:', this.textContent);
  }
);
```

#### 题目2：事件委托的经典面试题

**通俗概述：**
这是一个实际应用题，要求用事件委托实现一个待办事项列表。关键思路是：不给每个按钮单独绑定事件，而是给整个容器绑定一个事件，然后通过判断点击的是哪个按钮来执行对应的操作（删除、编辑、标记完成等）。

**答案：**
```javascript
// 题目：实现一个todolist，支持添加、删除、标记完成
class TodoList {
  constructor(container) {
    this.container = container;
    this.init();
  }

  init() {
    // 使用事件委托处理所有事件
    this.container.addEventListener('click', (e) => {
      const target = e.target;
      const action = target.dataset.action;
      const todoItem = target.closest('.todo-item');

      if (!action || !todoItem) return;

      switch(action) {
        case 'delete':
          this.deleteTodo(todoItem);
          break;
        case 'toggle':
          this.toggleTodo(todoItem);
          break;
        case 'edit':
          this.editTodo(todoItem);
          break;
      }
    });
  }

  addTodo(text) {
    const html = `
      <div class="todo-item">
        <input type="checkbox" data-action="toggle">
        <span class="todo-text">${text}</span>
        <button data-action="edit">编辑</button>
        <button data-action="delete">删除</button>
      </div>
    `;
    this.container.insertAdjacentHTML('beforeend', html);
  }

  deleteTodo(item) {
    item.remove();
  }

  toggleTodo(item) {
    item.classList.toggle('completed');
  }

  editTodo(item) {
    const textElement = item.querySelector('.todo-text');
    const newText = prompt('编辑任务:', textElement.textContent);
    if (newText) {
      textElement.textContent = newText;
    }
  }
}
```

### 3. 事件对象

#### 题目1：事件对象的常用属性和方法？

**通俗概述：**
当事件发生时，浏览器会创建一个"事件对象"，里面包含了这次事件的所有信息，就像是事件的"身份证"。比如点击事件的对象会告诉你：点击的是哪个元素、鼠标在哪个位置、按了哪些键等等。掌握这些属性和方法，就能获取事件的详细信息并进行相应处理。

**答案：**
```javascript
element.addEventListener('click', function(event) {
  // 常用属性
  console.log(event.type);           // 事件类型：'click'
  console.log(event.target);         // 触发事件的元素（事件源）
  console.log(event.currentTarget);  // 绑定事件的元素（this）
  console.log(event.eventPhase);     // 事件阶段：1(捕获) 2(目标) 3(冒泡)
  console.log(event.bubbles);        // 是否冒泡
  console.log(event.cancelable);     // 是否可取消默认行为
  console.log(event.timeStamp);      // 事件发生的时间戳
  console.log(event.isTrusted);      // 是否是用户触发的事件

  // 鼠标事件特有属性
  console.log(event.clientX, event.clientY); // 相对于视口的坐标
  console.log(event.pageX, event.pageY);     // 相对于页面的坐标
  console.log(event.screenX, event.screenY); // 相对于屏幕的坐标
  console.log(event.offsetX, event.offsetY); // 相对于目标元素的坐标

  // 键盘事件特有属性
  console.log(event.key);      // 按键的值
  console.log(event.code);     // 按键的物理位置
  console.log(event.keyCode);  // 按键编码（已废弃）
  console.log(event.altKey);   // 是否按下Alt键
  console.log(event.ctrlKey);  // 是否按下Ctrl键
  console.log(event.shiftKey); // 是否按下Shift键
  console.log(event.metaKey);  // 是否按下Meta键（Mac的Command键）

  // 常用方法
  event.preventDefault();        // 阻止默认行为
  event.stopPropagation();       // 阻止冒泡
  event.stopImmediatePropagation(); // 立即停止传播
});
```

#### 题目2：event.target和event.currentTarget的区别？

**通俗概述：**
这是一个容易混淆的概念。简单说：target是"真正被点击的元素"，currentTarget是"绑定事件处理函数的元素"。就像你点击了一个按钮里的文字，target是那个文字，currentTarget是按钮。在事件委托中，target是子元素，currentTarget是父元素。

**答案：**
- **event.target**：触发事件的元素（事件源）
- **event.currentTarget**：绑定事件监听器的元素

```javascript
// HTML结构
// <div id="parent">
//   <button id="child">点击我</button>
// </div>

document.getElementById('parent').addEventListener('click', function(e) {
  console.log('target:', e.target.id);             // 'child'（点击的元素）
  console.log('currentTarget:', e.currentTarget.id); // 'parent'（绑定事件的元素）
  console.log('this:', this.id);                   // 'parent'（this === currentTarget）
});
```

### 4. 自定义事件

#### 题目1：如何创建和触发自定义事件？

**通俗概述：**
除了点击、输入这些浏览器内置的事件，我们还可以创建自己的事件，比如"用户登录成功"、"数据加载完成"等。就像自己定义一个暗号，当某个条件满足时就"喊"这个暗号，其他地方听到这个暗号就执行相应的操作。这在组件间通信中非常有用。

**答案：**
```javascript
// 方法1：使用CustomEvent（推荐）
const customEvent = new CustomEvent('myEvent', {
  detail: { message: 'Hello World' }, // 自定义数据
  bubbles: true,                      // 是否冒泡
  cancelable: true                    // 是否可取消
});

// 监听自定义事件
element.addEventListener('myEvent', function(e) {
  console.log('自定义事件触发:', e.detail.message);
});

// 触发自定义事件
element.dispatchEvent(customEvent);

// 方法2：使用Event构造函数
const event = new Event('build', { bubbles: true });
element.dispatchEvent(event);

// 方法3：旧版本兼容写法
const event = document.createEvent('CustomEvent');
event.initCustomEvent('myEvent', true, true, { message: 'Hello' });
element.dispatchEvent(event);
```

#### 题目2：实现一个完整的事件发布订阅系统

**通俗概述：**
这是一个经典的设计模式题。发布订阅就像是"广播电台"，有人可以"订阅"（监听）某个频道，有人可以"发布"（广播）消息到这个频道。所有订阅了这个频道的人都能收到消息。这个模式在前端开发中非常常用，用于解耦不同模块间的通信。

**答案：**
```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }

  // 订阅事件
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
    return this; // 支持链式调用
  }

  // 触发事件
  emit(eventName, ...args) {
    if (!this.events[eventName]) {
      return this;
    }
    this.events[eventName].forEach(callback => {
      callback.apply(this, args);
    });
    return this;
  }

  // 取消订阅
  off(eventName, callback) {
    if (!this.events[eventName]) {
      return this;
    }
    if (!callback) {
      // 如果没有提供callback，移除所有监听器
      delete this.events[eventName];
    } else {
      this.events[eventName] = this.events[eventName].filter(
        cb => cb !== callback
      );
    }
    return this;
  }

  // 一次性订阅
  once(eventName, callback) {
    const onceWrapper = (...args) => {
      callback.apply(this, args);
      this.off(eventName, onceWrapper);
    };
    this.on(eventName, onceWrapper);
    return this;
  }
}

// 使用示例
const emitter = new EventEmitter();

emitter.on('login', (user) => {
  console.log(`${user} 登录了`);
});

emitter.once('logout', (user) => {
  console.log(`${user} 登出了`);
});

emitter.emit('login', '张三'); // 张三 登录了
emitter.emit('logout', '张三'); // 张三 登出了
emitter.emit('logout', '李四'); // 不会输出，因为是once
```

### 5. 事件性能优化

#### 题目1：如何优化大量事件监听器的性能？

**通俗概述：**
当页面上有很多元素需要绑定事件时，如果每个都单独绑定会很消耗内存和性能。就像管理一个大公司，不能老板直接管每个员工，而是要分层管理。优化方法包括：事件委托（让父元素代理）、防抖节流（控制触发频率）、及时清理不用的事件等。

**答案：**
```javascript
// 1. 使用事件委托
// 不好的做法
for (let i = 0; i < 1000; i++) {
  document.getElementById(`item-${i}`).addEventListener('click', handleClick);
}

// 好的做法
document.getElementById('container').addEventListener('click', (e) => {
  if (e.target.classList.contains('item')) {
    handleClick(e);
  }
});

// 2. 使用防抖和节流
// 防抖
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 节流
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 3. 使用passive选项优化滚动性能
document.addEventListener('scroll', handleScroll, { passive: true });

// 4. 及时移除不需要的事件监听器
class Component {
  constructor() {
    this.handleClick = this.handleClick.bind(this);
  }

  mount() {
    document.addEventListener('click', this.handleClick);
  }

  unmount() {
    document.removeEventListener('click', this.handleClick);
  }

  handleClick(e) {
    // 处理点击
  }
}

// 5. 使用事件监听器选项
element.addEventListener('click', handler, {
  once: true,    // 只触发一次
  passive: true, // 不会调用preventDefault
  capture: false // 冒泡阶段触发
});
```

## 二、Vue事件机制

### 1. Vue事件基础

#### 题目1：Vue中的事件绑定方式有哪些？

**通俗概述：**
Vue提供了多种绑定事件的方式，最常用的是@click这种语法糖。你可以直接在模板里写简单的表达式，也可以调用methods里的方法，还可以传参数。Vue让事件绑定变得非常直观和灵活，比原生JavaScript简洁很多。

**答案：**
**官方文档：**
- Vue 3: https://cn.vuejs.org/guide/essentials/event-handling.html
- Vue 2: https://v2.cn.vuejs.org/v2/guide/events.html
```vue
<template>
  <!-- 1. 内联事件处理器 -->
  <button @click="count++">增加</button>

  <!-- 2. 方法事件处理器 -->
  <button @click="increment">增加</button>

  <!-- 3. 带参数的方法调用 -->
  <button @click="say('hello')">打招呼</button>

  <!-- 4. 访问原生DOM事件 -->
  <button @click="warn('警告', $event)">警告</button>

  <!-- 5. 多个方法处理器 -->
  <button @click="one($event), two($event)">多个处理器</button>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    };
  },
  methods: {
    increment() {
      this.count++;
    },
    say(message) {
      alert(message);
    },
    warn(message, event) {
      if (event) {
        event.preventDefault();
      }
      alert(message);
    },
    one(event) {
      console.log('第一个处理器');
    },
    two(event) {
      console.log('第二个处理器');
    }
  }
};
</script>
```

#### 题目2：Vue事件修饰符有哪些？各自的作用是什么？

**通俗概述：**
Vue的事件修饰符是它的一大特色，让事件处理变得超级简单。比如想阻止冒泡，只需要加个.stop；想阻止默认行为，加个.prevent。这些修饰符可以串联使用，让代码变得非常简洁易读，不用在方法里写一堆preventDefault()这样的代码。

**答案：**
**官方文档：**
- Vue 3: https://cn.vuejs.org/guide/essentials/event-handling.html#event-modifiers
- Vue 2: https://v2.cn.vuejs.org/v2/guide/events.html#事件修饰符
```vue
<template>
  <!-- 阻止事件冒泡 -->
  <div @click.stop="handleClick">阻止冒泡</div>

  <!-- 阻止默认行为 -->
  <form @submit.prevent="handleSubmit">提交</form>

  <!-- 事件捕获模式 -->
  <div @click.capture="handleClick">捕获阶段触发</div>

  <!-- 只触发自身，不包括子元素 -->
  <div @click.self="handleClick">只有点击自身才触发</div>

  <!-- 只触发一次 -->
  <button @click.once="handleClick">只触发一次</button>

  <!-- 滚动事件的passive模式 -->
  <div @scroll.passive="handleScroll">优化滚动性能</div>

  <!-- 修饰符可以串联 -->
  <a @click.stop.prevent="handleClick">阻止冒泡和默认行为</a>

  <!-- 按键修饰符 -->
  <input @keyup.enter="submit">
  <input @keyup.tab="next">
  <input @keyup.delete="remove">
  <input @keyup.esc="cancel">
  <input @keyup.space="space">
  <input @keyup.up="up">
  <input @keyup.down="down">
  <input @keyup.left="left">
  <input @keyup.right="right">

  <!-- 系统修饰键 -->
  <input @keyup.ctrl="handleCtrl">
  <input @keyup.alt="handleAlt">
  <input @keyup.shift="handleShift">
  <input @keyup.meta="handleMeta">

  <!-- 精确修饰符 -->
  <button @click.ctrl.exact="handleCtrlClick">只有Ctrl</button>

  <!-- 鼠标按钮修饰符 -->
  <button @click.left="handleLeftClick">左键</button>
  <button @click.right="handleRightClick">右键</button>
  <button @click.middle="handleMiddleClick">中键</button>
</template>
```

#### 题目3：Vue中的.sync修饰符是什么？Vue3中如何替代？

**通俗概述：**
.sync修饰符是Vue2中的一个语法糖，用于实现父子组件间的双向数据绑定。就像是父子之间的"对讲机"，子组件可以直接修改父组件的数据。Vue3中移除了.sync，改用更强大的v-model来实现，而且可以有多个v-model，功能更强大。

**答案：**
**官方文档：**
- Vue 3 v-model: https://cn.vuejs.org/guide/components/v-model.html
- Vue 2 .sync: https://v2.cn.vuejs.org/v2/guide/components-custom-events.html#sync-修饰符
```vue
<!-- Vue 2.x 中的.sync修饰符 -->
<template>
  <!-- 父组件 -->
  <ChildComponent :title.sync="pageTitle" />

  <!-- 等价于 -->
  <ChildComponent
    :title="pageTitle"
    @update:title="pageTitle = $event"
  />
</template>

<script>
// 子组件
export default {
  props: ['title'],
  methods: {
    updateTitle() {
      this.$emit('update:title', '新标题');
    }
  }
};
</script>

<!-- Vue 3.x 中使用v-model替代 -->
<template>
  <!-- 父组件 -->
  <ChildComponent v-model:title="pageTitle" />

  <!-- 多个v-model -->
  <ChildComponent
    v-model:title="pageTitle"
    v-model:content="pageContent"
  />
</template>

<script>
// Vue 3 子组件
export default {
  props: ['title', 'content'],
  emits: ['update:title', 'update:content'],
  methods: {
    updateTitle() {
      this.$emit('update:title', '新标题');
    },
    updateContent() {
      this.$emit('update:content', '新内容');
    }
  }
};
</script>
```

### 2. Vue组件通信

#### 题目1：Vue组件间通信方式有哪些？

**通俗概述：**
Vue组件间通信就像是不同房间的人要说话，有很多种方式：父子组件用props和emit（像父母和孩子对话）；跨级组件用provide/inject（像祖父母直接和孙子对话）；任意组件用EventBus（像广播）；全局状态用Vuex/Pinia（像公共告示板）。每种方式适用于不同的场景。

**答案：**
**官方文档：**
- Props/Emit: https://cn.vuejs.org/guide/components/props.html
- Provide/Inject: https://cn.vuejs.org/guide/components/provide-inject.html
- Pinia: https://pinia.vuejs.org/zh/
- Vuex: https://vuex.vuejs.org/zh/
```javascript
// 1. Props和$emit（父子组件）
// 父组件
<ChildComponent :message="parentMsg" @update="handleUpdate" />

// 子组件
props: ['message'],
methods: {
  sendToParent() {
    this.$emit('update', 'child data');
  }
}

// 2. provide/inject（跨级组件）
// 祖先组件
provide() {
  return {
    theme: this.theme,
    // 提供响应式数据
    user: computed(() => this.user)
  };
}

// 后代组件
inject: ['theme', 'user']

// 3. EventBus（任意组件）
// Vue2 - 使用Vue实例作为事件总线
import Vue from 'vue';
export const EventBus = new Vue();

// 发送事件
EventBus.$emit('user-login', userData);

// 监听事件
EventBus.$on('user-login', (data) => {
  console.log('用户登录:', data);
});

// 移除监听（组件销毁时记得移除）
EventBus.$off('user-login');

// Vue3 - 需要使用第三方库或自己实现
import mitt from 'mitt';
export const EventBus = mitt();

// 4. Vuex/Pinia（全局状态管理）
// Vuex
this.$store.dispatch('updateUser', userData);
this.$store.commit('SET_USER', userData);

// Pinia
import { useUserStore } from '@/stores/user';
const userStore = useUserStore();
userStore.updateUser(userData);

// 5. $attrs和$listeners（属性和事件透传）- Vue2
// 中间组件
<GrandChild v-bind="$attrs" v-on="$listeners" />

// Vue3中使用$attrs（包含了事件）
<GrandChild v-bind="$attrs" />

// 6. $parent/$children（直接访问）- 不推荐
this.$parent.parentMethod();
this.$children[0].childMethod();

// 7. ref（获取组件实例）
<ChildComponent ref="child" />
this.$refs.child.childMethod();

// 8. Vue3 Composition API
// 使用composables共享逻辑
// useUser.js
import { ref, computed } from 'vue';

export function useUser() {
  const user = ref(null);
  const isLoggedIn = computed(() => !!user.value);

  function login(userData) {
    user.value = userData;
  }

  function logout() {
    user.value = null;
  }

  return {
    user,
    isLoggedIn,
    login,
    logout
  };
}
```

#### 题目2：Vue2和Vue3的事件总线实现有什么区别？

**通俗概述：**
Vue2中可以直接用Vue实例作为事件总线，因为Vue实例自带$on、$emit等方法，就像内置了一个"广播电台"。但Vue3把这些方法移除了，需要自己实现或使用第三方库（如mitt）。这是Vue3为了减小体积和复杂度做的改变。

**答案：**
**官方文档：**
- Vue 2 实例方法: https://v2.cn.vuejs.org/v2/api/#实例方法-事件
- Vue 3 迁移指南: https://v3-migration.vuejs.org/zh/breaking-changes/events-api.html
- mitt库: https://github.com/developit/mitt

**Vue2内置事件总线：**
Vue2中可以直接使用Vue实例作为事件总线，因为Vue2实例提供了`$on`、`$emit`、`$off`、`$once`等方法。

```javascript
// Vue2 - 方法1：使用空的Vue实例作为事件总线
import Vue from 'vue';
export const EventBus = new Vue();

// 发送事件
EventBus.$emit('user-login', userData);

// 监听事件
EventBus.$on('user-login', (data) => {
  console.log('用户登录:', data);
});

// 移除监听
EventBus.$off('user-login');

// 一次性监听
EventBus.$once('user-logout', (data) => {
  console.log('用户登出:', data);
});

// Vue2 - 方法2：挂载到Vue原型上（全局事件总线）
// main.js
Vue.prototype.$bus = new Vue();

// 组件中使用
this.$bus.$emit('event-name', data);
this.$bus.$on('event-name', callback);

// 在组件销毁时移除监听
beforeDestroy() {
  this.$bus.$off('event-name');
}
```

**Vue3移除了事件API：**
Vue3中移除了`$on`、`$off`、`$once`等实例方法，因此需要自己实现或使用第三方库。

```javascript
// Vue3中没有内置的事件总线，需要自己实现或使用第三方库

// 方法1：使用mitt库
import mitt from 'mitt';

const emitter = mitt();

// 在main.js中全局注册
app.config.globalProperties.$emitter = emitter;

// 或者通过provide/inject
app.provide('emitter', emitter);

// 使用
// 发送事件
emitter.emit('custom-event', data);

// 监听事件
emitter.on('custom-event', (data) => {
  console.log(data);
});

// 移除监听
emitter.off('custom-event');

// 方法2：自定义事件总线
class EventBus {
  constructor() {
    this.events = {};
  }

  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  emit(event, ...args) {
    if (this.events[event]) {
      this.events[event].forEach(callback => {
        callback(...args);
      });
    }
  }

  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}

// 创建单例
export default new EventBus();

// 方法3：使用Composition API实现
import { ref, readonly } from 'vue';

function useEventBus() {
  const events = ref(new Map());

  function on(event, callback) {
    if (!events.value.has(event)) {
      events.value.set(event, []);
    }
    events.value.get(event).push(callback);
  }

  function emit(event, ...args) {
    if (events.value.has(event)) {
      events.value.get(event).forEach(callback => {
        callback(...args);
      });
    }
  }

  function off(event, callback) {
    if (events.value.has(event)) {
      const callbacks = events.value.get(event);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }

  return {
    on,
    emit,
    off,
    events: readonly(events)
  };
}

export default useEventBus();
```

### 3. Vue自定义指令中的事件

#### 题目1：如何在自定义指令中处理事件？

**通俗概述：**
自定义指令就像是给HTML元素添加"超能力"的工具。在指令中处理事件很常见，比如实现"点击外部关闭"、"长按触发"等功能。关键是在指令的生命周期钩子中绑定和解绑事件，确保不会造成内存泄漏。

**答案：**
**官方文档：**
- Vue 3: https://cn.vuejs.org/guide/reusability/custom-directives.html
- Vue 2: https://v2.cn.vuejs.org/v2/guide/custom-directive.html
```javascript
// Vue2 自定义指令
Vue.directive('click-outside', {
  bind(el, binding, vnode) {
    el.clickOutsideEvent = function(event) {
      // 检查点击是否在元素外部
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event);
      }
    };
    document.body.addEventListener('click', el.clickOutsideEvent);
  },
  unbind(el) {
    document.body.removeEventListener('click', el.clickOutsideEvent);
  }
});

// Vue3 自定义指令
app.directive('click-outside', {
  mounted(el, binding) {
    el.clickOutsideEvent = function(event) {
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event);
      }
    };
    document.addEventListener('click', el.clickOutsideEvent);
  },
  unmounted(el) {
    document.removeEventListener('click', el.clickOutsideEvent);
  }
});

// 使用
<div v-click-outside="handleClickOutside">
  点击外部关闭
</div>

// 复杂示例：长按指令
app.directive('longpress', {
  mounted(el, binding) {
    if (typeof binding.value !== 'function') {
      throw 'callback must be a function';
    }

    let pressTimer = null;
    const duration = binding.arg || 500; // 默认500ms

    const start = (e) => {
      if (e.type === 'click' && e.button !== 0) {
        return;
      }
      if (pressTimer === null) {
        pressTimer = setTimeout(() => {
          handler(e);
        }, duration);
      }
    };

    const cancel = () => {
      if (pressTimer !== null) {
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    };

    const handler = (e) => {
      binding.value(e);
    };

    el.addEventListener('mousedown', start);
    el.addEventListener('touchstart', start);
    el.addEventListener('click', cancel);
    el.addEventListener('mouseout', cancel);
    el.addEventListener('touchend', cancel);
    el.addEventListener('touchcancel', cancel);

    // 保存事件处理器以便卸载
    el._longpress = { start, cancel };
  },
  unmounted(el) {
    const { start, cancel } = el._longpress;
    el.removeEventListener('mousedown', start);
    el.removeEventListener('touchstart', start);
    el.removeEventListener('click', cancel);
    el.removeEventListener('mouseout', cancel);
    el.removeEventListener('touchend', cancel);
    el.removeEventListener('touchcancel', cancel);
  }
});

// 使用
<button v-longpress:1000="handleLongPress">长按我</button>
```

### 4. Vue事件相关原理

#### 题目1：Vue是如何实现事件绑定的？

**通俗概述：**
Vue在编译模板时会把@click这样的事件绑定转换成原生的addEventListener。就像是一个"翻译官"，把Vue的语法糖翻译成浏览器能理解的原生代码。Vue还会做一些优化，比如事件代理，让性能更好。

**答案：**
```javascript
// Vue在编译模板时，会将@click等事件绑定转换为事件处理器

// 模板
<button @click="handleClick">点击</button>

// 编译后（简化版）
function render() {
  return h('button', {
    onClick: handleClick
  }, '点击');
}

// Vue内部处理流程
// 1. 编译阶段：将@click转换为onClick
// 2. 创建VNode时，将事件存储在VNode的props中
// 3. patch过程中，调用原生addEventListener绑定事件

// 事件代理实现（Vue2）
// Vue2使用事件代理优化性能
class EventManager {
  constructor() {
    this.events = {};
  }

  add(el, event, handler) {
    if (!this.events[event]) {
      this.events[event] = new WeakMap();
    }
    this.events[event].set(el, handler);
    el.addEventListener(event, handler);
  }

  remove(el, event) {
    if (this.events[event]) {
      const handler = this.events[event].get(el);
      if (handler) {
        el.removeEventListener(event, handler);
        this.events[event].delete(el);
      }
    }
  }
}
```

#### 题目2：Vue的v-model原理是什么？Vue2和Vue3的v-model有什么区别？

**通俗概述：**
v-model是Vue中实现双向数据绑定的语法糖，本质上是属性绑定+事件监听的组合。就像是"自动同步器"，当输入框的值变化时自动更新数据，当数据变化时自动更新输入框。Vue3对v-model做了增强，支持多个v-model，功能更强大。

**答案：**
**官方文档：**
- Vue 3: https://cn.vuejs.org/guide/components/v-model.html
- Vue 2: https://v2.cn.vuejs.org/v2/guide/components.html#在组件上使用-v-model
- 迁移指南: https://v3-migration.vuejs.org/zh/breaking-changes/v-model.html

**v-model的基本原理：**
v-model是语法糖，本质是属性绑定和事件监听的结合。

```javascript
// 原始写法
<input :value="message" @input="message = $event.target.value">

// v-model写法
<input v-model="message">
```

**Vue2和Vue3的v-model区别：**

**1. 组件上的默认prop和事件名称不同**
```javascript
// Vue2
<CustomInput v-model="searchText" />
// 等价于
<CustomInput :value="searchText" @input="searchText = $event" />

// Vue3
<CustomInput v-model="searchText" />
// 等价于
<CustomInput :modelValue="searchText" @update:modelValue="searchText = $event" />
```

**2. 支持多个v-model绑定**
```vue
<!-- Vue2：只能有一个v-model，需要用.sync实现多个双向绑定 -->
<UserForm
  v-model="name"
  :age.sync="age"
  :email.sync="email"
/>

<!-- Vue3：支持多个v-model -->
<UserForm
  v-model:name="name"
  v-model:age="age"
  v-model:email="email"
/>
```

**3. 自定义v-model的实现方式**
```javascript
// Vue2 - 需要配置model选项
export default {
  model: {
    prop: 'checked',  // 自定义prop名称
    event: 'change'   // 自定义事件名称
  },
  props: {
    checked: Boolean
  },
  methods: {
    handleChange(e) {
      this.$emit('change', e.target.checked);
    }
  }
};

// Vue3 - 直接使用v-model:propName
export default {
  props: {
    modelValue: String,  // 默认
    title: String,       // 自定义
    content: String      // 自定义
  },
  emits: ['update:modelValue', 'update:title', 'update:content'],
  methods: {
    updateValue(value) {
      this.$emit('update:modelValue', value);
    },
    updateTitle(value) {
      this.$emit('update:title', value);
    },
    updateContent(value) {
      this.$emit('update:content', value);
    }
  }
};

// 使用
<MyComponent
  v-model="value"          // 默认的modelValue
  v-model:title="title"    // 自定义的title
  v-model:content="content" // 自定义的content
/>
```

**4. v-model修饰符的变化**
```javascript
// Vue2：内置修饰符
<input v-model.trim="text">
<input v-model.number="age">
<input v-model.lazy="msg">

// Vue3：除了内置修饰符，还支持自定义修饰符
<input v-model.trim="text">
<input v-model.number="age">
<input v-model.lazy="msg">
<CustomInput v-model.capitalize="text" />  // 自定义修饰符

// 组件内处理自定义修饰符（Vue3新特性）
export default {
  props: {
    modelValue: String,
    modelModifiers: {  // 接收修饰符
      default: () => ({})
    }
  },
  emits: ['update:modelValue'],
  methods: {
    emitValue(value) {
      if (this.modelModifiers.capitalize) {
        value = value.charAt(0).toUpperCase() + value.slice(1);
      }
      if (this.modelModifiers.lowercase) {
        value = value.toLowerCase();
      }
      this.$emit('update:modelValue', value);
    }
  }
};
```

**5. 完整对比示例**
```javascript
// === Vue2实现 ===
// 父组件
<template>
  <CustomInput v-model="text" :age.sync="age" />
</template>

// 子组件
export default {
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: String,
    age: Number
  },
  methods: {
    updateValue(val) {
      this.$emit('change', val);  // 对应v-model
    },
    updateAge(val) {
      this.$emit('update:age', val);  // 对应.sync
    }
  }
};

// === Vue3实现 ===
// 父组件
<template>
  <CustomInput v-model="text" v-model:age="age" />
</template>

// 子组件
export default {
  props: {
    modelValue: String,
    age: Number
  },
  emits: ['update:modelValue', 'update:age'],
  methods: {
    updateValue(val) {
      this.$emit('update:modelValue', val);
    },
    updateAge(val) {
      this.$emit('update:age', val);
    }
  }
};
```

**总结主要区别：**
1. **默认prop名称**：Vue2使用`value`，Vue3使用`modelValue`
2. **默认事件名称**：Vue2使用`input`，Vue3使用`update:modelValue`
3. **多个双向绑定**：Vue2需要v-model + .sync，Vue3统一使用v-model:xxx
4. **自定义修饰符**：Vue3新增支持自定义修饰符
5. **.sync修饰符**：Vue3中被移除，功能由v-model:xxx替代

## 三、React事件机制

### 1. React事件基础

#### 题目1：React的合成事件是什么？为什么要使用合成事件？

**通俗概述：**
React的合成事件就像是给原生事件穿了一件"标准化外套"，让所有浏览器的事件行为都变得一致。就像不同品牌的手机都用同一个充电接口一样，React把不同浏览器的事件差异抹平了，还做了性能优化，所有事件都统一管理。

**答案：**
**官方文档：**
- React事件处理: https://zh-hans.react.dev/learn/responding-to-events
- 合成事件: https://zh-hans.react.dev/reference/react-dom/components/common#react-event-object
React的合成事件（SyntheticEvent）是React自己实现的一套事件系统，它是原生DOM事件的跨浏览器封装。

**为什么使用合成事件：**
1. **跨浏览器兼容性**：抹平不同浏览器的差异
2. **性能优化**：通过事件委托，所有事件都绑定到document上
3. **事件池**：React16及之前版本使用事件池复用事件对象
4. **更好的控制**：可以控制事件的触发顺序和行为

```javascript
class Component extends React.Component {
  handleClick = (e) => {
    // e是合成事件对象
    console.log(e); // SyntheticEvent
    console.log(e.nativeEvent); // 原生事件对象

    // 合成事件的属性和方法
    e.preventDefault(); // 阻止默认行为
    e.stopPropagation(); // 阻止冒泡
    e.persist(); // React16及之前，保持事件引用

    // 异步访问事件对象（React16及之前需要persist）
    setTimeout(() => {
      console.log(e.type); // React17+可以直接访问
    }, 1000);
  };

  render() {
    return <button onClick={this.handleClick}>点击</button>;
  }
}
```

#### 题目2：React事件绑定的几种方式？

**通俗概述：**
React中绑定事件有好几种写法，主要区别在于this指向和性能。类组件中推荐用箭头函数或在constructor中绑定，避免在render中绑定（会影响性能）。函数组件中就简单多了，直接定义函数即可，配合useCallback还能优化性能。

**答案：**
**官方文档：**
- 事件处理: https://zh-hans.react.dev/learn/responding-to-events
- Hook文档: https://zh-hans.react.dev/reference/react/hooks
```javascript
class EventBinding extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };

    // 方式1：构造函数中绑定
    this.handleClick1 = this.handleClick1.bind(this);
  }

  // 方式1：普通方法 + constructor绑定
  handleClick1() {
    this.setState({ count: this.state.count + 1 });
  }

  // 方式2：箭头函数定义方法
  handleClick2 = () => {
    this.setState({ count: this.state.count + 1 });
  }

  // 方式3：普通方法
  handleClick3() {
    this.setState({ count: this.state.count + 1 });
  }

  // 方式4：带参数的方法
  handleClick4(param, e) {
    console.log(param, e);
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        {/* 方式1：constructor中绑定 */}
        <button onClick={this.handleClick1}>方式1</button>

        {/* 方式2：箭头函数方法 */}
        <button onClick={this.handleClick2}>方式2</button>

        {/* 方式3：render中bind（不推荐，每次render创建新函数） */}
        <button onClick={this.handleClick3.bind(this)}>方式3</button>

        {/* 方式4：render中箭头函数（不推荐，每次render创建新函数） */}
        <button onClick={() => this.handleClick3()}>方式4</button>

        {/* 方式5：传参 - 使用箭头函数 */}
        <button onClick={(e) => this.handleClick4('参数', e)}>方式5</button>

        {/* 方式6：传参 - 使用bind */}
        <button onClick={this.handleClick4.bind(this, '参数')}>方式6</button>
      </div>
    );
  }
}

// 函数组件中的事件绑定
function FunctionComponent() {
  const [count, setCount] = useState(0);

  // 直接定义事件处理函数
  const handleClick = () => {
    setCount(count + 1);
  };

  // 使用useCallback优化
  const handleClickMemo = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);

  // 带参数的事件处理
  const handleClickWithParam = (param) => {
    console.log(param);
    setCount(count + 1);
  };

  return (
    <div>
      <button onClick={handleClick}>点击</button>
      <button onClick={handleClickMemo}>优化的点击</button>
      <button onClick={() => handleClickWithParam('参数')}>带参数</button>
    </div>
  );
}
```

#### 题目3：React事件和原生事件的执行顺序？

**通俗概述：**
这是一个经典的面试题。React事件和原生事件混合使用时，执行顺序会让人困惑。简单记住：React17之前，原生事件先执行，然后才是React事件；React17之后，顺序更接近原生事件流。这个变化是为了让React事件行为更符合预期。

**答案：**
```javascript
class EventOrder extends React.Component {
  componentDidMount() {
    // 原生事件绑定
    document.getElementById('native-btn').addEventListener('click', () => {
      console.log('原生事件（冒泡）');
    });

    document.getElementById('native-btn').addEventListener('click', () => {
      console.log('原生事件（捕获）');
    }, true);

    document.addEventListener('click', () => {
      console.log('document原生事件');
    });
  }

  handleReactClick = () => {
    console.log('React合成事件');
  };

  handleReactClickCapture = () => {
    console.log('React合成事件（捕获）');
  };

  render() {
    return (
      <button
        id="native-btn"
        onClick={this.handleReactClick}
        onClickCapture={this.handleReactClickCapture}
      >
        点击测试顺序
      </button>
    );
  }
}

// 点击按钮后的执行顺序（React 17+）：
// 1. 原生事件（捕获）
// 2. React合成事件（捕获）
// 3. React合成事件
// 4. 原生事件（冒泡）
// 5. document原生事件

// React 16及之前的执行顺序：
// 1. 原生事件（捕获）
// 2. 原生事件（冒泡）
// 3. React合成事件（捕获）
// 4. React合成事件
// 5. document原生事件
```

### 2. React事件系统原理

#### 题目1：React17对事件系统做了哪些改变？

**通俗概述：**
React17对事件系统做了重要升级：把事件绑定从document改到了根容器上，这样多个React版本可以共存不冲突；移除了事件池，事件对象不再复用，使用起来更直观。这些改变让React更好地与其他库集成，行为也更接近原生事件。

**答案：**
**官方文档：**
- React 17发布说明: https://zh-hans.react.dev/blog/2020/10/20/react-v17
- React 18升级指南: https://zh-hans.react.dev/blog/2022/03/08/react-18-upgrade-guide
```javascript
// React 16及之前
// 1. 所有事件都绑定在document上
// 2. 使用事件池复用事件对象

// React 17+的改变
// 1. 事件绑定在根容器上（ReactDOM.render的容器）
// 2. 移除事件池，事件对象不再复用
// 3. 更接近原生事件行为

// 示例：多个React版本共存
// React 16
ReactDOM.render(<App16 />, document.getElementById('root16'));
// 事件绑定在document上

// React 17+
ReactDOM.render(<App17 />, document.getElementById('root17'));
// 事件绑定在#root17上

// 好处：
// 1. 多版本React共存不会冲突
// 2. 更好的与第三方库集成
// 3. 事件处理更接近原生行为

// 事件委托示例
function EventDelegation() {
  useEffect(() => {
    // React 17+中，这个原生事件可能先于React事件执行
    document.addEventListener('click', (e) => {
      // 可以阻止React事件
      e.stopPropagation();
    });
  }, []);

  return (
    <div onClick={() => console.log('React事件')}>
      点击测试
    </div>
  );
}
```

#### 题目2：React事件池是什么？为什么React17移除了事件池？

**通俗概述：**
事件池是React16及之前版本的一个优化机制，就像"共享单车"一样，事件对象用完后会被回收再利用，避免频繁创建销毁。但这导致异步访问事件对象时会出问题，需要调用persist()保持引用。React17移除了事件池，因为现代浏览器性能提升了，这个优化的收益不大，反而增加了复杂度。

**答案：**
```javascript
// React 16及之前的事件池机制
class EventPoolExample extends React.Component {
  handleClick = (e) => {
    // e是从事件池中取出的合成事件对象
    console.log(e.type); // 'click'

    // 异步访问会失败（事件对象被重置）
    setTimeout(() => {
      console.log(e.type); // null（React16）
    }, 1000);

    // 需要使用persist保持引用
    e.persist();
    setTimeout(() => {
      console.log(e.type); // 'click'
    }, 1000);
  };

  render() {
    return <button onClick={this.handleClick}>点击</button>;
  }
}

// React 17+移除事件池
function ModernEventExample() {
  const handleClick = (e) => {
    // 不需要persist，可以直接异步访问
    setTimeout(() => {
      console.log(e.type); // 'click'
    }, 1000);

    // 可以保存事件对象引用
    const eventType = e.type;
    fetchData().then(() => {
      console.log(eventType); // 'click'
    });
  };

  return <button onClick={handleClick}>点击</button>;
}

// 为什么移除事件池：
// 1. 现代浏览器性能提升，创建事件对象成本降低
// 2. 简化心智模型，避免persist的困惑
// 3. 更符合开发者预期，减少bug
// 4. 与原生事件行为一致
```

### 3. React事件优化

#### 题目1：如何优化React中的事件处理性能？

**通俗概述：**
React中事件处理的性能优化主要围绕"避免不必要的重新渲染"。就像避免重复做同样的工作一样：用useCallback缓存事件处理函数，用React.memo避免子组件无意义的重渲染，用事件委托处理大量元素，用防抖节流控制触发频率。

**答案：**
**官方文档：**
- useCallback: https://zh-hans.react.dev/reference/react/useCallback
- React.memo: https://zh-hans.react.dev/reference/react/memo
- useMemo: https://zh-hans.react.dev/reference/react/useMemo
```javascript
// 1. 使用useCallback缓存事件处理函数
function OptimizedComponent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  // 没有优化：每次render创建新函数
  const handleClick = () => {
    setCount(count + 1);
  };

  // 使用useCallback优化
  const handleClickOptimized = useCallback(() => {
    setCount(prev => prev + 1);
  }, []); // 依赖项为空，函数永不改变

  // 依赖特定值的处理函数
  const handleTextChange = useCallback((e) => {
    setText(e.target.value);
    // 处理依赖text的逻辑
  }, [text]);

  return (
    <div>
      <ExpensiveChild onClick={handleClickOptimized} />
      <input value={text} onChange={handleTextChange} />
    </div>
  );
}

// 2. 使用React.memo避免不必要的重渲染
const ExpensiveChild = React.memo(({ onClick }) => {
  console.log('ExpensiveChild render');
  return <button onClick={onClick}>点击</button>;
});

// 3. 事件委托优化大量元素
function ListWithDelegation() {
  const [items, setItems] = useState(Array.from({ length: 1000 }, (_, i) => ({
    id: i,
    text: `Item ${i}`
  })));

  // 使用事件委托而不是为每个item绑定事件
  const handleClick = useCallback((e) => {
    const id = e.target.dataset.id;
    if (id) {
      console.log('Clicked item:', id);
    }
  }, []);

  return (
    <ul onClick={handleClick}>
      {items.map(item => (
        <li key={item.id} data-id={item.id}>
          {item.text}
        </li>
      ))}
    </ul>
  );
}

// 4. 防抖和节流
function SearchComponent() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  // 使用useMemo创建防抖函数
  const debouncedSearch = useMemo(
    () => debounce((searchQuery) => {
      // 执行搜索
      fetchResults(searchQuery).then(setResults);
    }, 500),
    []
  );

  const handleSearch = useCallback((e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  }, [debouncedSearch]);

  return (
    <div>
      <input value={query} onChange={handleSearch} placeholder="搜索..." />
      <ResultsList results={results} />
    </div>
  );
}

// 5. 使用ref避免闭包陷阱
function TimerComponent() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  useEffect(() => {
    countRef.current = count;
  }, [count]);

  const handleClick = useCallback(() => {
    setTimeout(() => {
      // 使用ref获取最新值，避免闭包陷阱
      console.log('Current count:', countRef.current);
      setCount(countRef.current + 1);
    }, 3000);
  }, []); // 依赖项为空，但仍能获取最新的count

  return (
    <button onClick={handleClick}>Count: {count}</button>
  );
}
```

### 4. React事件相关Hooks

#### 题目1：如何使用Hooks处理复杂的事件逻辑？

**通俗概述：**
自定义Hook是封装复杂事件逻辑的最佳方式，就像把常用的功能打包成"工具箱"。比如监听鼠标移动、点击外部关闭、按键监听等，都可以封装成Hook，在不同组件中复用。关键是要正确处理事件的绑定和清理，避免内存泄漏。

**答案：**
**官方文档：**
- 自定义Hook: https://zh-hans.react.dev/learn/reusing-logic-with-custom-hooks
- useEffect: https://zh-hans.react.dev/reference/react/useEffect
- useRef: https://zh-hans.react.dev/reference/react/useRef
```javascript
// 1. 自定义Hook封装事件逻辑
function useEventListener(eventName, handler, element = window) {
  const savedHandler = useRef();

  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);

  useEffect(() => {
    const isSupported = element && element.addEventListener;
    if (!isSupported) return;

    const eventListener = (event) => savedHandler.current(event);
    element.addEventListener(eventName, eventListener);

    return () => {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}

// 使用示例
function Component() {
  const [coords, setCoords] = useState({ x: 0, y: 0 });

  useEventListener('mousemove', (e) => {
    setCoords({ x: e.clientX, y: e.clientY });
  });

  return <div>鼠标位置: {coords.x}, {coords.y}</div>;
}

// 2. useClickOutside Hook
function useClickOutside(ref, callback) {
  useEffect(() => {
    function handleClickOutside(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        callback();
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('touchstart', handleClickOutside);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('touchstart', handleClickOutside);
    };
  }, [ref, callback]);
}

// 使用示例
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef();

  useClickOutside(dropdownRef, () => {
    setIsOpen(false);
  });

  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(!isOpen)}>
        Toggle Dropdown
      </button>
      {isOpen && <div>Dropdown Content</div>}
    </div>
  );
}

// 3. useKeyPress Hook
function useKeyPress(targetKey, callback) {
  const [keyPressed, setKeyPressed] = useState(false);

  useEffect(() => {
    function downHandler({ key }) {
      if (key === targetKey) {
        setKeyPressed(true);
        callback && callback();
      }
    }

    function upHandler({ key }) {
      if (key === targetKey) {
        setKeyPressed(false);
      }
    }

    window.addEventListener('keydown', downHandler);
    window.addEventListener('keyup', upHandler);

    return () => {
      window.removeEventListener('keydown', downHandler);
      window.removeEventListener('keyup', upHandler);
    };
  }, [targetKey, callback]);

  return keyPressed;
}

// 使用示例
function Game() {
  const arrowUpPressed = useKeyPress('ArrowUp', () => {
    console.log('向上移动');
  });

  return (
    <div>
      {arrowUpPressed && <div>正在按上箭头</div>}
    </div>
  );
}

// 4. useLongPress Hook
function useLongPress(callback, delay = 500) {
  const [startLongPress, setStartLongPress] = useState(false);
  const timeout = useRef();

  useEffect(() => {
    if (startLongPress) {
      timeout.current = setTimeout(callback, delay);
    } else {
      timeout.current && clearTimeout(timeout.current);
    }

    return () => {
      timeout.current && clearTimeout(timeout.current);
    };
  }, [startLongPress, callback, delay]);

  return {
    onMouseDown: () => setStartLongPress(true),
    onMouseUp: () => setStartLongPress(false),
    onMouseLeave: () => setStartLongPress(false),
    onTouchStart: () => setStartLongPress(true),
    onTouchEnd: () => setStartLongPress(false),
  };
}

// 使用示例
function LongPressButton() {
  const longPressProps = useLongPress(() => {
    alert('长按触发！');
  }, 1000);

  return (
    <button {...longPressProps}>
      长按我
    </button>
  );
}
```

## 四、框架事件机制对比

### 1. 三大框架事件机制对比

#### 题目1：Vue、React、原生JavaScript事件机制的区别？

**通俗概述：**
这是一个经典的对比题。简单说：原生JavaScript最基础但最灵活；Vue提供了丰富的事件修饰符，写起来很简洁；React用合成事件统一了浏览器差异，但语法相对复杂一些。每个都有自己的特色，选择哪个主要看项目需求和团队偏好。

**答案：**

| 特性 | 原生JavaScript | Vue | React |
|------|---------------|-----|-------|
| **事件系统** | 原生DOM事件 | 原生DOM事件 + 自定义事件 | 合成事件系统 |
| **事件绑定** | addEventListener | @事件名 或 v-on | on事件名（驼峰） |
| **事件委托** | 手动实现 | 自动（组件级） | 自动（根容器级） |
| **事件对象** | 原生Event | 原生Event | SyntheticEvent |
| **阻止冒泡** | stopPropagation() | .stop修饰符 | stopPropagation() |
| **阻止默认** | preventDefault() | .prevent修饰符 | preventDefault() |
| **事件修饰符** | 无 | 丰富的修饰符 | 无 |
| **自定义事件** | CustomEvent | $emit | 通过props回调 |

```javascript
// 原生JavaScript
element.addEventListener('click', (e) => {
  e.stopPropagation();
  e.preventDefault();
});

// Vue
<button @click.stop.prevent="handleClick">点击</button>

// React
<button onClick={(e) => {
  e.stopPropagation();
  e.preventDefault();
}}>点击</button>
```

#### 题目2：不同框架中实现相同功能的对比

**通俗概述：**
通过实际例子来对比不同框架的写法差异，比如实现一个删除确认功能。可以看出：原生JavaScript代码最多但最直接；Vue的模板语法很直观；React的函数式写法很现代。每种写法都有自己的优势，关键是要理解各自的设计思路。

**答案：**
```javascript
// 功能：实现一个带确认的删除按钮

// 原生JavaScript
document.getElementById('deleteBtn').addEventListener('click', function(e) {
  e.preventDefault();
  if (confirm('确定要删除吗？')) {
    deleteItem(this.dataset.id);
  }
});

// Vue 3
<template>
  <button @click="handleDelete" :data-id="item.id">
    删除
  </button>
</template>

<script>
export default {
  methods: {
    handleDelete(e) {
      if (confirm('确定要删除吗？')) {
        this.deleteItem(e.target.dataset.id);
      }
    }
  }
};
</script>

// React
function DeleteButton({ itemId, onDelete }) {
  const handleClick = useCallback(() => {
    if (confirm('确定要删除吗？')) {
      onDelete(itemId);
    }
  }, [itemId, onDelete]);

  return (
    <button onClick={handleClick}>
      删除
    </button>
  );
}

// 功能：实现输入框实时搜索（带防抖）

// 原生JavaScript
let timer = null;
const input = document.getElementById('search');
input.addEventListener('input', function(e) {
  clearTimeout(timer);
  timer = setTimeout(() => {
    search(e.target.value);
  }, 500);
});

// Vue 3 Composition API
<template>
  <input v-model="searchQuery" @input="debouncedSearch">
</template>

<script>
import { ref } from 'vue';
import { debounce } from 'lodash';

export default {
  setup() {
    const searchQuery = ref('');

    const debouncedSearch = debounce((e) => {
      search(e.target.value);
    }, 500);

    return {
      searchQuery,
      debouncedSearch
    };
  }
};
</script>

// React
function SearchInput() {
  const [query, setQuery] = useState('');

  const debouncedSearch = useMemo(
    () => debounce((value) => {
      search(value);
    }, 500),
    []
  );

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };

  return (
    <input value={query} onChange={handleChange} />
  );
}
```

### 2. 面试高频问题总结

#### 题目1：事件处理相关的常见性能问题和解决方案？

**通俗概述：**
事件处理中最常见的性能问题就是"太多"和"太频繁"：太多事件监听器会占用内存，太频繁的事件触发会卡顿页面。解决方案就是"合并"和"控制"：用事件委托合并多个监听器，用防抖节流控制触发频率，及时清理不用的监听器避免内存泄漏。

**答案：**
```javascript
// 1. 大量事件监听器问题
// 问题：为1000个按钮绑定点击事件
// 解决：使用事件委托

// 不好
for (let i = 0; i < 1000; i++) {
  document.getElementById(`btn-${i}`).addEventListener('click', handleClick);
}

// 好
document.getElementById('container').addEventListener('click', (e) => {
  if (e.target.matches('.btn')) {
    handleClick(e);
  }
});

// 2. 频繁触发的事件
// 问题：scroll、resize、mousemove等事件触发频率过高
// 解决：防抖或节流

// 防抖 - 适合输入框搜索
const debounce = (fn, delay) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  };
};

// 节流 - 适合滚动、拖拽
const throttle = (fn, delay) => {
  let last = 0;
  return (...args) => {
    const now = Date.now();
    if (now - last >= delay) {
      fn(...args);
      last = now;
    }
  };
};

// 3. 内存泄漏问题
// 问题：未及时移除事件监听器
// 解决：组件卸载时清理

// React
useEffect(() => {
  const handler = () => {};
  window.addEventListener('resize', handler);
  return () => {
    window.removeEventListener('resize', handler);
  };
}, []);

// Vue
export default {
  mounted() {
    window.addEventListener('resize', this.handleResize);
  },
  beforeUnmount() {
    window.removeEventListener('resize', this.handleResize);
  }
};

// 4. 事件处理函数重复创建
// 问题：每次render创建新函数
// 解决：使用useCallback或将函数定义在组件外

// React - 使用useCallback
const handleClick = useCallback(() => {
  // 处理逻辑
}, [dependencies]);

// Vue - 方法自动缓存
methods: {
  handleClick() {
    // 处理逻辑
  }
}
```

#### 题目2：跨框架的事件通信如何实现？

**通俗概述：**
当一个项目中同时使用多个框架时（比如Vue和React共存），它们之间的通信就需要用到"中间人"。最常用的方法是使用原生的CustomEvent或者全局事件总线，就像不同语言的人通过翻译官交流一样。还可以用PostMessage进行iframe间的通信。

**答案：**
```javascript
// 使用原生CustomEvent实现跨框架通信

// 事件总线
class CrossFrameworkEventBus {
  constructor() {
    this.element = document.createElement('div');
    document.body.appendChild(this.element);
  }

  emit(eventName, data) {
    const event = new CustomEvent(eventName, {
      detail: data,
      bubbles: true,
      cancelable: true
    });
    this.element.dispatchEvent(event);
  }

  on(eventName, callback) {
    this.element.addEventListener(eventName, (e) => {
      callback(e.detail);
    });
  }

  off(eventName, callback) {
    this.element.removeEventListener(eventName, callback);
  }
}

const globalBus = new CrossFrameworkEventBus();

// React组件中使用
function ReactComponent() {
  useEffect(() => {
    const handler = (data) => {
      console.log('React received:', data);
    };

    globalBus.on('vue-message', handler);

    return () => {
      globalBus.off('vue-message', handler);
    };
  }, []);

  const sendMessage = () => {
    globalBus.emit('react-message', { from: 'React' });
  };

  return <button onClick={sendMessage}>Send from React</button>;
}

// Vue组件中使用
export default {
  mounted() {
    globalBus.on('react-message', this.handleReactMessage);
  },
  beforeUnmount() {
    globalBus.off('react-message', this.handleReactMessage);
  },
  methods: {
    handleReactMessage(data) {
      console.log('Vue received:', data);
    },
    sendMessage() {
      globalBus.emit('vue-message', { from: 'Vue' });
    }
  }
};

// 使用PostMessage进行iframe通信
// 父窗口
window.addEventListener('message', (e) => {
  if (e.origin !== 'https://trusted-origin.com') return;
  console.log('Received:', e.data);
});

iframe.contentWindow.postMessage({ type: 'HELLO' }, '*');

// 子窗口（iframe）
window.addEventListener('message', (e) => {
  if (e.data.type === 'HELLO') {
    e.source.postMessage({ type: 'RESPONSE' }, e.origin);
  }
});
```

## 五、经典面试题实战

### 题目1：实现一个完整的拖拽功能

**通俗概述：**
拖拽功能是前端开发中的经典需求，考查对鼠标事件、坐标计算、状态管理的综合运用。关键点是：监听mousedown开始拖拽，mousemove更新位置，mouseup结束拖拽。还要考虑触摸设备的兼容性。React中可以封装成自定义Hook，让逻辑更清晰。

**答案：**
```javascript
// 原生JavaScript实现
class Draggable {
  constructor(element) {
    this.element = element;
    this.isDragging = false;
    this.currentX = 0;
    this.currentY = 0;
    this.initialX = 0;
    this.initialY = 0;
    this.xOffset = 0;
    this.yOffset = 0;

    this.init();
  }

  init() {
    this.element.addEventListener('mousedown', this.dragStart.bind(this));
    document.addEventListener('mousemove', this.drag.bind(this));
    document.addEventListener('mouseup', this.dragEnd.bind(this));

    // 触摸事件支持
    this.element.addEventListener('touchstart', this.dragStart.bind(this));
    document.addEventListener('touchmove', this.drag.bind(this));
    document.addEventListener('touchend', this.dragEnd.bind(this));
  }

  dragStart(e) {
    e.preventDefault();

    if (e.type === 'touchstart') {
      this.initialX = e.touches[0].clientX - this.xOffset;
      this.initialY = e.touches[0].clientY - this.yOffset;
    } else {
      this.initialX = e.clientX - this.xOffset;
      this.initialY = e.clientY - this.yOffset;
    }

    if (e.target === this.element) {
      this.isDragging = true;
      this.element.classList.add('dragging');
    }
  }

  drag(e) {
    if (!this.isDragging) return;

    e.preventDefault();

    if (e.type === 'touchmove') {
      this.currentX = e.touches[0].clientX - this.initialX;
      this.currentY = e.touches[0].clientY - this.initialY;
    } else {
      this.currentX = e.clientX - this.initialX;
      this.currentY = e.clientY - this.initialY;
    }

    this.xOffset = this.currentX;
    this.yOffset = this.currentY;

    this.setTranslate(this.currentX, this.currentY);
  }

  dragEnd(e) {
    this.initialX = this.currentX;
    this.initialY = this.currentY;
    this.isDragging = false;
    this.element.classList.remove('dragging');
  }

  setTranslate(xPos, yPos) {
    this.element.style.transform = `translate(${xPos}px, ${yPos}px)`;
  }
}

// React Hook实现
function useDraggable() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

  const handleMouseDown = useCallback((e) => {
    setIsDragging(true);
    setDragStart({
      x: e.clientX - position.x,
      y: e.clientY - position.y
    });
  }, [position]);

  useEffect(() => {
    if (!isDragging) return;

    const handleMouseMove = (e) => {
      setPosition({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y
      });
    };

    const handleMouseUp = () => {
      setIsDragging(false);
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging, dragStart]);

  return {
    position,
    isDragging,
    handleMouseDown,
    style: {
      transform: `translate(${position.x}px, ${position.y}px)`,
      cursor: isDragging ? 'grabbing' : 'grab'
    }
  };
}

// 使用
function DraggableComponent() {
  const { position, isDragging, handleMouseDown, style } = useDraggable();

  return (
    <div
      onMouseDown={handleMouseDown}
      style={style}
      className={isDragging ? 'dragging' : ''}
    >
      拖拽我
    </div>
  );
}
```

### 题目2：实现一个图片懒加载功能

**通俗概述：**
图片懒加载是优化页面性能的重要手段，只有当图片进入视口时才开始加载。现代做法是使用IntersectionObserver API，比传统的scroll事件监听性能更好。核心思路是：观察图片元素，当进入可视区域时，将data-src赋值给src属性开始加载。

**答案：**
```javascript
// 使用IntersectionObserver实现
class LazyLoad {
  constructor(options = {}) {
    this.options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1,
      ...options
    };

    this.observer = null;
    this.init();
  }

  init() {
    if (!('IntersectionObserver' in window)) {
      // 降级处理
      this.loadAllImages();
      return;
    }

    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      this.options
    );

    this.observeImages();
  }

  observeImages() {
    const images = document.querySelectorAll('[data-src]');
    images.forEach(img => this.observer.observe(img));
  }

  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadImage(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }

  loadImage(img) {
    const src = img.dataset.src;
    if (!src) return;

    // 创建新图片对象预加载
    const tempImg = new Image();
    tempImg.onload = () => {
      img.src = src;
      img.classList.add('loaded');
      delete img.dataset.src;
    };
    tempImg.onerror = () => {
      img.classList.add('error');
    };
    tempImg.src = src;
  }

  loadAllImages() {
    const images = document.querySelectorAll('[data-src]');
    images.forEach(img => this.loadImage(img));
  }

  destroy() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
}

// React组件实现
function LazyImage({ src, placeholder, alt, ...props }) {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [isLoading, setIsLoading] = useState(true);
  const imgRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = new Image();
            img.onload = () => {
              setImageSrc(src);
              setIsLoading(false);
            };
            img.src = src;
            observer.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => {
      if (imgRef.current) {
        observer.unobserve(imgRef.current);
      }
    };
  }, [src]);

  return (
    <img
      ref={imgRef}
      src={imageSrc}
      alt={alt}
      className={isLoading ? 'loading' : 'loaded'}
      {...props}
    />
  );
}

// Vue 3指令实现
app.directive('lazy', {
  mounted(el, binding) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = binding.value;
          img.classList.add('loaded');
          observer.unobserve(img);
        }
      });
    });

    observer.observe(el);
    el._observer = observer;
  },
  unmounted(el) {
    if (el._observer) {
      el._observer.disconnect();
      delete el._observer;
    }
  }
});

// 使用
<img v-lazy="imageSrc" alt="Lazy loaded image">
```

### 题目3：实现一个虚拟滚动列表

**通俗概述：**
虚拟滚动是处理大量数据列表的经典方案，核心思想是"只渲染可见的部分"。就像看书一样，你只需要看当前这一页，不需要把整本书都摊开。通过监听滚动事件，动态计算哪些项目应该显示，大大提升了性能。

**答案：**
```javascript
// React实现虚拟滚动
function VirtualList({ items, itemHeight, containerHeight, renderItem }) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // 计算可见区域的起始和结束索引
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    items.length - 1,
    Math.floor((scrollTop + containerHeight) / itemHeight)
  );

  // 可见项
  const visibleItems = items.slice(startIndex, endIndex + 1);

  // 总高度
  const totalHeight = items.length * itemHeight;

  // 偏移量
  const offsetY = startIndex * itemHeight;

  const handleScroll = (e) => {
    setScrollTop(e.target.scrollTop);
  };

  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: 'auto',
        position: 'relative'
      }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div
          style={{
            transform: `translateY(${offsetY}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0
          }}
        >
          {visibleItems.map((item, index) => (
            <div
              key={startIndex + index}
              style={{ height: itemHeight }}
            >
              {renderItem(item, startIndex + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// 使用示例
function App() {
  const items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    text: `Item ${i}`
  }));

  return (
    <VirtualList
      items={items}
      itemHeight={50}
      containerHeight={500}
      renderItem={(item) => (
        <div style={{ padding: '10px', borderBottom: '1px solid #ccc' }}>
          {item.text}
        </div>
      )}
    />
  );
}
```

## 总结

以上就是前端事件机制的高频面试题汇总，涵盖了JavaScript原生事件、Vue事件系统、React事件系统等核心知识点。掌握这些内容对于前端开发和面试都非常重要。

重点掌握：
1. 事件流的三个阶段和事件委托原理
2. 事件对象的常用属性和方法
3. 自定义事件和发布订阅模式
4. Vue的事件修饰符和组件通信
5. React的合成事件系统
6. 事件性能优化技巧
7. 跨框架事件通信方案