# HTTP缓存和跨域经典面试题

## 一、强缓存

### 1. 什么是强缓存？强缓存的实现原理？

**答案：**
强缓存是指浏览器直接从本地缓存中获取资源，不需要向服务器发送请求。当强缓存生效时，浏览器直接返回200状态码（from cache）。

**两种实现方式：**

**1. Expires（HTTP/1.0）**
```http
# 服务器响应头
HTTP/1.1 200 OK
Expires: Wed, 21 Oct 2025 07:28:00 GMT
Content-Type: text/html

# 缺点：
# 1. 使用绝对时间，依赖客户端时间
# 2. 客户端时间被修改会导致缓存失效
# 3. 写法复杂，容易出错
```

**2. Cache-Control（HTTP/1.1）**
```http
# 服务器响应头
HTTP/1.1 200 OK
Cache-Control: max-age=31536000  # 缓存一年
Content-Type: text/css

# 常用指令：
# max-age=秒数：缓存最大有效时间
# no-cache：需要协商缓存验证
# no-store：不缓存
# private：只能被浏览器缓存
# public：可以被任何缓存（包括CDN）
# must-revalidate：缓存过期后必须验证
```

### 2. 强缓存的常见配置场景

**场景1：静态资源长期缓存**
```javascript
// 带hash的静态资源，可以设置长期缓存
app.use('/static', express.static('public', {
  setHeaders: (res, path) => {
    if (path.includes('.') && path.match(/\.[0-9a-f]{8}\./)) {
      // app.12345678.js 这种带hash的文件
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    }
  }
}));
```

**场景2：HTML文件不缓存**
```javascript
// HTML文件需要每次检查更新
app.get('/*.html', (req, res) => {
  res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
  res.setHeader('Pragma', 'no-cache'); // HTTP/1.0兼容
  res.setHeader('Expires', '0');
  res.sendFile(path.join(__dirname, 'index.html'));
});
```

**场景3：API接口缓存策略**
```javascript
// API数据缓存5分钟
app.get('/api/data', (req, res) => {
  res.setHeader('Cache-Control', 'private, max-age=300');
  res.json(data);
});

// 用户相关接口不缓存
app.get('/api/user', (req, res) => {
  res.setHeader('Cache-Control', 'no-store');
  res.json(userData);
});
```

### 3. 强缓存失效的判断流程

```javascript
// 浏览器缓存判断流程
function shouldUseCache(request, cachedResponse) {
  // 1. 检查Cache-Control
  const cacheControl = cachedResponse.headers['cache-control'];
  if (cacheControl) {
    const maxAge = parseMaxAge(cacheControl);
    const age = Date.now() - cachedResponse.timestamp;
    if (age < maxAge * 1000) {
      return true; // 使用强缓存
    }
  }

  // 2. 检查Expires（Cache-Control优先级更高）
  const expires = cachedResponse.headers['expires'];
  if (expires && new Date(expires) > new Date()) {
    return true; // 使用强缓存
  }

  return false; // 强缓存失效，走协商缓存
}
```

### 4. 强缓存的应用场景

**场景1：静态资源文件（带hash）**
```javascript
// 适用：JS、CSS、图片等带版本号或hash的静态文件
// 策略：设置长期缓存（1年）
app.use('/static', express.static('public', {
  setHeaders: (res, path) => {
    // main.a8b2c3d4.js, style.5e6f7g8h.css
    if (path.match(/\.[0-9a-f]{8}\./)) {
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    }
  }
}));

// immutable表示文件内容永不改变，避免用户刷新时的重新验证
```

**场景2：字体文件**
```javascript
// 字体文件体积较大，变化频率低
app.get(/\.(woff2?|ttf|otf|eot)$/, (req, res) => {
  res.setHeader('Cache-Control', 'public, max-age=2592000'); // 缓存30天
  res.setHeader('Access-Control-Allow-Origin', '*'); // 字体需要处理跨域
});
```

**场景3：图片资源**
```javascript
// 产品图片、Logo等
app.get('/images/*', (req, res) => {
  // Logo、图标等不常变化的图片
  if (req.path.includes('logo') || req.path.includes('icons')) {
    res.setHeader('Cache-Control', 'public, max-age=604800'); // 7天
  }
  // 用户上传的图片、头像等
  else if (req.path.includes('user-uploads')) {
    res.setHeader('Cache-Control', 'private, max-age=86400'); // 1天，仅浏览器缓存
  }
  // 临时活动图片
  else if (req.path.includes('campaign')) {
    res.setHeader('Cache-Control', 'public, max-age=3600'); // 1小时
  }
});
```

**场景4：第三方库和框架**
```javascript
// CDN上的第三方库（jQuery、React、Vue等）
// 这些库版本固定，可以设置长期缓存
app.get('/vendor/*.js', (req, res) => {
  res.setHeader('Cache-Control', 'public, max-age=31536000');
  // 配合CDN使用效果更好
});

// 或者使用公共CDN
<script src="https://cdn.jsdelivr.net/npm/vue@3.2.45/dist/vue.global.prod.js"></script>
// CDN通常已配置好强缓存
```

**场景5：离线应用（Service Worker配合）**
```javascript
// Service Worker中的缓存策略
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // 优先使用缓存（Cache First策略）
      if (response) {
        return response;
      }
      return fetch(event.request).then((response) => {
        // 缓存新资源
        if (response.status === 200) {
          const responseClone = response.clone();
          caches.open('v1').then((cache) => {
            cache.put(event.request, responseClone);
          });
        }
        return response;
      });
    })
  );
});
```

**场景6：视频/音频文件**
```javascript
// 大文件缓存策略
app.get('/media/*', (req, res) => {
  const filePath = path.join(__dirname, 'media', req.params[0]);
  const stat = fs.statSync(filePath);

  // 支持范围请求（视频播放进度条）
  res.setHeader('Accept-Ranges', 'bytes');
  res.setHeader('Cache-Control', 'public, max-age=86400'); // 缓存1天

  // 处理部分内容请求
  const range = req.headers.range;
  if (range) {
    // 返回206 Partial Content
    const parts = range.replace(/bytes=/, "").split("-");
    const start = parseInt(parts[0], 10);
    const end = parts[1] ? parseInt(parts[1], 10) : stat.size - 1;

    res.status(206);
    res.setHeader('Content-Range', `bytes ${start}-${end}/${stat.size}`);
    res.setHeader('Content-Length', (end - start) + 1);

    const stream = fs.createReadStream(filePath, { start, end });
    stream.pipe(res);
  } else {
    res.setHeader('Content-Length', stat.size);
    fs.createReadStream(filePath).pipe(res);
  }
});
```

**场景7：移动端应用资源**
```javascript
// 移动端网络环境考虑
app.use((req, res, next) => {
  const userAgent = req.headers['user-agent'];
  const isMobile = /Mobile|Android|iPhone/i.test(userAgent);

  if (isMobile) {
    // 移动端设置更长的缓存时间，减少流量消耗
    if (req.path.match(/\.(jpg|jpeg|png|gif|webp)$/)) {
      res.setHeader('Cache-Control', 'public, max-age=604800'); // 7天
    }
    if (req.path.match(/\.(js|css)$/)) {
      res.setHeader('Cache-Control', 'public, max-age=2592000'); // 30天
    }
  }
  next();
});
```

**场景8：API接口数据缓存**
```javascript
// 不同类型API的缓存策略
// 配置数据、字典数据等不常变化的接口
app.get('/api/config', (req, res) => {
  res.setHeader('Cache-Control', 'public, max-age=3600'); // 缓存1小时
  res.json(configData);
});

// 商品列表等更新频率适中的接口
app.get('/api/products', (req, res) => {
  res.setHeader('Cache-Control', 'private, max-age=300'); // 缓存5分钟
  res.json(products);
});

// 股票行情等实时数据
app.get('/api/stock-price', (req, res) => {
  res.setHeader('Cache-Control', 'no-cache'); // 使用协商缓存
  res.json(stockData);
});

// 用户个人信息等敏感数据
app.get('/api/user/profile', (req, res) => {
  res.setHeader('Cache-Control', 'no-store'); // 完全不缓存
  res.json(userProfile);
});
```

**最佳实践总结：**

1. **HTML文件**：通常不设置强缓存或设置很短的缓存时间，确保用户能获取最新版本
2. **CSS/JS文件**：配合webpack等构建工具生成hash文件名，设置长期强缓存
3. **图片资源**：根据更新频率设置不同的缓存时间（Logo长期缓存，用户头像短期缓存）
4. **字体文件**：设置较长的缓存时间（通常30天到1年）
5. **API数据**：根据业务特性选择合适的缓存策略
6. **第三方库**：使用CDN并设置长期缓存
7. **大文件**：合理设置缓存时间，配合范围请求优化体验

### 5. 强缓存的常见面试题

**Q1：Expires和Cache-Control的区别？**
```javascript
// Expires：HTTP/1.0，绝对时间
Expires: Wed, 21 Oct 2025 07:28:00 GMT

// Cache-Control：HTTP/1.1，相对时间
Cache-Control: max-age=86400

// 两者同时存在时，Cache-Control优先级更高
```

**Q2：如何处理缓存更新问题？**
```javascript
// 1. 文件名加hash
// webpack配置
output: {
  filename: '[name].[contenthash:8].js'
}

// 2. 版本号查询参数
<link rel="stylesheet" href="/style.css?v=1.0.1">

// 3. HTML meta标签（不推荐，只对HTML有效）
<meta http-equiv="Cache-Control" content="no-cache">
```

**Q3：private和public的区别？**
```javascript
// private：只能被浏览器缓存
Cache-Control: private, max-age=300
// 适用场景：用户个人数据

// public：可以被任何中间代理缓存
Cache-Control: public, max-age=3600
// 适用场景：静态资源、公共数据
```

**Q4：no-cache和no-store的区别？**
```javascript
// no-cache：可以缓存，但使用前必须验证
Cache-Control: no-cache
// 效果：强制走协商缓存

// no-store：完全不缓存
Cache-Control: no-store
// 效果：每次都请求最新资源
```

## 二、协商缓存

### 1. 什么是协商缓存？协商缓存的实现原理？

📝 **面试背诵要点：**

**定义：**
- 协商缓存是需要与服务器"协商"确认的缓存机制
- 当强缓存失效后，浏览器携带缓存标识向服务器发送请求
- 服务器根据缓存标识判断资源是否更新

**实现原理流程：**
1. 首次请求：服务器返回资源和缓存标识（Last-Modified或ETag）
2. 再次请求：浏览器带上缓存标识（If-Modified-Since或If-None-Match）
3. 服务器判断：
   - 资源未变化 → 返回304 Not Modified
   - 资源已变化 → 返回200和新资源

**两种协商缓存实现方式：**

### 2. 协商缓存的两种实现方法

**1. Last-Modified / If-Modified-Since（基于时间）**

📝 **实现原理：**
- **Last-Modified**：服务器返回资源最后修改时间
- **If-Modified-Since**：浏览器询问此时间后资源是否修改
- 服务器比较文件修改时间，决定返回304还是200

**优点：**
- 实现简单，性能开销小
- 时间戳人类可读，便于调试

**缺点：**
- 精度只到秒级，1秒内多次修改无法识别
- 文件内容未变但修改时间变了会导致缓存失效
- 分布式服务器时间同步问题
```http
# 首次请求响应头
HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
Cache-Control: no-cache

# 再次请求请求头
GET /api/data HTTP/1.1
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT

# 服务器响应
HTTP/1.1 304 Not Modified
```

2. **ETag / If-None-Match（基于内容）**

📝 **实现原理：**
- **ETag**：服务器返回资源的唯一标识（通常是内容hash）
- **If-None-Match**：浏览器询问资源标识是否改变
- 服务器比较ETag值，决定返回304还是200

**优点：**
- 精确度高，只要内容变化就能检测
- 不受时间影响，解决分布式问题
- 可以识别内容相同但时间不同的情况

**缺点：**
- 需要计算hash值，服务器开销较大
- ETag生成算法可能因服务器而异

```http
# 首次请求响应头
HTTP/1.1 200 OK
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Cache-Control: no-cache

# 再次请求请求头
GET /api/data HTTP/1.1
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"

# 服务器响应
HTTP/1.1 304 Not Modified
```

### 3. 协商缓存的具体实现代码

```javascript
// Node.js服务端实现Last-Modified
app.get('/api/data', (req, res) => {
  const stats = fs.statSync('./data.json');
  const lastModified = stats.mtime.toUTCString();

  // 设置协商缓存
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Last-Modified', lastModified);

  // 检查是否命中缓存
  if (req.headers['if-modified-since'] === lastModified) {
    res.status(304).end();
    return;
  }

  res.json(data);
});

// Node.js服务端实现ETag
const crypto = require('crypto');

app.get('/api/resource', (req, res) => {
  const content = fs.readFileSync('./resource.txt');
  const hash = crypto.createHash('md5').update(content).digest('hex');
  const etag = `"${hash}"`;

  // 设置协商缓存
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('ETag', etag);

  // 检查是否命中缓存
  if (req.headers['if-none-match'] === etag) {
    res.status(304).end();
    return;
  }

  res.send(content);
});

// 同时使用Last-Modified和ETag（ETag优先级更高）
app.get('/api/both', (req, res) => {
  const stats = fs.statSync('./data.json');
  const lastModified = stats.mtime.toUTCString();
  const content = fs.readFileSync('./data.json');
  const etag = `"${crypto.createHash('md5').update(content).digest('hex')}"`;

  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Last-Modified', lastModified);
  res.setHeader('ETag', etag);

  // ETag优先判断
  if (req.headers['if-none-match'] === etag) {
    res.status(304).end();
    return;
  }

  // 其次判断Last-Modified
  if (req.headers['if-modified-since'] === lastModified) {
    res.status(304).end();
    return;
  }

  res.json(JSON.parse(content));
});
```

### 4. Last-Modified和ETag的区别？

**答案：**

| 特性 | Last-Modified | ETag |
|------|---------------|------|
| **精度** | 秒级精度 | 任意精度 |
| **性能** | 性能更好 | 需要计算哈希值 |
| **分布式** | 不适合分布式系统 | 适合分布式系统 |
| **文件变化** | 只检测内容变化 | 检测内容和元数据变化 |
| **实现复杂度** | 简单 | 相对复杂 |

**ETag的优势：**
1. 可以检测文件内容变化，即使修改时间相同
2. 支持分布式系统，避免时间同步问题
3. 可以检测文件元数据变化（如权限）

**Last-Modified的优势：**
1. 实现简单，性能开销小
2. 人类可读，便于调试

### 3. 强缓存 vs 协商缓存对比

**答案：**

| 对比项 | 强缓存 | 协商缓存 |
|--------|--------|----------|
| **是否发送请求** | 不发送请求 | 发送请求 |
| **状态码** | 200 (from cache) | 304 (Not Modified) |
| **实现方式** | Expires、Cache-Control | Last-Modified/If-Modified-Since、ETag/If-None-Match |
| **优先级** | 优先级高 | 强缓存失效后才使用 |
| **网络开销** | 无 | 有请求但无响应体 |
| **适用场景** | 静态资源、不常变化的文件 | 需要实时性的资源 |

**缓存决策流程：**
```javascript
// 浏览器缓存决策过程
function getCachedResource(url) {
  const cache = getCache(url);

  // 1. 先判断强缓存
  if (cache && isStrongCacheValid(cache)) {
    return cache.data; // 200 from cache
  }

  // 2. 强缓存失效，判断协商缓存
  if (cache && cache.etag) {
    const response = fetch(url, {
      headers: {
        'If-None-Match': cache.etag,
        'If-Modified-Since': cache.lastModified
      }
    });

    if (response.status === 304) {
      return cache.data; // 使用缓存
    }
  }

  // 3. 缓存都失效，获取新资源
  return fetchNewResource(url);
}
```

**最佳实践组合：**
```javascript
// 静态资源：强缓存 + 文件hash
app.use('/static', (req, res) => {
  // app.a3b4c5d6.js
  res.setHeader('Cache-Control', 'public, max-age=31536000');
});

// HTML文件：协商缓存
app.get('/*.html', (req, res) => {
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('ETag', generateETag(content));
  res.setHeader('Last-Modified', lastModified);
});

// API接口：短时间强缓存 + 协商缓存
app.get('/api/data', (req, res) => {
  res.setHeader('Cache-Control', 'private, max-age=60');
  res.setHeader('ETag', generateETag(data));
});
```

### 4. 协商缓存的经典面试题场景？

**答案：**

**场景1：文件内容未变化，但修改时间变化**
```javascript
// 问题：文件内容相同，但touch命令修改了时间
// Last-Modified会认为文件已变化，导致不必要的下载
// ETag可以正确识别内容未变化

// 解决方案：优先使用ETag，Last-Modified作为备选
if (request.headers['if-none-match'] === currentETag) {
  return 304; // 使用缓存
} else if (request.headers['if-modified-since'] === lastModified) {
  return 304; // 使用缓存
} else {
  return 200; // 返回新内容
}
```

**场景2：分布式系统中的缓存一致性问题**
```javascript
// 问题：多台服务器时间不同步
// 解决方案：使用ETag而不是Last-Modified

// 服务器A
const etagA = generateETag(content); // "abc123"

// 服务器B  
const etagB = generateETag(content); // "abc123" (相同内容)

// 即使时间不同步，ETag也能正确判断
```

**场景3：CDN边缘节点的缓存策略**
```javascript
// CDN节点缓存策略
app.get('/api/data', (req, res) => {
  const etag = generateETag(data);
  const lastModified = new Date(fileStats.mtime).toUTCString();
  
  // 设置缓存头
  res.set({
    'ETag': etag,
    'Last-Modified': lastModified,
    'Cache-Control': 'no-cache' // 强制协商缓存
  });
  
  // 检查协商缓存
  if (req.headers['if-none-match'] === etag) {
    return res.status(304).end();
  }
  
  if (req.headers['if-modified-since'] === lastModified) {
    return res.status(304).end();
  }
  
  res.json(data);
});
```

## 二、跨域问题

### 1. 什么是跨域？为什么会出现跨域问题？

**答案：**
跨域是指浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的。

**同源策略限制：**
- 协议相同（http/https）
- 域名相同
- 端口相同

**跨域场景示例：**
```javascript
// 同源：http://localhost:3000
// 跨域：https://localhost:3000 (协议不同)
// 跨域：http://localhost:8080 (端口不同)  
// 跨域：http://api.example.com (域名不同)
```

**为什么需要同源策略：**
1. **防止CSRF攻击**：恶意网站无法获取用户在其他网站的数据
2. **保护用户隐私**：防止恶意网站读取用户敏感信息
3. **维护数据安全**：防止恶意网站篡改其他网站的数据

### 2. 跨域的解决方案有哪些？

**答案：**

**1. CORS（跨域资源共享）**

📝 **面试背诵要点：**
- **定义**：CORS是W3C标准，通过服务器设置响应头来告诉浏览器允许哪些跨域请求
- **核心原理**：服务端在响应头中添加Access-Control-*字段，浏览器据此判断是否允许跨域
- **主要响应头**：
  - `Access-Control-Allow-Origin`：允许的源
  - `Access-Control-Allow-Methods`：允许的HTTP方法
  - `Access-Control-Allow-Headers`：允许的请求头
  - `Access-Control-Allow-Credentials`：是否允许携带Cookie
  - `Access-Control-Max-Age`：预检请求缓存时间
- **优点**：
  - 支持所有HTTP方法
  - 安全可控，可精确配置
  - 是现代浏览器推荐的跨域解决方案
- **缺点**：
  - 需要服务端配合设置
  - 老版本浏览器不支持（IE10以下）

```javascript
// 服务端设置CORS头
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*'); // 允许所有域名
  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization');
  res.header('Access-Control-Allow-Credentials', 'true'); // 允许携带cookie

  // 预检请求处理
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

// 客户端请求
fetch('http://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  },
  credentials: 'include', // 携带cookie
  body: JSON.stringify(data)
});
```

**2. JSONP（JSON with Padding）**

📝 **面试背诵要点：**
- **原理**：利用`<script>`标签不受同源策略限制的特点，动态创建script标签请求跨域资源
- **核心思想**：将数据包装在函数调用中，作为JavaScript代码执行
- **实现步骤**：
  1. 客户端定义回调函数
  2. 创建script标签，src指向跨域API并传递回调函数名
  3. 服务端返回函数调用形式的数据
  4. 浏览器自动执行返回的JavaScript代码
- **优点**：
  - 兼容性好，支持老版本浏览器（IE6+）
  - 实现简单，不需要额外配置
  - 不需要XMLHttpRequest对象
- **缺点**：
  - 只支持GET请求（因为是通过URL传参）
  - 存在安全隐患（XSS攻击、CSRF攻击）
  - 错误处理困难（没有HTTP状态码）
  - 需要服务端配合
  - 只能传输JSON数据
  - 无法获取响应头信息

**JSONP的工作流程详解：**
```javascript
// 1. 浏览器端请求过程
// 原始请求：http://api.example.com/data
// JSONP请求：http://api.example.com/data?callback=handleData

// 2. 服务器返回数据格式对比
// 普通JSON返回：
{
  "name": "张三",
  "age": 25
}

// JSONP返回（包装成函数调用）：
handleData({
  "name": "张三",
  "age": 25
})

// 3. 浏览器执行返回的JavaScript代码
// 相当于执行：handleData({"name": "张三", "age": 25})
```

**JSONP完整示例 - 获取天气信息：**

```html
<!-- 前端页面：http://localhost:3000/index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>JSONP示例 - 天气查询</title>
</head>
<body>
    <h1>天气查询</h1>
    <button onclick="getWeather()">获取北京天气</button>
    <div id="result"></div>

    <script>
        // 步骤1：定义全局回调函数
        function handleWeatherData(data) {
            console.log('收到天气数据:', data);

            // 步骤5：处理返回的数据
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `
                <h2>${data.city}天气</h2>
                <p>温度: ${data.temp}°C</p>
                <p>天气: ${data.weather}</p>
                <p>风力: ${data.wind}</p>
                <p>更新时间: ${data.updateTime}</p>
            `;

            // 步骤6：清理script标签
            const script = document.getElementById('jsonp-script');
            if (script) {
                document.body.removeChild(script);
            }
        }

        function getWeather() {
            // 步骤2：创建script标签
            const script = document.createElement('script');
            script.id = 'jsonp-script';

            // 步骤3：设置src，指向跨域API，带上callback参数
            // 告诉服务器：请用handleWeatherData函数包装数据
            script.src = 'http://api.weather.com/beijing?callback=handleWeatherData';

            // 步骤4：将script标签添加到页面
            // 浏览器会立即发起请求
            document.body.appendChild(script);
        }
    </script>
</body>
</html>
```

```javascript
// 后端服务器代码：http://api.weather.com
// Node.js + Express 示例

const express = require('express');
const app = express();

// 天气API接口
app.get('/beijing', (req, res) => {
    // 获取callback参数名
    const callbackName = req.query.callback;

    // 天气数据
    const weatherData = {
        city: '北京',
        temp: 25,
        weather: '晴',
        wind: '微风',
        updateTime: new Date().toLocaleString()
    };

    // 判断是否是JSONP请求
    if (callbackName) {
        // JSONP请求：返回函数调用
        // 返回的内容：handleWeatherData({"city":"北京","temp":25,...})
        res.type('text/javascript');
        res.send(`${callbackName}(${JSON.stringify(weatherData)})`);
    } else {
        // 普通请求：返回JSON
        res.json(weatherData);
    }
});

app.listen(8080, () => {
    console.log('Weather API running on http://api.weather.com');
});
```

**JSONP执行过程图解：**
```text
用户点击按钮
    ↓
1. 创建<script>标签
    ↓
2. 设置src="http://api.weather.com/beijing?callback=handleWeatherData"
    ↓
3. 浏览器发起GET请求（注意：script标签不受同源策略限制）
    ↓
4. 服务器收到请求，识别callback参数
    ↓
5. 服务器返回：handleWeatherData({"city":"北京","temp":25,...})
    ↓
6. 浏览器接收到响应，作为JavaScript代码执行
    ↓
7. 执行全局函数handleWeatherData，传入数据
    ↓
8. 在回调函数中处理数据，更新页面
```

**实际案例 - 百度搜索建议：**
```html
<!-- 百度搜索建议的JSONP实现 -->
<input type="text" id="search" placeholder="输入搜索内容">
<div id="suggestions"></div>

<script>
    // 百度的回调函数名是固定的
    window.baidu = {
        sug: function(data) {
            const suggestions = data.s;
            const html = suggestions.map(item =>
                `<div>${item}</div>`
            ).join('');
            document.getElementById('suggestions').innerHTML = html;
        }
    };

    document.getElementById('search').addEventListener('input', function(e) {
        const keyword = e.target.value;
        if (!keyword) return;

        // 移除之前的script
        const oldScript = document.getElementById('baidu-sug');
        if (oldScript) {
            document.body.removeChild(oldScript);
        }

        // 创建新的script请求百度建议API
        const script = document.createElement('script');
        script.id = 'baidu-sug';
        // 百度搜索建议接口（真实可用）
        script.src = `https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=${keyword}&cb=baidu.sug`;
        document.body.appendChild(script);
    });
</script>
```

**为什么JSONP能跨域？核心原理：**
```javascript
// 同源策略限制的是：
// 1. AJAX请求（XMLHttpRequest、fetch）
// 2. DOM访问
// 3. Cookie、LocalStorage等存储

// 同源策略不限制的是：
// 1. <script src="...">  ✓ 可以加载跨域JS文件
// 2. <img src="...">     ✓ 可以加载跨域图片
// 3. <link href="...">   ✓ 可以加载跨域CSS

// JSONP就是利用<script>标签可以跨域加载JS的特性
// 把数据伪装成JS代码（函数调用）返回
```

**JSONP vs CORS 对比：**

| 特性 | JSONP | CORS |
|------|-------|------|
| **浏览器兼容性** | 所有浏览器 | IE10+ |
| **请求方法** | 仅GET | 所有HTTP方法 |
| **错误处理** | 困难（超时判断） | 完善（HTTP状态码） |
| **安全性** | 较低（容易XSS） | 较高（浏览器验证） |
| **实现复杂度** | 简单 | 需要服务端配置 |
| **数据格式** | 仅JSON | 任意格式 |
| **请求控制** | 无法设置请求头 | 可以自定义请求头 |

**JSONP安全问题及防范：**
```javascript
// 安全问题1：XSS攻击
// 恶意服务器返回恶意代码而非预期数据
// 防范：验证返回源，使用CSP策略

// 安全问题2：敏感数据泄露
// JSONP请求会携带Cookie，可能泄露用户信息
// 防范：敏感接口不使用JSONP

// 安全的JSONP实现
function safeJsonp(url, options = {}) {
  return new Promise((resolve, reject) => {
    const timeout = options.timeout || 5000;
    const callbackName = options.callbackName ||
      `jsonp_${Date.now()}_${Math.floor(Math.random() * 10000)}`;

    let timeoutId;

    // 定义全局回调函数
    window[callbackName] = function(data) {
      resolve(data);
      cleanup();
    };

    // 清理函数
    const cleanup = () => {
      if (timeoutId) clearTimeout(timeoutId);
      if (script.parentNode) {
        document.body.removeChild(script);
      }
      delete window[callbackName];
    };

    // 超时处理
    timeoutId = setTimeout(() => {
      reject(new Error('JSONP request timeout'));
      cleanup();
    }, timeout);

    // 创建script标签
    const script = document.createElement('script');
    script.src = `${url}${url.includes('?') ? '&' : '?'}callback=${callbackName}`;
    script.onerror = () => {
      reject(new Error('JSONP request failed'));
      cleanup();
    };

    document.body.appendChild(script);
  });
}

// 使用示例
safeJsonp('http://api.example.com/data', { timeout: 3000 })
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

**JSONP的实际应用场景：**
1. **第三方API调用**：百度搜索建议、天气API等公开服务
2. **统计分析**：Google Analytics等第三方统计服务
3. **社交分享**：获取分享数、点赞数等社交数据
4. **广告投放**：广告内容的跨域加载
5. **旧系统兼容**：需要支持IE8及以下版本的场景

```javascript
// 客户端
function jsonp(url, callback) {
  const script = document.createElement('script');
  const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());

  window[callbackName] = function(data) {
    callback(data);
    document.body.removeChild(script);
    delete window[callbackName];
  };

  script.src = url + '?callback=' + callbackName;
  document.body.appendChild(script);
}

// 使用
jsonp('http://api.example.com/data?callback=handleData', function(data) {
  console.log(data);
});

// 服务端
app.get('/data', (req, res) => {
  const data = { message: 'Hello World' };
  const callback = req.query.callback;
  res.send(`${callback}(${JSON.stringify(data)});`);
});
```

**3. 代理服务器**

📝 **面试背诵要点：**
- **原理**：同源策略是浏览器的限制，服务器之间没有跨域限制。通过同域的代理服务器转发请求
- **实现方式**：
  1. 开发环境：webpack-dev-server、vite等开发服务器的proxy配置
  2. 生产环境：Nginx反向代理
  3. Node.js中间层代理
- **工作流程**：
  1. 前端请求同域的代理接口
  2. 代理服务器转发请求到目标服务器
  3. 目标服务器返回数据给代理服务器
  4. 代理服务器返回数据给前端
- **优点**：
  - 前端无需任何修改
  - 可以灵活处理请求和响应
  - 可以隐藏真实的服务器地址
- **缺点**：
  - 需要额外的代理服务器
  - 增加了请求的延迟

```javascript
// webpack devServer代理
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://api.example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};

// nginx代理
server {
  listen 80;
  server_name localhost;

  location /api/ {
    proxy_pass http://api.example.com/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
  }
}
```

**4. postMessage**

📝 **面试背诵要点：**
- **作用**：HTML5新增API，用于不同源的窗口间安全通信
- **适用场景**：
  - 页面与iframe之间的通信
  - 页面与弹出窗口的通信
  - 多个标签页之间的通信
- **API使用**：
  - 发送：`targetWindow.postMessage(data, targetOrigin)`
  - 接收：`window.addEventListener('message', handler)`
- **安全性**：
  - 必须验证`event.origin`确保消息来源可信
  - 指定明确的`targetOrigin`而非使用'*'
- **优点**：
  - 安全可靠，浏览器原生支持
  - 可以传递结构化数据
- **缺点**：
  - 只能用于窗口间通信
  - IE8/9只支持字符串数据

```javascript
// 父页面
window.addEventListener('message', function(event) {
  if (event.origin !== 'http://trusted-domain.com') return;
  console.log('收到消息:', event.data);
});

// 子页面（iframe）
parent.postMessage('Hello Parent', 'http://parent-domain.com');
```

**5. WebSocket**

📝 **面试背诵要点：**
- **原理**：WebSocket协议本身不受同源策略限制，可以与任何域进行通信
- **特点**：
  - 建立连接时可以跨域
  - 全双工通信，性能高
  - 持久连接，适合实时通信
- **使用场景**：
  - 实时聊天应用
  - 股票行情推送
  - 在线协作工具
  - 游戏应用
- **安全性**：服务端需要验证Origin头来确保安全

```javascript
// 客户端代码（http://localhost:3000）
const ws = new WebSocket('ws://api.example.com:8080/socket');

ws.onopen = function() {
    console.log('WebSocket连接已建立');
    ws.send(JSON.stringify({ type: 'hello', data: 'world' }));
};

ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    console.log('收到消息:', data);
};

// 服务端代码（Node.js）
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function(ws, req) {
    // 验证来源
    const origin = req.headers.origin;
    const allowedOrigins = ['http://localhost:3000', 'https://example.com'];

    if (!allowedOrigins.includes(origin)) {
        ws.close();
        return;
    }

    ws.on('message', function(message) {
        console.log('收到消息:', message);
        // 广播给所有客户端
        wss.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
                client.send(message);
            }
        });
    });
});
```

**6. window.name + iframe**

📝 **面试背诵要点：**
- **原理**：window.name属性在不同页面（甚至不同域名）加载后依然存在，可以存储2MB左右的数据
- **实现步骤**：
  1. 在目标页面设置window.name
  2. 跳转到同域代理页面
  3. 读取window.name的值
- **优点**：
  - 兼容性好（IE6+）
  - 可传输大量数据（约2MB）
- **缺点**：
  - 实现复杂
  - 只能单向传输
  - 需要代理页面

```javascript
// 目标页面（http://api.example.com/data.html）
window.name = JSON.stringify({
    name: '张三',
    age: 25,
    data: '大量数据...'
});

// 主页面（http://localhost:3000/index.html）
function getData() {
    let iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    let state = 0;

    iframe.onload = function() {
        if (state === 0) {
            // 第一次加载跨域页面
            state = 1;
            // 切换到同域代理页面
            iframe.src = 'http://localhost:3000/proxy.html';
        } else if (state === 1) {
            // 第二次加载（同域页面）
            // 读取数据
            let data = iframe.contentWindow.name;
            console.log('获取到数据:', JSON.parse(data));
            // 清理
            iframe.contentWindow.document.write('');
            iframe.contentWindow.close();
            document.body.removeChild(iframe);
        }
    };

    iframe.src = 'http://api.example.com/data.html';
    document.body.appendChild(iframe);
}
```

**7. location.hash + iframe**

📝 **面试背诵要点：**
- **原理**：通过改变URL的hash部分来传递数据，hash改变不会刷新页面
- **实现方式**：
  1. A页面通过iframe嵌入B页面
  2. B页面通过修改A页面的hash传递数据
  3. A页面监听hashchange事件获取数据
- **优点**：
  - 实现简单
  - 兼容性较好
- **缺点**：
  - 数据容量有限（URL长度限制）
  - 数据暴露在URL中
  - 只能传递字符串

```javascript
// A页面（http://localhost:3000/a.html）
function startRequest() {
    let iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    iframe.src = 'http://api.example.com/b.html#getData';
    document.body.appendChild(iframe);

    // 监听hash变化
    window.addEventListener('hashchange', function() {
        console.log('收到数据:', location.hash.substring(1));
    });
}

// B页面（http://api.example.com/b.html）
window.onload = function() {
    let data = { name: '张三', age: 25 };
    // 由于B无法直接修改A的hash（跨域）
    // 需要借助中间页面C（与A同域）
    let iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    iframe.src = `http://localhost:3000/c.html#${JSON.stringify(data)}`;
    document.body.appendChild(iframe);
};

// C页面（http://localhost:3000/c.html）
window.onload = function() {
    // C和A同域，可以修改A的hash
    parent.parent.location.hash = location.hash.substring(1);
};
```

**8. document.domain**

📝 **面试背诵要点：**
- **作用**：通过设置相同的document.domain实现不同子域之间的跨域
- **限制条件**：
  - 只能用于二级域名相同的情况
  - 如：a.example.com 和 b.example.com
  - 不能跨协议（http和https不行）
- **原理**：将document.domain设置为相同的主域，浏览器就认为它们同源
- **使用步骤**：
  1. 两个页面都设置`document.domain = 'example.com'`
  2. 之后可以互相访问DOM和JavaScript对象
- **优点**：
  - 实现简单
  - 适合公司内部不同子域的项目
- **缺点**：
  - 只适用于子域名场景
  - 设置后端口号会重置为null
  - 安全性降低

```javascript
// 适用于子域名跨域
// 主页面：http://www.example.com
document.domain = 'example.com';

// 子页面：http://api.example.com
document.domain = 'example.com';
// 现在可以互相访问
```

### 3. 跨域解决方案总结对比

**所有跨域方案对比表：**

| 方案 | 原理 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|----------|
| **CORS** | 服务器设置响应头 | 标准方案、支持所有HTTP方法、安全可控 | 需要服务端配置、IE10+ | 现代Web应用首选 |
| **JSONP** | script标签不受限制 | 兼容性好、简单 | 只支持GET、有安全风险 | 公开API、老浏览器 |
| **代理服务器** | 服务器间无跨域 | 前端无需改动、灵活 | 需要额外服务器、有延迟 | 开发环境、生产环境 |
| **postMessage** | HTML5 API | 安全、双向通信 | 只能窗口间通信 | iframe、弹窗通信 |
| **WebSocket** | 独立协议 | 实时双向、不受限制 | 需要特殊协议支持 | 实时通信应用 |
| **window.name** | 属性持久化 | 可传大数据(2MB)、兼容好 | 实现复杂、单向 | 需要大数据传输 |
| **location.hash** | URL hash传递 | 简单、兼容性好 | 数据量小、暴露URL | 简单数据传递 |
| **document.domain** | 设置相同域 | 简单直接 | 仅限子域、安全性降低 | 子域名之间通信 |

**选择建议：**
1. **新项目首选**：CORS（标准、安全、功能完整）
2. **需要兼容老浏览器**：JSONP（IE6+都支持）
3. **开发环境**：webpack-dev-server代理
4. **生产环境**：Nginx反向代理 或 CORS
5. **实时通信**：WebSocket
6. **iframe通信**：postMessage
7. **子域名通信**：document.domain

### 4. CORS的预检请求是什么？

📝 **面试背诵要点：**

**定义与作用：**
- 预检请求（Preflight Request）是浏览器在发送非简单跨域请求前，自动发送的OPTIONS请求
- 目的是询问服务器是否允许该跨域请求，避免发送实际请求后被拒绝

**简单请求 vs 非简单请求：**

**简单请求（不触发预检）需同时满足：**
1. 方法只能是：GET、HEAD、POST
2. 请求头只能包含：
   - Accept
   - Accept-Language
   - Content-Language
   - Content-Type（仅限下面三种）
3. Content-Type只能是：
   - application/x-www-form-urlencoded
   - multipart/form-data
   - text/plain

**非简单请求（触发预检）的情况：**
1. 使用了PUT、DELETE、PATCH等方法
2. Content-Type为application/json
3. 设置了自定义请求头（如Authorization）

**预检请求的特点：**
- 使用OPTIONS方法
- 包含`Access-Control-Request-Method`头（实际请求方法）
- 包含`Access-Control-Request-Headers`头（实际请求头）
- 不包含请求体

**优化预检请求：**
- 设置`Access-Control-Max-Age`缓存预检结果
- 尽可能使用简单请求避免预检
- 合理设计API减少预检次数

**预检请求流程：**
```javascript
// 1. 浏览器发送预检请求
OPTIONS /api/data HTTP/1.1
Origin: http://localhost:3000
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Content-Type,Authorization

// 2. 服务器响应
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: GET,POST,PUT,DELETE
Access-Control-Allow-Headers: Content-Type,Authorization
Access-Control-Max-Age: 86400  // 缓存24小时

// 3. 浏览器发送实际请求
PUT /api/data HTTP/1.1
Origin: http://localhost:3000
Content-Type: application/json
Authorization: Bearer token
```

### 4. 跨域携带Cookie的问题？

📝 **面试背诵要点：**

**默认行为：**
- 跨域请求默认不携带Cookie和HTTP认证信息
- 这是出于安全考虑，防止CSRF攻击

**携带Cookie的条件（必须同时满足）：**

**1. 客户端配置：**
- fetch：设置`credentials: 'include'`
- XMLHttpRequest：设置`withCredentials = true`
- axios：设置`withCredentials: true`

**2. 服务端配置：**
- 必须设置`Access-Control-Allow-Credentials: true`
- `Access-Control-Allow-Origin`不能是通配符`*`，必须是具体域名
- 响应头必须包含`Set-Cookie`时的`SameSite`属性考虑

**重要限制：**
1. Origin不能使用`*`：当`Allow-Credentials`为true时，`Allow-Origin`必须是明确的域名
2. 安全性考虑：只允许信任的域名携带Cookie
3. Cookie的SameSite属性：
   - `SameSite=Strict`：完全禁止跨域携带
   - `SameSite=Lax`：部分允许（导航请求）
   - `SameSite=None`：允许跨域（需要Secure）

**常见错误：**
- 错误：同时设置`Allow-Origin: *`和`Allow-Credentials: true`
- 错误：忘记在客户端设置credentials
- 错误：Cookie设置了`SameSite=Strict`

```javascript
// 客户端配置
// fetch请求
fetch('http://api.example.com/data', {
  credentials: 'include' // 携带cookie
});

// XMLHttpRequest
const xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open('GET', 'http://api.example.com/data');
xhr.send();

// 服务端配置
// 不能使用通配符 *
res.header('Access-Control-Allow-Origin', 'http://localhost:3000');
res.header('Access-Control-Allow-Credentials', 'true');

// 动态设置允许的域名
const allowedOrigins = ['http://localhost:3000', 'http://localhost:8080'];
const origin = req.headers.origin;
if (allowedOrigins.includes(origin)) {
  res.header('Access-Control-Allow-Origin', origin);
}
res.header('Access-Control-Allow-Credentials', 'true');
```

### 5. 跨域问题的经典面试场景？

**答案：**

**场景1：开发环境跨域问题**
```javascript
// 问题：本地开发时前端localhost:3000访问后端localhost:8080
// 解决方案：开发服务器代理

// package.json
{
  "scripts": {
    "dev": "webpack serve --config webpack.dev.js"
  }
}

// webpack.dev.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};
```

**场景2：生产环境跨域问题**
```javascript
// 问题：前端域名和后端域名不同
// 解决方案：CORS配置

// 后端CORS中间件
const cors = require('cors');
app.use(cors({
  origin: ['https://www.example.com', 'https://admin.example.com'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
```

**场景3：第三方API跨域问题**
```javascript
// 问题：调用第三方API遇到跨域限制
// 解决方案：后端代理

// 后端代理接口
app.get('/api/weather', async (req, res) => {
  try {
    const response = await fetch('https://api.weather.com/data', {
      headers: {
        'Authorization': `Bearer ${process.env.WEATHER_API_KEY}`
      }
    });
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch weather data' });
  }
});
```

**场景4：WebSocket跨域问题**
```javascript
// 问题：WebSocket连接跨域
// 解决方案：服务端设置CORS

const WebSocket = require('ws');
const wss = new WebSocket.Server({
  port: 8080,
  verifyClient: (info) => {
    const origin = info.origin;
    const allowedOrigins = ['http://localhost:3000', 'https://example.com'];
    return allowedOrigins.includes(origin);
  }
});
```

## 三、面试重点总结

### HTTP缓存重点
1. **强缓存机制**：
   - Expires vs Cache-Control的区别
   - max-age、no-cache、no-store的使用场景
   - 缓存更新策略（hash、版本号）

2. **协商缓存机制**：
   - Last-Modified vs ETag的区别和适用场景
   - 304状态码的触发条件
   - 分布式系统中的缓存策略

3. **缓存策略选择**：
   - 静态资源：强缓存 + hash指纹
   - HTML文件：协商缓存或不缓存
   - API接口：根据业务需求选择

### 跨域问题重点
1. **安全理解**：同源策略的作用和必要性
2. **解决方案**：CORS、JSONP、代理等方案的优缺点
3. **实践应用**：开发和生产环境的不同处理方式
4. **深入理解**：预检请求、Cookie处理等细节

### 常见面试问题

**缓存相关：**
1. 强缓存和协商缓存的区别是什么？
2. Cache-Control的no-cache和no-store有什么区别？
3. 为什么需要协商缓存？强缓存不够吗？
4. ETag和Last-Modified可以同时使用吗？优先级如何？
5. 如何解决缓存更新问题？
6. 分布式系统中如何保证缓存一致性？
7. from memory cache和from disk cache的区别？

**跨域相关：**
1. 为什么会有跨域限制？同源策略的作用？
2. CORS和JSONP的区别和适用场景？
3. 简单请求和非简单请求的区别？
4. CORS预检请求什么时候触发？如何避免？
5. 跨域请求如何携带Cookie？
6. 开发环境和生产环境的跨域处理有什么不同？
7. 如何处理跨域的图片、字体等静态资源？

这些知识点都是前端面试中的高频考点，掌握这些内容能够帮助您在面试中更好地回答相关问题！
