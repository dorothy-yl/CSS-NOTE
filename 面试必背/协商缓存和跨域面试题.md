# HTTP缓存和跨域经典面试题 ⭐⭐⭐⭐⭐

> 💡 **重要程度**: 高频必考
> 📌 **记忆口诀**: **强制协商、时间标识、CORS首选**
> 📚 **详细内容**: 参考 [HTTP经典面试题汇总](/面试必背/HTTP经典面试题汇总.md)

---

## 📋 快速导航

| 章节 | 重要级别 | 核心内容 |
|------|---------|---------|
| [一、强缓存](#一强缓存) | ⭐⭐⭐⭐⭐ | Expires vs Cache-Control |
| [二、协商缓存](#二协商缓存) | ⭐⭐⭐⭐⭐ | Last-Modified vs ETag |
| [三、跨域问题](#三跨域问题) | ⭐⭐⭐⭐⭐ | CORS、JSONP、代理 |
| [四、核心速记](#四核心速记) | ⭐⭐⭐⭐⭐ | 面试答题模板 |

---

## 📚 重要说明

本文档是 **[HTTP经典面试题汇总](/面试必背/HTTP经典面试题汇总.md)** 的补充和精简版，主要聚焦于：
- HTTP缓存机制（强缓存 + 协商缓存）
- 跨域解决方案

**如需更详细的内容，请查阅：**
- [HTTP经典面试题汇总](/面试必背/HTTP经典面试题汇总.md) - 包含完整的缓存策略、跨域方案、状态码等
- 本文档内容与HTTP汇总文档的**第二章**和**第七章**重叠，建议优先学习HTTP汇总文档

---

## 🎯 记忆口诀

### 缓存机制口诀
```
强制协商、时间标识、CORS首选
```

**解释：**
- **强制协商**：强缓存优先，协商缓存兜底
- **时间标识**：Last-Modified基于时间，ETag基于内容
- **CORS首选**：现代跨域首选CORS方案

### 详细记忆法
```
缓存两种强协商（强缓存、协商缓存）
强看Cache-Control（Expires已过时）
协商看ETag好（比Last-Modified精确）
跨域CORS最标准（JSONP仅兼容）
```

---

## 一、强缓存

> **详细内容请参考**: [HTTP经典面试题汇总 - 第二章](/面试必备/HTTP经典面试题汇总.md#二http缓存机制)

### 📝 1. 什么是强缓存？ ⭐⭐⭐⭐⭐ 🔥 ⚠️

**定义：**
浏览器直接从本地缓存获取资源，**不发送请求到服务器**。

**核心特点：**
- ✅ 不发送HTTP请求
- ✅ 直接从缓存读取
- ✅ 速度最快
- ✅ 状态码：200 (from disk cache) 或 200 (from memory cache)

**记忆口诀：**
```
强缓存不发请求、直接读取本地、200 from cache
```

---

### 📝 2. 强缓存的实现方式有哪些？ ⭐⭐⭐⭐⭐ 🔥

**两种实现方式对比：**

| 方式 | 版本 | 特点 | 优先级 | 推荐度 |
|------|------|------|--------|--------|
| **Expires** | HTTP/1.0 | 绝对时间，依赖客户端时间 | 低 | ❌ 不推荐 |
| **Cache-Control** | HTTP/1.1 | 相对时间，不依赖客户端时间 | 高 | ✅ 推荐 |

#### Expires（已过时）
```http
Expires: Wed, 21 Oct 2025 07:28:00 GMT
```
- 绝对时间
- 依赖客户端时间，客户端时间不准确会导致缓存失效
- HTTP/1.0 产物，已被 Cache-Control 取代

#### Cache-Control（推荐）⭐⭐⭐⭐⭐ 🔥
```http
Cache-Control: max-age=31536000         # 缓存一年（秒）
Cache-Control: no-cache                 # 强制协商缓存
Cache-Control: no-store                 # 完全不缓存
Cache-Control: public, max-age=3600     # 公共缓存1小时
Cache-Control: private, max-age=300     # 私有缓存5分钟
```

**常用指令说明：**
| 指令 | 说明 | 应用场景 |
|------|------|----------|
| **max-age=秒** | 缓存的最长时间（相对时间） | 大部分静态资源 |
| **no-cache** | 可以缓存，但每次必须验证（走协商缓存） | HTML文件 |
| **no-store** | 完全不缓存，每次都请求 | 敏感信息 |
| **public** | 可以被任何缓存存储（CDN、代理） | 公共资源 |
| **private** | 只能被浏览器缓存 | 用户私有数据 |

**记忆口诀：**
```
Expires绝对时间已过时
Cache-Control相对时间更好用
max-age设时长、no-cache强协商、no-store不缓存
```

---

### 📝 3. 不同资源的缓存策略是什么？ ⭐⭐⭐⭐⭐ 🔥

**最佳实践（按资源类型）：**

| 资源类型 | Cache-Control策略 | 说明 |
|---------|-------------------|------|
| **HTML文件** | `no-cache` 或 `max-age=0` | 确保获取最新版本 |
| **CSS/JS（带hash）** | `max-age=31536000` (1年) | 文件名变化即更新 |
| **CSS/JS（无hash）** | `no-cache` | 每次验证 |
| **图片资源** | `max-age=604800` (7天) | 相对稳定 |
| **字体文件** | `max-age=31536000` (1年) | 很少变化 |
| **API数据** | `no-cache` 或短时缓存 | 根据业务需求 |
| **敏感信息** | `no-store` | 完全不缓存 |

**实际示例：**
```javascript
// webpack配置文件名hash
output: {
  filename: '[name].[contenthash].js'
}

// HTML引用
<script src="main.abc123.js"></script>

// 服务端设置
res.setHeader('Cache-Control', 'max-age=31536000');
```

**记忆口诀：**
```
HTML不缓存、带hash长缓存、图片短缓存、敏感不存储
```

---

## 二、协商缓存

> **详细内容请参考**: [HTTP经典面试题汇总 - 第二章](/面试必背/HTTP经典面试题汇总.md#二http缓存机制)

### 📝 4. 什么是协商缓存？ ⭐⭐⭐⭐⭐ 🔥 ⚠️

**定义：**
缓存过期后，浏览器携带标识向服务器**询问资源是否更新**。

**核心特点：**
- ✅ 需要发送HTTP请求
- ✅ 服务器验证资源是否变化
- ✅ 未变化返回304，使用缓存
- ✅ 已变化返回200 + 新资源

**记忆口诀：**
```
协商缓存发请求、携带标识问服务器、304用缓存、200返新资源
```

---

### 📝 5. 协商缓存的实现方式有哪些？ ⭐⭐⭐⭐⭐ 🔥

**两种实现方式对比：**

| 方式 | 请求头 | 响应头 | 优先级 | 精度 |
|------|--------|--------|--------|------|
| **Last-Modified** | If-Modified-Since | Last-Modified | 低 | 秒级 |
| **ETag** | If-None-Match | ETag | 高 | 精确到字节 |

**记忆口诀：**
```
Last-Modified时间标识、ETag内容标识
同时存在ETag优先
```

---

### 📝 6. 协商缓存的工作流程是什么？ ⭐⭐⭐⭐⭐ 🔥 ⚠️

**完整流程：**
```
1. 首次请求
   ↓
2. 服务器返回资源 + Last-Modified/ETag
   ↓
3. 浏览器缓存资源和标识
   ↓
4. 再次请求（缓存过期）
   ↓
5. 携带 If-Modified-Since/If-None-Match
   ↓
6. 服务器对比标识
   ├─ 未变化 → 返回 304 Not Modified（使用缓存）
   └─ 已变化 → 返回 200 + 新资源（更新缓存）
```

**具体示例：**

#### 首次请求：
```http
GET /style.css HTTP/1.1

响应：
HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT
ETag: "33a64df551425fcc55e4d42a148795d9"
Cache-Control: max-age=3600

[CSS内容]
```

#### 再次请求（缓存过期）：
```http
GET /style.css HTTP/1.1
If-Modified-Since: Wed, 21 Oct 2025 07:28:00 GMT
If-None-Match: "33a64df551425fcc55e4d42a148795d9"

响应（未修改）：
HTTP/1.1 304 Not Modified
（没有响应体，使用缓存）

响应（已修改）：
HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2025 08:30:00 GMT
ETag: "新的hash值"

[新的CSS内容]
```

**记忆口诀：**
```
首次返回资源加标识、再次携带标识问服务器
未变304用缓存、已变200返新资源
```

---

### 📝 7. ETag和Last-Modified的区别？ ⭐⭐⭐⭐⭐ 🔥 ⚠️

**六大维度对比：**

| 特性 | Last-Modified | ETag |
|------|---------------|------|
| **精度** | 秒级，1秒内多次修改无法识别 | 任意精度，内容变化即可识别 |
| **性能** | 读取文件修改时间，性能好 | 需计算hash，性能较差 |
| **分布式** | 不同服务器时间可能不同步 | 内容相同hash就相同，分布式友好 |
| **优先级** | 低 | 高（同时存在时ETag优先） |
| **基于** | 文件修改时间 | 文件内容hash |
| **适用场景** | 一般资源 | 需要精确验证的资源 |

**为什么ETag更好？⭐⭐⭐⭐⭐ 🔥**

1. **精度更高**：可以识别秒内的多次修改
   ```
   10:00:00.100 修改文件
   10:00:00.500 再次修改
   Last-Modified无法识别（都是10:00:00）
   ETag可以识别（内容hash不同）
   ```

2. **内容驱动**：只关心内容是否变化，不关心时间
   ```
   修改后又改回原内容
   Last-Modified：时间变了，返回200
   ETag：内容没变，返回304
   ```

3. **分布式友好**：不依赖服务器时间同步
   ```
   服务器A时间：10:00
   服务器B时间：10:05
   Last-Modified：可能不一致
   ETag：内容相同hash就相同
   ```

4. **更灵活**：可以自定义hash算法
   ```javascript
   // 可以基于内容、版本号等计算
   const etag = crypto.createHash('md5')
     .update(content)
     .digest('hex');
   ```

**记忆口诀：**
```
ETag精确到字节、内容驱动更可靠
Last-Modified秒级精度、时间驱动可能误判
ETag性能差些、但准确性高、优先级高
```

---

## 三、跨域问题

> **详细内容请参考**: [HTTP经典面试题汇总 - 第七章](/面试必背/HTTP经典面试题汇总.md#七跨域cors)

### 📝 8. 什么是同源策略？⭐⭐⭐⭐⭐ 🔥 ⚠️

**定义：**
浏览器的安全策略，限制一个源（origin）的文档或脚本如何与另一个源的资源进行交互。

**同源的三个条件（必须全部相同）：**
1. **协议**相同（http/https）
2. **域名**相同
3. **端口**相同

**跨域场景示例：**
```javascript
// 假设当前页面：http://localhost:3000

// ✅ 同源
http://localhost:3000/api/users

// ❌ 跨域：协议不同
https://localhost:3000

// ❌ 跨域：端口不同
http://localhost:8080

// ❌ 跨域：域名不同
http://api.example.com

// ❌ 跨域：子域名不同
http://sub.localhost:3000
```

**记忆口诀：**
```
协议域名端口、三者全同才同源
有一不同就跨域
```

---

### 📝 9. 跨域的解决方案有哪些？⭐⭐⭐⭐⭐ 🔥

**五大主流解决方案对比：**

| 方案 | 优点 | 缺点 | 适用场景 | 推荐度 |
|------|------|------|----------|--------|
| **CORS** | 标准、安全、支持所有HTTP方法 | 需服务端配置 | 现代Web应用 | ⭐⭐⭐⭐⭐ |
| **JSONP** | 兼容老浏览器（IE6+） | 仅GET、安全性差 | 老浏览器兼容 | ⭐⭐ |
| **代理服务器** | 前端无需修改 | 需额外服务器 | 开发/生产环境 | ⭐⭐⭐⭐ |
| **postMessage** | 安全、双向通信 | 仅窗口间通信 | iframe通信 | ⭐⭐⭐ |
| **WebSocket** | 实时、双向、无跨域限制 | 需特殊协议支持 | 实时应用 | ⭐⭐⭐⭐ |

**记忆口诀：**
```
CORS首选最标准、JSONP兼容已过时
代理服务器万能、postMessage窗口通信、WebSocket实时双向
```

---

### 📝 10. CORS如何配置？⭐⭐⭐⭐⭐ 🔥 ⚠️

**四大核心响应头：**

| 响应头 | 说明 | 示例 |
|--------|------|------|
| **Access-Control-Allow-Origin** | 允许的源（必需） | `http://localhost:3000` 或 `*` |
| **Access-Control-Allow-Methods** | 允许的HTTP方法 | `GET,POST,PUT,DELETE` |
| **Access-Control-Allow-Headers** | 允许的请求头 | `Content-Type,Authorization` |
| **Access-Control-Allow-Credentials** | 是否允许携带cookie | `true` |

**完整配置示例：**

#### 服务端配置（Node.js/Express）
```javascript
// 基础配置
app.use((req, res, next) => {
  // 允许的源（不能是*如果要携带cookie）
  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');

  // 允许的HTTP方法
  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');

  // 允许的请求头
  res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization');

  // 允许携带cookie
  res.header('Access-Control-Allow-Credentials', 'true');

  // 预检请求缓存时间（秒）
  res.header('Access-Control-Max-Age', '86400'); // 24小时

  // 处理预检请求
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }

  next();
});
```

#### 客户端配置
```javascript
// Fetch API
fetch('http://api.example.com/data', {
  method: 'POST',
  credentials: 'include', // 携带cookie（重要！）
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  },
  body: JSON.stringify({ name: 'test' })
});

// Axios
axios.defaults.withCredentials = true; // 全局配置

axios.post('http://api.example.com/data',
  { name: 'test' },
  {
    withCredentials: true, // 或单独配置
    headers: {
      'Authorization': 'Bearer token'
    }
  }
);
```

**记忆口诀：**
```
服务端四大响应头：Origin、Methods、Headers、Credentials
客户端关键配置：credentials: 'include'
携带cookie时Origin不能为*
```

---

### 📝 11. 什么是预检请求？⭐⭐⭐⭐⭐ 🔥 ⚠️

**定义：**
浏览器在发送某些跨域请求前，会先发送一个 **OPTIONS 请求**到服务器，检查服务器是否允许该实际请求。

**触发条件（非简单请求）：**

| 触发因素 | 说明 | 示例 |
|---------|------|------|
| **HTTP方法** | 使用了PUT、DELETE、PATCH等 | `method: 'PUT'` |
| **Content-Type** | 为application/json | `Content-Type: application/json` |
| **自定义请求头** | 设置了自定义头部 | `X-Custom-Header: value` |

**简单请求 vs 非简单请求：**

| 类型 | HTTP方法 | Content-Type | 自定义头 | 是否预检 |
|------|----------|--------------|----------|----------|
| **简单请求** | GET/POST/HEAD | text/plain<br>multipart/form-data<br>application/x-www-form-urlencoded | 无 | ❌ 不触发 |
| **非简单请求** | PUT/DELETE/PATCH等 | application/json | 有 | ✅ 触发 |

**预检请求示例：**
```http
OPTIONS /api/data HTTP/1.1
Host: api.example.com
Origin: http://localhost:3000
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Content-Type,Authorization

响应：
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: GET,POST,PUT,DELETE
Access-Control-Allow-Headers: Content-Type,Authorization
Access-Control-Max-Age: 86400

（然后才发送真正的PUT请求）
```

**优化建议：⭐⭐⭐⭐**

1. **设置缓存时间**：
   ```javascript
   res.header('Access-Control-Max-Age', '86400'); // 缓存24小时
   ```

2. **使用简单请求**：
   ```javascript
   // 避免：application/json触发预检
   fetch('/api/data', {
     method: 'POST',
     headers: { 'Content-Type': 'application/json' },
     body: JSON.stringify(data)
   });

   // 优化：使用简单请求
   fetch('/api/data', {
     method: 'POST',
     headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
     body: new URLSearchParams(data)
   });
   ```

3. **服务端正确处理OPTIONS**：
   ```javascript
   if (req.method === 'OPTIONS') {
     res.sendStatus(200);
     return;
   }
   ```

**记忆口诀：**
```
非简单请求先预检、OPTIONS问服务器允不允
PUT DELETE PATCH要预检、application/json要预检、自定义头要预检
优化：缓存预检结果、尽量用简单请求
```

---

## 四、核心速记

### 缓存决策流程

```
用户请求
    ↓
是否有缓存?
    ├─ 无 → 发送请求 → 缓存资源
    └─ 有 → 强缓存是否有效?
              ├─ 是 → 返回缓存（200 from cache）
              └─ 否 → 协商缓存
                      ├─ 304 → 使用缓存
                      └─ 200 → 返回新资源
```

### 面试答题模板

**Q1: 强缓存和协商缓存的区别？**

答：
1. **是否发送请求**：强缓存不发送请求，协商缓存发送请求验证
2. **状态码**：强缓存200（from cache），协商缓存304
3. **实现方式**：强缓存用Cache-Control，协商缓存用ETag/Last-Modified
4. **优先级**：强缓存优先级更高

**Q2: 如何解决缓存更新问题？**

答：
1. **文件名加hash**：webpack的`contenthash`
2. **版本号查询参数**：`style.css?v=1.0.1`
3. **HTML不缓存**：确保能获取最新的资源引用

**Q3: 跨域请求如何携带Cookie？**

答：
1. 服务端设置`Access-Control-Allow-Credentials: true`
2. `Access-Control-Allow-Origin`不能是`*`，必须是具体域名
3. 客户端设置`credentials: 'include'`
4. Cookie的`SameSite`属性设置为`None`（需配合`Secure`）

**Q4: 为什么ETag比Last-Modified好？**

答：
1. **精度更高**：可识别秒内多次修改
2. **内容驱动**：只关心内容是否变化
3. **分布式友好**：不依赖服务器时间同步
4. **更灵活**：可自定义hash算法

**Q5: CORS和JSONP的区别？**

答：
1. **请求方法**：CORS支持所有HTTP方法，JSONP仅支持GET
2. **安全性**：CORS更安全，JSONP易受XSS攻击
3. **兼容性**：CORS需IE10+，JSONP支持所有浏览器
4. **推荐度**：现代项目首选CORS，只在老浏览器兼容时用JSONP

---

## 五、核心速记（10分钟快速复习）

### 1. 强缓存
```
定义：直接从本地缓存获取，不发送请求
实现：Cache-Control（推荐）、Expires（过时）
指令：max-age（缓存时长）、no-cache（强制协商）、no-store（不缓存）
状态码：200 (from cache)
```

### 2. 协商缓存
```
定义：缓存过期后，向服务器询问是否更新
实现：ETag（推荐）、Last-Modified
流程：首次请求 → 返回标识 → 再次请求携带标识 → 304或200
状态码：304 Not Modified（未修改使用缓存）、200（返回新资源）
```

### 3. ETag vs Last-Modified
```
ETag：精确到字节、内容驱动、分布式友好、优先级高
Last-Modified：秒级精度、时间驱动、可能不同步、优先级低
推荐：优先使用ETag
```

### 4. 跨域解决方案
```
CORS（推荐）：标准、安全、支持所有方法
JSONP：仅GET、兼容老浏览器、安全性差
代理：前端无需改动、需额外服务器
postMessage：窗口间通信
WebSocket：实时双向通信
```

### 5. CORS核心配置
```
服务端：
- Access-Control-Allow-Origin（允许的源）
- Access-Control-Allow-Methods（允许的方法）
- Access-Control-Allow-Headers（允许的请求头）
- Access-Control-Allow-Credentials（允许携带cookie）

客户端：
- credentials: 'include'（携带cookie）
```

### 6. 预检请求
```
触发条件：非简单请求（PUT/DELETE/PATCH、application/json、自定义头）
优化：设置Access-Control-Max-Age缓存预检结果
避免：使用简单请求、标准Content-Type、不设置自定义头
```

---

## 六、TOP 15 高频面试题速答

### Q1: 什么是强缓存？⭐⭐⭐⭐⭐ 🔥
浏览器直接从本地缓存获取资源，不发送请求到服务器，使用Cache-Control或Expires控制。

### Q2: 什么是协商缓存？⭐⭐⭐⭐⭐ 🔥
缓存过期后，浏览器携带标识向服务器询问资源是否更新，使用ETag或Last-Modified。

### Q3: 强缓存和协商缓存的区别？⭐⭐⭐⭐⭐ 🔥 ⚠️
强缓存不发请求（200 from cache）；协商缓存发请求验证（304或200）。

### Q4: ETag和Last-Modified的区别？⭐⭐⭐⭐⭐ 🔥 ⚠️
ETag精确到字节、内容驱动；Last-Modified秒级精度、时间驱动。ETag优先级更高。

### Q5: Cache-Control的常用指令有哪些？⭐⭐⭐⭐⭐ 🔥
max-age（缓存时长）、no-cache（强制协商）、no-store（不缓存）、public/private

### Q6: 什么是同源策略？⭐⭐⭐⭐⭐ 🔥
协议、域名、端口必须完全相同，浏览器的安全策略，限制跨域访问。

### Q7: 如何解决跨域问题？⭐⭐⭐⭐⭐ 🔥
CORS（推荐）、JSONP、代理服务器、postMessage、WebSocket。

### Q8: CORS需要哪些响应头？⭐⭐⭐⭐⭐ 🔥
Access-Control-Allow-Origin、Methods、Headers、Credentials

### Q9: 什么是预检请求？⭐⭐⭐⭐⭐ 🔥 ⚠️
非简单请求前发送OPTIONS请求，检查服务器是否允许该实际请求。

### Q10: no-cache和no-store的区别？⭐⭐⭐⭐
no-cache可缓存但每次必须验证；no-store完全不缓存。

### Q11: from memory cache和from disk cache的区别？⭐⭐⭐⭐
memory cache在内存、速度快、关闭浏览器清空；disk cache在硬盘、持久化。

### Q12: 如何携带Cookie跨域请求？⭐⭐⭐⭐⭐ 🔥
服务端设置Credentials:true且Origin不能为*；客户端设置credentials:'include'。

### Q13: CORS和JSONP的区别？⭐⭐⭐⭐
CORS支持所有方法、更安全；JSONP仅GET、兼容老浏览器。

### Q14: 如何避免预检请求？⭐⭐⭐⭐
使用简单请求方法、标准Content-Type、不设置自定义头。

### Q15: 304状态码表示什么？⭐⭐⭐⭐⭐ 🔥
Not Modified，资源未修改，使用缓存。协商缓存验证后返回。

---

## 七、答题技巧与模板

### 模板1: 缓存机制对比
```
1. 定义：说明强缓存和协商缓存的区别
2. 是否发送请求：强缓存不发、协商缓存发
3. 状态码：200 from cache vs 304
4. 实现方式：Cache-Control vs ETag/Last-Modified
5. 优先级：强缓存优先
```

### 模板2: ETag vs Last-Modified
```
1. 精度：ETag精确到字节 vs 秒级
2. 性能：ETag需计算hash vs 读取时间
3. 分布式：ETag内容相同hash相同 vs 可能不同步
4. 优先级：ETag更高
5. 推荐：优先使用ETag
```

### 模板3: 跨域解决方案
```
1. 列举方案：CORS、JSONP、代理、postMessage、WebSocket
2. 对比优劣：用表格对比
3. 推荐方案：现代项目首选CORS
4. 配置示例：展示服务端和客户端配置
```

### 模板4: CORS配置
```
1. 服务端配置：4个核心响应头
2. 客户端配置：credentials设置
3. 预检请求：触发条件和优化
4. 注意事项：携带cookie时Origin不能为*
```

---

## 八、学习建议

### 必须掌握（⭐⭐⭐⭐⭐）
1. 强缓存和协商缓存的区别
2. Cache-Control常用指令
3. ETag vs Last-Modified
4. 同源策略和跨域概念
5. CORS配置方法

### 重要理解（⭐⭐⭐⭐）
6. 缓存决策流程
7. 预检请求触发条件
8. 跨域携带Cookie的配置
9. 简单请求和非简单请求
10. CORS vs JSONP对比

### 加分项（⭐⭐⭐）
11. 缓存更新策略
12. 预检请求优化
13. 其他跨域方案（代理、postMessage）
14. 实际项目缓存配置

---

## 九、常见面试问题详解

### Q: from memory cache 和 from disk cache 的区别？⭐⭐⭐⭐
**答：**
- **memory cache（内存缓存）**：
  - 存储在内存中，速度快
  - 容量小
  - 关闭浏览器就清空
  - 优先级高

- **disk cache（硬盘缓存）**：
  - 存储在硬盘中，速度相对慢
  - 容量大
  - 持久保存
  - 优先级低

### Q: Cache-Control的no-cache和no-store有什么区别？⭐⭐⭐⭐
**答：**
- **no-cache**：
  - 可以缓存资源
  - 但每次必须向服务器验证（强制走协商缓存）
  - 适用于需要验证新鲜度的资源

- **no-store**：
  - 完全不缓存，不存储任何内容
  - 每次都重新请求
  - 适用于敏感信息

### Q: 如何清除浏览器缓存？⭐⭐⭐⭐
**答：**
1. **修改资源URL**：加时间戳或版本号（`style.css?v=1.0.1`）
2. **设置响应头**：`Cache-Control: no-cache` 或 `no-store`
3. **用户手动清除**：浏览器设置中清除缓存
4. **文件名加hash**：webpack的contenthash

### Q: 简单请求和非简单请求的区别？⭐⭐⭐⭐⭐ 🔥
**答：**

**简单请求**：
- 方法：GET、POST、HEAD
- 请求头：简单请求头（Accept、Accept-Language、Content-Language）
- Content-Type：text/plain、multipart/form-data、application/x-www-form-urlencoded
- 不会触发预检请求

**非简单请求**：
- 其他HTTP方法（PUT、DELETE、PATCH等）
- 使用了自定义请求头
- Content-Type为application/json
- 会触发预检请求（OPTIONS）

### Q: 如何避免预检请求？⭐⭐⭐⭐
**答：**
1. 使用简单请求方法（GET/POST）
2. Content-Type使用`application/x-www-form-urlencoded`
3. 不设置自定义请求头
4. 设置`Access-Control-Max-Age`缓存预检结果

### Q: 跨域时为什么不能设置Origin为*且允许携带Cookie？⭐⭐⭐⭐⭐ 🔥
**答：**
- **安全考虑**：防止CSRF（跨站请求伪造）攻击
- **必须明确指定**：`Access-Control-Allow-Origin`必须是具体域名
- **可信来源**：确保请求来自可信的源
- **Cookie安全**：避免cookie被恶意网站获取

---

## 📖 相关资料

- [HTTP经典面试题汇总 - 完整版](/面试必背/HTTP经典面试题汇总.md)
- [AJAX经典面试题](/面试必背/AJAX经典面试题.md)
- [MDN - HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)
- [MDN - CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)
- [RFC 7234 - HTTP缓存](https://tools.ietf.org/html/rfc7234)
- [RFC 6454 - 同源策略](https://tools.ietf.org/html/rfc6454)

---

**最后更新**: 2025-09-30
**难度等级**: ⭐⭐⭐⭐⭐（必背）
**面试频率**: 极高（几乎必考）