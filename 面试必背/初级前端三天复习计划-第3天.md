# 初级前端三天复习计划 - 第3天

> 📅 **学习时间**：第3天 | **目标**：HTML+CSS补充 + JS补充 + Diff算法和迭代器 + Vue补充 + 性能优化补充 | **建议时长**：8小时

---

## 📚 今日学习内容导航

| 序号 | 模块 | 核心知识点 | 重要程度 | 预计时长 | 文件链接 |
|------|------|-----------|---------|----------|----------|
| 1 | **HTML和CSS补充** | 本地存储、CSS3动画、移动端适配、预处理器 | ⭐⭐⭐⭐ | 1.5小时 | [HTML面试总结大全.md](../面试总结大全/HTML面试总结大全.md)<br>[CSS高频面试题汇总.md](./CSS高频面试题汇总.md) |
| 2 | **JavaScript补充** | 深拷贝浅拷贝、数组方法、手写代码 | ⭐⭐⭐⭐⭐ | 2小时 | [JS高频面试题汇总.md](./JS高频面试题汇总.md) |
| 3 | **Diff算法和迭代器专项** | 虚拟DOM、Vue Diff算法、Iterator迭代器 | ⭐⭐⭐⭐⭐ | 2小时 | [diff算法和虚拟DOM面试题汇总.md](./diff算法和虚拟DOM面试题汇总.md)<br>[Iterator迭代器面试题-精简版.md](./Iterator迭代器面试题-精简版.md) |
| 4 | **Vue补充** | keep-alive、v-model原理、Vue指令 | ⭐⭐⭐⭐⭐ | 1.5小时 | [Vue面试总结大全.md](../面试总结大全/Vue面试总结大全.md)<br>[Vue完整面试题汇总.md](./Vue完整面试题汇总.md) |
| 5 | **性能优化补充** | 长列表优化、Vite优化、性能指标监控 | ⭐⭐⭐⭐⭐ | 1小时 | [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md) |

---

## 📖 详细学习路径

### 第一模块：HTML和CSS补充（1.5小时）

#### ✅ HTML补充（0.5小时）→ [HTML面试总结大全.md](../面试总结大全/HTML面试总结大全.md)

1. **本地存储对比**

   **Cookie vs localStorage vs sessionStorage：**

   | 特性 | Cookie | localStorage | sessionStorage |
   |------|--------|--------------|----------------|
   | 存储大小 | 4KB | 5-10MB | 5-10MB |
   | 生命周期 | 可设置过期时间 | 永久保存，除非手动删除 | 标签页关闭时删除 |
   | 作用域 | 同源下所有页面 | 同源下所有页面 | 同源的同一标签页 |
   | 服务器通信 | 自动随HTTP请求发送 | 不会发送到服务器 | 不会发送到服务器 |
   | API | document.cookie | localStorage.setItem/getItem | sessionStorage.setItem/getItem |

   **使用场景：**
   - Cookie：身份认证、用户偏好
   - localStorage：长期缓存、用户配置
   - sessionStorage：表单数据、临时状态

2. **HTML5 API**
   - Geolocation API：获取用户地理位置
   - Drag and Drop API：拖放功能
   - Canvas API：绘制图形、图表、游戏
   - Web Workers：后台线程，处理耗时任务
   - Service Worker：离线缓存、消息推送
   - History API：pushState、replaceState操作历史记录

#### ✅ CSS补充（1小时）→ [CSS高频面试题汇总.md](./CSS高频面试题汇总.md)

1. **CSS3动画与过渡**

   **transition过渡：**
   ```css
   .box {
     transition: all 0.3s ease-in-out;
   }
   .box:hover {
     transform: scale(1.2);
   }
   ```

   **animation动画：**
   ```css
   @keyframes fadeIn {
     from { opacity: 0; }
     to { opacity: 1; }
   }
   .box {
     animation: fadeIn 1s ease-out;
   }
   ```

   **transform变换：**
   - translate：平移
   - rotate：旋转
   - scale：缩放
   - skew：倾斜

   **性能优化：**
   - 优先使用transform和opacity（触发GPU加速）
   - 避免触发重排的属性（width、height、margin等）

2. **移动端适配**

   **rem适配：**
   ```javascript
   function setRem() {
     const baseSize = 16;
     const scale = document.documentElement.clientWidth / 375;
     document.documentElement.style.fontSize = baseSize * scale + 'px';
   }
   window.addEventListener('resize', setRem);
   setRem();
   ```

   **vw/vh适配：**
   - 1vw = 视口宽度的1%
   - 1vh = 视口高度的1%

   **1px问题：**
   ```css
   .border {
     position: relative;
   }
   .border::after {
     content: '';
     position: absolute;
     left: 0;
     bottom: 0;
     width: 100%;
     height: 1px;
     background: #000;
     transform: scaleY(0.5);
   }
   ```

   **viewport设置：**
   ```html
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   ```

3. **CSS预处理器**
   - **Less/Sass变量：** `$primary-color: #007bff;`
   - **嵌套：** 简化选择器书写
   - **Mixin混入：** 复用样式片段
   - **函数：** lighten()、darken()、透明度调整

---

### 第二模块：JavaScript补充（2小时）→ [JS高频面试题汇总.md](./JS高频面试题汇总.md)

#### ✅ 必学知识点

1. **深拷贝与浅拷贝** → [JS高频面试题汇总.md](./JS高频面试题汇总.md#10-深拷贝与浅拷贝-)

   **浅拷贝：**
   ```javascript
   // 方法1：扩展运算符
   const copy1 = { ...obj };
   const copy2 = [...arr];

   // 方法2：Object.assign
   const copy3 = Object.assign({}, obj);

   // 方法3：数组方法
   const copy4 = arr.slice();
   const copy5 = arr.concat();
   ```

   **深拷贝：**
   ```javascript
   // 方法1：JSON（有局限性：无法拷贝函数、undefined、Symbol、循环引用）
   const deepCopy1 = JSON.parse(JSON.stringify(obj));

   // 方法2：递归实现（推荐）
   function deepClone(obj, map = new WeakMap()) {
     if (obj === null || typeof obj !== 'object') return obj;
     if (map.has(obj)) return map.get(obj); // 处理循环引用

     const clone = Array.isArray(obj) ? [] : {};
     map.set(obj, clone);

     for (let key in obj) {
       if (obj.hasOwnProperty(key)) {
         clone[key] = deepClone(obj[key], map);
       }
     }
     return clone;
   }

   // 方法3：structuredClone（新API，现代浏览器）
   const deepCopy2 = structuredClone(obj);
   ```

2. **数组常用方法**

   **遍历方法：**
   - forEach：遍历数组，无返回值
   - map：映射数组，返回新数组
   - filter：过滤数组，返回符合条件的新数组
   - reduce：累加器，返回单个值
   - some：是否有元素满足条件
   - every：是否所有元素满足条件
   - find：查找第一个满足条件的元素
   - findIndex：查找第一个满足条件的索引

   **修改原数组：**
   - push、pop：尾部添加/删除
   - shift、unshift：头部删除/添加
   - splice：任意位置增删改
   - sort、reverse：排序、反转

   **不修改原数组：**
   - concat：合并数组
   - slice：截取数组
   - join：数组转字符串
   - map、filter、reduce

   **实用技巧：**
   ```javascript
   // 数组去重
   const unique = [...new Set(arr)];
   const unique2 = arr.filter((item, index) => arr.indexOf(item) === index);

   // 数组扁平化
   const flat = arr.flat(Infinity);
   const flat2 = arr.toString().split(',').map(Number);

   // 数组求和
   const sum = arr.reduce((acc, cur) => acc + cur, 0);

   // 数组最大值
   const max = Math.max(...arr);
   ```

3. **手写经典代码**

   **手写防抖：**
   ```javascript
   function debounce(fn, delay) {
     let timer = null;
     return function(...args) {
       if (timer) clearTimeout(timer);
       timer = setTimeout(() => {
         fn.apply(this, args);
       }, delay);
     };
   }
   ```

   **手写节流：**
   ```javascript
   function throttle(fn, delay) {
     let last = 0;
     return function(...args) {
       const now = Date.now();
       if (now - last >= delay) {
         fn.apply(this, args);
         last = now;
       }
     };
   }
   ```

   **手写Promise.all：**
   ```javascript
   Promise.myAll = function(promises) {
     return new Promise((resolve, reject) => {
       const results = [];
       let count = 0;
       for (let i = 0; i < promises.length; i++) {
         Promise.resolve(promises[i]).then(res => {
           results[i] = res;
           count++;
           if (count === promises.length) resolve(results);
         }).catch(reject);
       }
     });
   };
   ```

   **手写call、apply、bind：**
   ```javascript
   // call
   Function.prototype.myCall = function(context, ...args) {
     context = context || window;
     const fn = Symbol();
     context[fn] = this;
     const result = context[fn](...args);
     delete context[fn];
     return result;
   };

   // apply
   Function.prototype.myApply = function(context, args) {
     context = context || window;
     const fn = Symbol();
     context[fn] = this;
     const result = context[fn](...args);
     delete context[fn];
     return result;
   };

   // bind
   Function.prototype.myBind = function(context, ...args) {
     const fn = this;
     return function(...newArgs) {
       return fn.apply(context, [...args, ...newArgs]);
     };
   };
   ```

---

### 第三模块：Diff算法和迭代器专项（2小时）

#### ✅ 必学知识点

1. **虚拟DOM** → [diff算法和虚拟DOM面试题汇总.md](./diff算法和虚拟DOM面试题汇总.md)

   **虚拟DOM的定义：**
   - 用JavaScript对象描述DOM结构
   - 轻量级的DOM抽象

   **虚拟DOM的优势：**
   - 减少真实DOM操作，提升性能
   - 跨平台能力（React Native、Weex）
   - 方便实现SSR

   **虚拟DOM结构：**
   ```javascript
   const vnode = {
     tag: 'div',
     props: { class: 'container' },
     children: [
       { tag: 'h1', props: {}, children: ['Title'] },
       { tag: 'p', props: {}, children: ['Content'] }
     ]
   };
   ```

2. **Vue Diff算法** → [diff算法和虚拟DOM面试题汇总.md](./diff算法和虚拟DOM面试题汇总.md)

   **Diff算法目的：**
   - 找出新旧虚拟DOM的差异
   - 最小化DOM操作

   **Vue2的双端比较：**
   1. 旧头 vs 新头
   2. 旧尾 vs 新尾
   3. 旧头 vs 新尾
   4. 旧尾 vs 新头
   5. 乱序比较（key的作用）

   **Vue3的最长递增子序列：**
   - 减少节点移动次数
   - 性能更优

   **key的作用：**
   - 唯一标识节点
   - 复用和重新排序现有元素
   - 不要用index作为key（列表会变化时）

   **为什么不建议用index作为key？**
   ```javascript
   // 初始列表：[A, B, C]
   // 删除B后：[A, C]

   // 使用index作为key
   // 删除前：A(0), B(1), C(2)
   // 删除后：A(0), C(1)  ← C的key从2变成1，无法复用

   // 使用唯一ID作为key
   // 删除前：A(id:1), B(id:2), C(id:3)
   // 删除后：A(id:1), C(id:3)  ← C的key不变，可以复用
   ```

3. **Iterator迭代器** → [Iterator迭代器面试题-精简版.md](./Iterator迭代器面试题-精简版.md)

   **Iterator接口：**
   ```javascript
   const iterator = {
     next() {
       return { value: any, done: boolean };
     }
   };
   ```

   **可迭代对象：**
   - Array、String、Map、Set、TypedArray
   - NodeList、arguments

   **for...of循环：**
   ```javascript
   const arr = [1, 2, 3];
   for (let item of arr) {
     console.log(item); // 1, 2, 3
   }
   ```

   **自定义迭代器：**
   ```javascript
   const obj = {
     data: [1, 2, 3],
     [Symbol.iterator]() {
       let index = 0;
       const data = this.data;
       return {
         next() {
           if (index < data.length) {
             return { value: data[index++], done: false };
           } else {
             return { done: true };
           }
         }
       };
     }
   };

   for (let item of obj) {
     console.log(item); // 1, 2, 3
   }
   ```

   **Generator函数：**
   ```javascript
   function* generator() {
     yield 1;
     yield 2;
     yield 3;
   }

   const gen = generator();
   console.log(gen.next()); // { value: 1, done: false }
   console.log(gen.next()); // { value: 2, done: false }
   console.log(gen.next()); // { value: 3, done: false }
   console.log(gen.next()); // { done: true }
   ```

---

### 第四模块：Vue补充（1.5小时）

#### ✅ 必学知识点

1. **keep-alive缓存机制** → [Vue面试总结大全.md](../面试总结大全/Vue面试总结大全.md)

   **作用：**
   - 缓存组件状态，避免重复渲染
   - 保留组件实例，不销毁

   **属性：**
   - include：缓存的组件名（字符串、数组、正则）
   - exclude：不缓存的组件名
   - max：最多缓存多少个组件

   **生命周期：**
   - activated：组件激活时调用
   - deactivated：组件失活时调用

   **使用场景：**
   - 列表页和详情页切换
   - 多标签页切换
   - 保持表单状态

   **示例：**
   ```vue
   <keep-alive :include="['Home', 'About']" :max="10">
     <router-view />
   </keep-alive>
   ```

2. **v-model原理** → [Vue面试总结大全.md](../面试总结大全/Vue面试总结大全.md#3-v-model原理)

   **核心原理：**
   - v-model是语法糖
   - 结合属性绑定和事件监听实现双向绑定

   **不同元素的v-model：**
   ```vue
   <!-- 文本输入框 -->
   <input v-model="text" />
   <!-- 等价于 -->
   <input :value="text" @input="text = $event.target.value" />

   <!-- 复选框 -->
   <input type="checkbox" v-model="checked" />
   <!-- 等价于 -->
   <input type="checkbox" :checked="checked" @change="checked = $event.target.checked" />

   <!-- 下拉选择框 -->
   <select v-model="selected">
     <option value="A">A</option>
   </select>
   <!-- 等价于 -->
   <select :value="selected" @change="selected = $event.target.value">
     <option value="A">A</option>
   </select>
   ```

   **自定义组件v-model（Vue3）：**
   ```vue
   <!-- 父组件 -->
   <MyInput v-model="value" />
   <!-- 等价于 -->
   <MyInput :modelValue="value" @update:modelValue="value = $event" />

   <!-- 子组件 -->
   <template>
     <input
       :value="modelValue"
       @input="$emit('update:modelValue', $event.target.value)"
     />
   </template>
   <script>
   export default {
     props: ['modelValue'],
     emits: ['update:modelValue']
   }
   </script>
   ```

3. **Vue指令** → [Vue完整面试题汇总.md](./Vue完整面试题汇总.md)

   **常用内置指令：**
   - v-if / v-else / v-else-if：条件渲染
   - v-show：显示/隐藏（display）
   - v-for：列表渲染
   - v-model：双向绑定
   - v-bind（:）：属性绑定
   - v-on（@）：事件监听
   - v-once：只渲染一次
   - v-html：渲染HTML
   - v-text：文本内容
   - v-cloak：防止闪烁

   **v-if vs v-show：**
   | 特性 | v-if | v-show |
   |------|------|--------|
   | 渲染方式 | 条件性渲染 | 始终渲染，切换display |
   | 性能 | 切换时开销大 | 初始渲染开销大 |
   | 使用场景 | 条件很少改变 | 频繁切换 |

4. **Vue Router深入** → [Vue完整面试题汇总.md](./Vue完整面试题汇总.md#16-路由传参)

   **路由传参：**
   ```javascript
   // params传参（动态路由）
   { path: '/user/:id', component: User }
   this.$router.push({ name: 'User', params: { id: 123 } });
   // 访问：this.$route.params.id

   // query传参（查询参数）
   this.$router.push({ path: '/user', query: { id: 123 } });
   // 访问：this.$route.query.id
   ```

   **路由懒加载：**
   ```javascript
   const Home = () => import('./views/Home.vue');
   const About = () => import(/* webpackChunkName: "about" */ './views/About.vue');
   ```

---

### 第五模块：性能优化补充（1小时）→ [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md)

#### ✅ 必学知识点

1. **长列表优化** → [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md#三javascript优化)

   **虚拟滚动（Virtual Scroll）：**
   - 原理：只渲染可视区域的列表项
   - 计算：可视区域高度 / 每项高度 = 可见数量
   - 滚动时动态计算startIndex和endIndex

   **时间分片（Time Slicing）：**
   ```javascript
   function timeSlice(list, fn, count = 100) {
     let index = 0;
     function chunk() {
       for (let i = 0; i < count && index < list.length; i++, index++) {
         fn(list[index]);
       }
       if (index < list.length) {
         requestAnimationFrame(chunk);
       }
     }
     chunk();
   }
   ```

   **分页加载和无限滚动：**
   - 分页：适用于数据量大、需要精确翻页
   - 无限滚动：适用于社交媒体流

2. **Vite构建优化** → [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md#七webpackvite优化)

   **Vite vs Webpack：**
   | 特性 | Vite | Webpack |
   |------|------|---------|
   | 开发环境 | ES Module，按需编译 | 全量打包 |
   | 启动速度 | 极快 | 较慢 |
   | 热更新 | 快速 | 相对较慢 |
   | 生产环境 | Rollup | Webpack |

   **Vite优化技巧：**
   - 依赖预构建：使用esbuild（Go语言）
   - 按需编译：只编译当前页面需要的模块
   - 缓存：依赖缓存、源码缓存

   **Vite配置优化：**
   ```javascript
   // vite.config.js
   export default {
     build: {
       rollupOptions: {
         output: {
           manualChunks: {
             vendor: ['vue', 'vue-router', 'pinia'],
             utils: ['lodash', 'dayjs']
           }
         }
       },
       chunkSizeWarningLimit: 1000
     }
   }
   ```

3. **性能指标监控** → [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md#一性能指标与衡量标准)

   **核心性能指标：**
   - FP（First Paint）：首次绘制
   - FCP（First Contentful Paint）：首次内容绘制
   - LCP（Largest Contentful Paint）：最大内容绘制
   - CLS（Cumulative Layout Shift）：累积布局偏移
   - FID（First Input Delay）：首次输入延迟
   - TTI（Time to Interactive）：可交互时间

   **性能监控：**
   ```javascript
   // Performance API
   const observer = new PerformanceObserver((list) => {
     for (const entry of list.getEntries()) {
       console.log('LCP:', entry.renderTime || entry.loadTime);
     }
   });
   observer.observe({ type: 'largest-contentful-paint', buffered: true });

   // Navigation Timing
   window.addEventListener('load', () => {
     const timing = performance.timing;
     const loadTime = timing.loadEventEnd - timing.navigationStart;
     console.log('页面加载时间:', loadTime);
   });
   ```

   **错误监控：**
   ```javascript
   // 全局错误监听
   window.addEventListener('error', (event) => {
     console.error('Error:', event.error);
   });

   // Promise错误监听
   window.addEventListener('unhandledrejection', (event) => {
     console.error('Unhandled Promise:', event.reason);
   });
   ```

   **常见监控平台：**
   - Sentry：错误监控、性能监控
   - Fundebug：前端错误监控
   - 神策分析：用户行为分析

---

## 📝 今日学习检验

### 必答问题清单（第3天）

#### HTML和CSS模块
1. ✅ localStorage、sessionStorage、Cookie的区别？
2. ✅ CSS3动画animation和transition的区别？
3. ✅ 移动端rem适配的原理是什么？
4. ✅ 如何解决移动端1px问题？

#### JavaScript模块
5. ✅ 深拷贝和浅拷贝的区别？手写深拷贝函数？
6. ✅ 数组的map、filter、reduce有什么区别？
7. ✅ 数组去重有哪些方法？
8. ✅ 手写防抖和节流函数？
9. ✅ 手写Promise.all？

#### Diff算法和迭代器模块
10. ✅ 什么是虚拟DOM？有什么优势？
11. ✅ Vue的Diff算法原理？key的作用？
12. ✅ 为什么不建议用index作为key？
13. ✅ 什么是Iterator迭代器？
14. ✅ for...of和for...in的区别？
15. ✅ Generator函数有什么用？

#### Vue模块
16. ✅ keep-alive的作用和使用场景？
17. ✅ v-model的实现原理是什么？
18. ✅ v-if和v-show的区别？什么时候用哪个？
19. ✅ Vue Router的params和query传参有什么区别？

#### 性能优化模块
20. ✅ 什么是虚拟滚动？原理是什么？
21. ✅ Vite为什么比Webpack快？
22. ✅ 前端核心性能指标有哪些？
23. ✅ 如何监控前端性能？

---

## 🎯 三天学习总结

### 📊 知识点全覆盖

恭喜你完成了三天的系统复习！现在你已经掌握了：

**第1天：基础篇**
- ✅ HTML和CSS基础（语义化、盒模型、Flex、定位）
- ✅ JavaScript基础（数据类型、作用域、this、闭包、原型链）
- ✅ 事件机制专项（事件流、事件委托、addEventListener）
- ✅ Vue基础（响应式、ref/reactive、computed/watch、组件通信）
- ✅ 性能优化基础（防抖节流、重排重绘）

**第2天：进阶篇**
- ✅ HTML和CSS进阶（BFC、层叠上下文、居中、响应式）
- ✅ JavaScript进阶（事件循环、Promise、async/await、模块化）
- ✅ HTTP网络专项（HTTP/HTTPS、缓存、跨域、AJAX）
- ✅ Vue进阶（生命周期、路由、Vuex/Pinia）
- ✅ 性能优化进阶（图片优化、懒加载、代码分割）

**第3天：补充篇**
- ✅ HTML和CSS补充（本地存储、CSS3动画、移动端适配）
- ✅ JavaScript补充（深拷贝、数组方法、手写代码）
- ✅ Diff算法和迭代器专项（虚拟DOM、Diff算法、Iterator）
- ✅ Vue补充（keep-alive、v-model、指令）
- ✅ 性能优化补充（长列表、Vite、性能监控）

### ✅ 学习成果检验

完成三天学习后，你应该能够：
- ✅ 流畅回答60+道高频面试题
- ✅ 手写防抖、节流、Promise.all、深拷贝等代码
- ✅ 理解前端核心原理和底层机制
- ✅ 掌握HTTP网络、跨域、缓存等重要知识
- ✅ 理解Vue响应式、生命周期、Diff算法等核心原理
- ✅ 掌握性能优化的常用手段和工具
- ✅ 具备初级前端工程师的理论基础

---

## 📚 进阶学习资源

如果你已经掌握了三天的基础内容，可以继续学习：

1. **Vue深入** → [Vue和React事件机制原理对比.md](./Vue和React事件机制原理对比.md)
   - Vue vs React事件机制对比
   - 虚拟DOM和Diff算法深入

2. **Vuex深入** → [Vuex和Pinia面试题详解.md](./Vuex和Pinia面试题详解.md)
   - Vuex核心概念详解
   - Pinia最佳实践
   - 状态管理设计模式

3. **HTTP深入** → [HTTP经典面试题汇总.md](./HTTP经典面试题汇总.md)
   - HTTP/2、HTTP/3新特性
   - 网络安全、CSRF、XSS
   - TCP/IP协议栈

---

## 💡 面试技巧

1. **回答结构：** 先说是什么，再说为什么，最后说怎么用
2. **举例说明：** 理论结合实际项目经验
3. **对比总结：** 善用对比（如Vue2 vs Vue3、GET vs POST）
4. **深入原理：** 面试官追问时能答到底层
5. **代码规范：** 手写代码时注意命名和注释
6. **保持自信：** 不会的题目也要尝试分析和思考

---

## 📈 复习建议

**考前一周：**
- 每天复习一个模块的内容
- 重点看标记⭐⭐⭐⭐⭐的高频考点
- 做检验题，查漏补缺

**考前一天：**
- 快速过一遍所有必答题
- 手写代码练习（防抖、节流、深拷贝）
- 看一遍事件循环的典型例题
- 复习HTTP缓存流程和跨域方案

**考前准备：**
- 保持充足睡眠
- 准备好简历和作品集
- 模拟面试场景，练习表达

---

**🎉 恭喜你完成三天复习计划！继续加油，祝面试顺利！💪**

---

**📌 最后提示：**
- 所有蓝色链接都可以点击查看详细内容
- 建议将三天计划打印或保存，随时复习
- 面试前快速过一遍所有必答题
- 保持自信，相信自己的准备！
- 记住：面试不仅考察知识，更考察学习能力和思维方式
