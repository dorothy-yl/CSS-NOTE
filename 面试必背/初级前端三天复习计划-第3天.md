# 初级前端三天复习计划 - 第 3 天

> 📅 **学习时间**：第 3 天 | **目标**：HTML+CSS 补充 + JS 补充 + Diff 算法和迭代器 + Vue 补充 + 性能优化补充 | **建议时长**：8 小时

---

## 📚 今日学习内容导航

| 序号 | 模块                      | 核心知识点                                | 重要程度   | 预计时长 | 文件链接                                                                                                                                     |
| ---- | ------------------------- | ----------------------------------------- | ---------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | **HTML 和 CSS 补充**      | 本地存储、CSS3 动画、移动端适配、预处理器 | ⭐⭐⭐⭐   | 1.5 小时 | [HTML 面试总结大全.md](../面试总结大全/HTML面试总结大全.md)<br>[CSS 高频面试题汇总.md](./CSS高频面试题汇总.md)                               |
| 2    | **JavaScript 补充**       | 深拷贝浅拷贝、数组方法、手写代码          | ⭐⭐⭐⭐⭐ | 2 小时   | [JS 高频面试题汇总.md](./JS高频面试题汇总.md)                                                                                                |
| 3    | **Diff 算法和迭代器专项** | 虚拟 DOM、Vue Diff 算法、Iterator 迭代器  | ⭐⭐⭐⭐⭐ | 2 小时   | [diff 算法和虚拟 DOM 面试题汇总.md](./diff算法和虚拟DOM面试题汇总.md)<br>[Iterator 迭代器面试题-精简版.md](./Iterator迭代器面试题-精简版.md) |
| 4    | **Vue 补充**              | keep-alive、v-model 原理、Vue 指令        | ⭐⭐⭐⭐⭐ | 1.5 小时 | [Vue 面试总结大全.md](../面试总结大全/Vue面试总结大全.md)<br>[Vue 完整面试题汇总.md](./Vue完整面试题汇总.md)                                 |
| 5    | **性能优化补充**          | 长列表优化、Vite 优化、性能指标监控       | ⭐⭐⭐⭐⭐ | 1 小时   | [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md)                                                                                 |

---

## 📖 详细学习路径

### 第一模块：HTML 和 CSS 补充（1.5 小时）

#### ✅ HTML 补充（0.5 小时）→ [HTML 面试总结大全.md](../面试总结大全/HTML面试总结大全.md)

1. **本地存储对比**

   **Cookie vs localStorage vs sessionStorage：**
   | 特性 | Cookie | localStorage | sessionStorage |
   |------|--------|--------------|----------------|
   | 存储大小 | 4KB | 5-10MB | 5-10MB |
   | 生命周期 | 可设置过期时间 | 永久保存，除非手动删除 | 标签页关闭时删除 |
   | 作用域 | 同源下所有页面 | 同源下所有页面 | 同源的同一标签页 |
   | 服务器通信 | 自动随 HTTP 请求发送 | 不会发送到服务器 | 不会发送到服务器 |
   | API | document.cookie | localStorage.setItem/getItem | sessionStorage.setItem/getItem |

   **使用场景：**

   - Cookie：身份认证、用户偏好
   - localStorage：长期缓存、用户配置
   - sessionStorage：表单数据、临时状态

2. **HTML5 API**

   - Geolocation API：获取用户地理位置
   - Drag and Drop API：拖放功能
   - Canvas API：绘制图形、图表、游戏
   - Web Workers：后台线程，处理耗时任务
   - Service Worker：离线缓存、消息推送
   - History API：pushState、replaceState 操作历史记录

3. **Canvas 绘制圆形**

   **基本绘制步骤：**

   ```javascript
   // 1. 获取canvas元素
   const canvas = document.getElementById("myCanvas");
   const ctx = canvas.getContext("2d");

   // 2. 开始路径
   ctx.beginPath();

   // 3. 绘制圆弧（完整圆）
   ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
   // x, y: 圆心坐标
   // radius: 半径
   // startAngle: 起始角度（弧度制）
   // endAngle: 结束角度（弧度制）
   // anticlockwise: 是否逆时针（可选，默认false）

   // 4. 设置样式并渲染
   ctx.fillStyle = "red"; // 填充颜色
   ctx.fill(); // 填充圆形
   ctx.strokeStyle = "blue"; // 描边颜色
   ctx.lineWidth = 2; // 描边宽度
   ctx.stroke(); // 描边圆形
   ```

   **完整示例：**

   ```javascript
   const canvas = document.getElementById("myCanvas");
   const ctx = canvas.getContext("2d");

   // 绘制实心圆
   ctx.beginPath();
   ctx.arc(100, 100, 50, 0, Math.PI * 2);
   ctx.fillStyle = "#ff6b6b";
   ctx.fill();

   // 绘制空心圆
   ctx.beginPath();
   ctx.arc(250, 100, 50, 0, Math.PI * 2);
   ctx.strokeStyle = "#4ecdc4";
   ctx.lineWidth = 3;
   ctx.stroke();

   // 绘制半圆（扇形）
   ctx.beginPath();
   ctx.arc(400, 100, 50, 0, Math.PI);
   ctx.fillStyle = "#95e1d3";
   ctx.fill();
   ```

   **重要知识点：**

   - `Math.PI * 2` 代表 360 度（完整圆）
   - `Math.PI` 代表 180 度（半圆）
   - 角度使用弧度制：`弧度 = 角度 * Math.PI / 180`
   - `beginPath()` 开始新路径，避免影响之前的绘制
   - `fill()` 填充路径，`stroke()` 描边路径

   **常见应用场景：**

   - 图表绘制（饼图、环形图）
   - 游戏开发（角色、道具）
   - 数据可视化
   - 动画效果

#### ✅ CSS 补充（1 小时）→ [CSS 高频面试题汇总.md](./CSS高频面试题汇总.md)

1. **CSS3 动画与过渡**

   **transition 过渡：**

   ```css
   .box {
     transition: all 0.3s ease-in-out;
   }
   .box:hover {
     transform: scale(1.2);
   }
   ```

   **animation 动画：**

   ```css
   @keyframes fadeIn {
     from {
       opacity: 0;
     }
     to {
       opacity: 1;
     }
   }
   .box {
     animation: fadeIn 1s ease-out;
   }
   ```

   **transform 变换：**

   - translate：平移
   - rotate：旋转
   - scale：缩放
   - skew：倾斜

   **性能优化：**

   - 优先使用 transform 和 opacity（触发 GPU 加速）
   - 避免触发重排的属性（width、height、margin 等）

2. **移动端适配**

   **rem 适配：**

   ```javascript
   function setRem() {
     const baseSize = 16;
     const scale = document.documentElement.clientWidth / 375;
     document.documentElement.style.fontSize = baseSize * scale + "px";
   }
   window.addEventListener("resize", setRem);
   setRem();
   ```

   **vw/vh 适配：**

   - 1vw = 视口宽度的 1%
   - 1vh = 视口高度的 1%

   **1px 问题：**

   ```css
   .border {
     position: relative;
   }
   .border::after {
     content: "";
     position: absolute;
     left: 0;
     bottom: 0;
     width: 100%;
     height: 1px;
     background: #000;
     transform: scaleY(0.5);
   }
   ```

   **viewport 设置：**

   ```html
   <meta
     name="viewport"
     content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
   />
   ```

3. **CSS 预处理器**
   - **Less/Sass 变量：** `$primary-color: #007bff;`
   - **嵌套：** 简化选择器书写
   - **Mixin 混入：** 复用样式片段
   - **函数：** lighten()、darken()、透明度调整

---

### 第二模块：JavaScript 补充（2 小时）→ [JS 高频面试题汇总.md](./JS高频面试题汇总.md)

#### ✅ 必学知识点

1. **深拷贝与浅拷贝** → [JS 高频面试题汇总.md](./JS高频面试题汇总.md#10-深拷贝与浅拷贝-)

   **浅拷贝：**

   ```javascript
   // 方法1：扩展运算符
   const copy1 = { ...obj };
   const copy2 = [...arr];

   // 方法2：Object.assign
   const copy3 = Object.assign({}, obj);

   // 方法3：数组方法
   const copy4 = arr.slice();
   const copy5 = arr.concat();
   ```

   **深拷贝：**

   ```javascript
   // 方法1：JSON（有局限性：无法拷贝函数、undefined、Symbol、循环引用）
   const deepCopy1 = JSON.parse(JSON.stringify(obj));

   // 方法2：递归实现（推荐）
   function deepClone(obj, map = new WeakMap()) {
     if (obj === null || typeof obj !== "object") return obj;
     if (map.has(obj)) return map.get(obj); // 处理循环引用

     const clone = Array.isArray(obj) ? [] : {};
     map.set(obj, clone);

     for (let key in obj) {
       if (obj.hasOwnProperty(key)) {
         clone[key] = deepClone(obj[key], map);
       }
     }
     return clone;
   }

   // 方法3：structuredClone（新API，现代浏览器）
   const deepCopy2 = structuredClone(obj);
   ```

2. **数组常用方法**

   **遍历方法：**

   - forEach：遍历数组，无返回值
   - map：映射数组，返回新数组
   - filter：过滤数组，返回符合条件的新数组
   - reduce：累加器，返回单个值
   - some：是否有元素满足条件
   - every：是否所有元素满足条件
   - find：查找第一个满足条件的元素
   - findIndex：查找第一个满足条件的索引

   **修改原数组：**

   - push、pop：尾部添加/删除
   - shift、unshift：头部删除/添加
   - splice：任意位置增删改
   - sort、reverse：排序、反转

   **不修改原数组：**

   - concat：合并数组
   - slice：截取数组
   - join：数组转字符串
   - map、filter、reduce

   **实用技巧：**

   ```javascript
   // 数组去重
   const unique = [...new Set(arr)];
   const unique2 = arr.filter((item, index) => arr.indexOf(item) === index);

   // 数组扁平化
   const flat = arr.flat(Infinity);
   const flat2 = arr.toString().split(",").map(Number);

   // 数组求和
   const sum = arr.reduce((acc, cur) => acc + cur, 0);

   // 数组最大值
   const max = Math.max(...arr);
   ```

3. **手写经典代码**

   **手写防抖：**

   ```javascript
 
   function debounce(fn, delay) {
     let timer = null;
     return function (...args) {
       if (timer) clearTimeout(timer);
       timer = setTimeout(() => {
         fn.apply(this, args);
       }, delay);
     };
   }
   ```

   **手写节流：**

   ```javascript
   function throttle(fn, delay) {
     let last = 0;
     return function (...args) {
       const now = Date.now();
       if (now - last >= delay) {
         fn.apply(this, args);
         last = now;
       }
     };
   }
   ```

   **手写 Promise.all：**

   ```javascript
   Promise.myAll = function (promises) {
     return new Promise((resolve, reject) => {
       const results = [];
       let count = 0;
       for (let i = 0; i < promises.length; i++) {
         Promise.resolve(promises[i])
           .then((res) => {
             results[i] = res;
             count++;
             if (count === promises.length) resolve(results);
           })
           .catch(reject);
       }
     });
   };
   ```

   **手写 call、apply、bind：**

   ```javascript
   // call
   Function.prototype.myCall = function (context, ...args) {
     context = context || window;
     const fn = Symbol();
     context[fn] = this;
     const result = context[fn](...args);
     delete context[fn];
     return result;
   };

   // apply
   Function.prototype.myApply = function (context, args) {
     context = context || window;
     const fn = Symbol();
     context[fn] = this;
     const result = context[fn](...args);
     delete context[fn];
     return result;
   };

   // bind
   Function.prototype.myBind = function (context, ...args) {
     const fn = this;
     return function (...newArgs) {
       return fn.apply(context, [...args, ...newArgs]);
     };
   };
   ```

---

### 第三模块：Diff 算法和迭代器专项（2 小时）

#### ✅ 必学知识点

1. **虚拟 DOM** → [diff 算法和虚拟 DOM 面试题汇总.md](./diff算法和虚拟DOM面试题汇总.md)

   **虚拟 DOM 的定义：**

   - 用 JavaScript 对象描述 DOM 结构
   - 轻量级的 DOM 抽象

   **虚拟 DOM 的优势：**

   - 减少真实 DOM 操作，提升性能
   - 跨平台能力（React Native、Weex）
   - 方便实现 SSR

   **虚拟 DOM 结构：**

   ```javascript
   const vnode = {
     tag: "div",
     props: { class: "container" },
     children: [
       { tag: "h1", props: {}, children: ["Title"] },
       { tag: "p", props: {}, children: ["Content"] },
     ],
   };
   ```

2. **Vue Diff 算法** → [diff 算法和虚拟 DOM 面试题汇总.md](./diff算法和虚拟DOM面试题汇总.md)

   **Diff 算法目的：**

   - 找出新旧虚拟 DOM 的差异
   - 最小化 DOM 操作

   **Vue2 的双端比较：**

   1. 旧头 vs 新头
   2. 旧尾 vs 新尾
   3. 旧头 vs 新尾
   4. 旧尾 vs 新头
   5. 乱序比较（key 的作用）

   **Vue3 的最长递增子序列：**

   - 减少节点移动次数
   - 性能更优

   **key 的作用：**

   - 唯一标识节点
   - 复用和重新排序现有元素
   - 不要用 index 作为 key（列表会变化时）

   **为什么不建议用 index 作为 key？**

   ```javascript
   // 初始列表：[A, B, C]
   // 删除B后：[A, C]

   // 使用index作为key
   // 删除前：A(0), B(1), C(2)
   // 删除后：A(0), C(1)  ← C的key从2变成1，无法复用

   // 使用唯一ID作为key
   // 删除前：A(id:1), B(id:2), C(id:3)
   // 删除后：A(id:1), C(id:3)  ← C的key不变，可以复用
   ```

3. **Iterator 迭代器** → [Iterator 迭代器面试题-精简版.md](./Iterator迭代器面试题-精简版.md)

   **Iterator 接口：**

   ```javascript
   const iterator = {
     next() {
       return { value: any, done: boolean };
     },
   };
   ```

   **可迭代对象：**

   - Array、String、Map、Set、TypedArray
   - NodeList、arguments

   **for...of 循环：**

   ```javascript
   const arr = [1, 2, 3];
   for (let item of arr) {
     console.log(item); // 1, 2, 3
   }
   ```

   **自定义迭代器：**

   ```javascript
   const obj = {
     data: [1, 2, 3],
     [Symbol.iterator]() {
       let index = 0;
       const data = this.data;
       return {
         next() {
           if (index < data.length) {
             return { value: data[index++], done: false };
           } else {
             return { done: true };
           }
         },
       };
     },
   };

   for (let item of obj) {
     console.log(item); // 1, 2, 3
   }
   ```

   **Generator 函数：**

   ```javascript
   function* generator() {
     yield 1;
     yield 2;
     yield 3;
   }

   const gen = generator();
   console.log(gen.next()); // { value: 1, done: false }
   console.log(gen.next()); // { value: 2, done: false }
   console.log(gen.next()); // { value: 3, done: false }
   console.log(gen.next()); // { done: true }
   ```

---

### 第四模块：Vue 补充（1.5 小时）

#### ✅ 必学知识点

1. **keep-alive 缓存机制** → [Vue 面试总结大全.md](../面试总结大全/Vue面试总结大全.md)

   **作用：**

   - 缓存组件状态，避免重复渲染
   - 保留组件实例，不销毁

   **属性：**

   - include：缓存的组件名（字符串、数组、正则）
   - exclude：不缓存的组件名
   - max：最多缓存多少个组件

   **生命周期：**

   - activated：组件激活时调用
   - deactivated：组件失活时调用

   **使用场景：**

   - 列表页和详情页切换
   - 多标签页切换
   - 保持表单状态

   **示例：**

   ```vue
   <keep-alive :include="['Home', 'About']" :max="10">
     <router-view />
   </keep-alive>
   ```

2. **v-model 原理** → [Vue 面试总结大全.md](../面试总结大全/Vue面试总结大全.md#3-v-model原理)

   **核心原理：**

   - v-model 是语法糖
   - 结合属性绑定和事件监听实现双向绑定

   **不同元素的 v-model：**

   ```vue
   <!-- 文本输入框 -->
   <input v-model="text" />
   <!-- 等价于 -->
   <input :value="text" @input="text = $event.target.value" />

   <!-- 复选框 -->
   <input type="checkbox" v-model="checked" />
   <!-- 等价于 -->
   <input
     type="checkbox"
     :checked="checked"
     @change="checked = $event.target.checked"
   />

   <!-- 下拉选择框 -->
   <select v-model="selected">
     <option value="A">A</option>
   </select>
   <!-- 等价于 -->
   <select :value="selected" @change="selected = $event.target.value">
     <option value="A">A</option>
   </select>
   ```

   **自定义组件 v-model（Vue3）：**

   ```vue
   <!-- 父组件 -->
   <MyInput v-model="value" />
   <!-- 等价于 -->
   <MyInput :modelValue="value" @update:modelValue="value = $event" />

   <!-- 子组件 -->
   <template>
     <input
       :value="modelValue"
       @input="$emit('update:modelValue', $event.target.value)"
     />
   </template>
   <script>
   export default {
     props: ["modelValue"],
     emits: ["update:modelValue"],
   };
   </script>
   ```

3. **Vue 指令** → [Vue 完整面试题汇总.md](./Vue完整面试题汇总.md)

   **常用内置指令：**

   - v-if / v-else / v-else-if：条件渲染
   - v-show：显示/隐藏（display）
   - v-for：列表渲染
   - v-model：双向绑定
   - v-bind（:）：属性绑定
   - v-on（@）：事件监听
   - v-once：只渲染一次
   - v-html：渲染 HTML
   - v-text：文本内容
   - v-cloak：防止闪烁

   **v-if vs v-show：**
   | 特性 | v-if | v-show |
   |------|------|--------|
   | 渲染方式 | 条件性渲染 | 始终渲染，切换 display |
   | 性能 | 切换时开销大 | 初始渲染开销大 |
   | 使用场景 | 条件很少改变 | 频繁切换 |

4. **Vue Router 深入** → [Vue 完整面试题汇总.md](./Vue完整面试题汇总.md#16-路由传参)

   **路由传参：**

   ```javascript
   // params传参（动态路由）
   { path: '/user/:id', component: User }
   this.$router.push({ name: 'User', params: { id: 123 } });
   // 访问：this.$route.params.id

   // query传参（查询参数）
   this.$router.push({ path: '/user', query: { id: 123 } });
   // 访问：this.$route.query.id
   ```

   **路由懒加载：**

   ```javascript
   const Home = () => import("./views/Home.vue");
   const About = () =>
     import(/* webpackChunkName: "about" */ "./views/About.vue");
   ```

---

### 第五模块：性能优化补充（1 小时）→ [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md)

#### ✅ 必学知识点

1. **长列表优化** → [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md#三javascript优化)

   **虚拟滚动（Virtual Scroll）：**

   - 原理：只渲染可视区域的列表项
   - 计算：可视区域高度 / 每项高度 = 可见数量
   - 滚动时动态计算 startIndex 和 end
   - Index

   **时间分片（Time Slicing）：**

   ```javascript
   function timeSlice(list, fn, count = 100) {
     let index = 0;
     function chunk() {
       for (let i = 0; i < count && index < list.length; i++, index++) {
         fn(list[index]);
       }
       if (index < list.length) {
         requestAnimationFrame(chunk);
       }
     }
     chunk();
   }
   ```

   **分页加载和无限滚动：**

   - 分页：适用于数据量大、需要精确翻页
   - 无限滚动：适用于社交媒体流

2. **Vite 构建优化** → [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md#七webpackvite优化)

   **Vite vs Webpack：**
   | 特性 | Vite | Webpack |
   |------|------|---------|
   | 开发环境 | ES Module，按需编译 | 全量打包 |
   | 启动速度 | 极快 | 较慢 |
   | 热更新 | 快速 | 相对较慢 |
   | 生产环境 | Rollup | Webpack |

   **Vite 优化技巧：**

   - 依赖预构建：使用 esbuild（Go 语言）
   - 按需编译：只编译当前页面需要的模块
   - 缓存：依赖缓存、源码缓存

   **Vite 配置优化：**

   ```javascript
   // vite.config.js
   export default {
     build: {
       rollupOptions: {
         output: {
           manualChunks: {
             vendor: ["vue", "vue-router", "pinia"],
             utils: ["lodash", "dayjs"],
           },
         },
       },
       chunkSizeWarningLimit: 1000,
     },
   };
   ```

3. **性能指标监控** → [前端性能优化面试题精简版.md](./前端性能优化面试题精简版.md#一性能指标与衡量标准)

   **核心性能指标：**

   - FP（First Paint）：首次绘制
   - FCP（First Contentful Paint）：首次内容绘制
   - LCP（Largest Contentful Paint）：最大内容绘制
   - CLS（Cumulative Layout Shift）：累积布局偏移
   - FID（First Input Delay）：首次输入延迟
   - TTI（Time to Interactive）：可交互时间

   **性能监控：**

   ```javascript
   // Performance API
   const observer = new PerformanceObserver((list) => {
     for (const entry of list.getEntries()) {
       console.log("LCP:", entry.renderTime || entry.loadTime);
     }
   });
   observer.observe({ type: "largest-contentful-paint", buffered: true });

   // Navigation Timing
   window.addEventListener("load", () => {
     const timing = performance.timing;
     const loadTime = timing.loadEventEnd - timing.navigationStart;
     console.log("页面加载时间:", loadTime);
   });
   ```

   **错误监控：**

   ```javascript
   // 全局错误监听
   window.addEventListener("error", (event) => {
     console.error("Error:", event.error);
   });

   // Promise错误监听
   window.addEventListener("unhandledrejection", (event) => {
     console.error("Unhandled Promise:", event.reason);
   });
   ```

   **常见监控平台：**

   - Sentry：错误监控、性能监控
   - Fundebug：前端错误监控
   - 神策分析：用户行为分析

---

## 📝 今日学习检验

### 必答问题清单（第 3 天）

#### HTML 和 CSS 模块

1. ✅ localStorage、sessionStorage、Cookie 的区别？
2. ✅ CSS3 动画 animation 和 transition 的区别？
3. ✅ 移动端 rem 适配的原理是什么？
4. ✅ 如何解决移动端 1px 问题？

#### JavaScript 模块

5. ✅ 深拷贝和浅拷贝的区别？手写深拷贝函数？
6. ✅ 数组的 map、filter、reduce 有什么区别？
7. ✅ 数组去重有哪些方法？
8. ✅ 手写防抖和节流函数？
9. ✅ 手写 Promise.all？

#### Diff 算法和迭代器模块

10. ✅ 什么是虚拟 DOM？有什么优势？
11. ✅ Vue 的 Diff 算法原理？key 的作用？
12. ✅ 为什么不建议用 index 作为 key？
13. ✅ 什么是 Iterator 迭代器？
14. ✅ for...of 和 for...in 的区别？
15. ✅ Generator 函数有什么用？

#### Vue 模块

16. ✅ keep-alive 的作用和使用场景？
17. ✅ v-model 的实现原理是什么？
18. ✅ v-if 和 v-show 的区别？什么时候用哪个？
19. ✅ Vue Router 的 params 和 query 传参有什么区别？

#### 性能优化模块

20. ✅ 什么是虚拟滚动？原理是什么？
21. ✅ Vite 为什么比 Webpack 快？
22. ✅ 前端核心性能指标有哪些？
23. ✅ 如何监控前端性能？

---

## 🎯 三天学习总结

### 📊 知识点全覆盖

恭喜你完成了三天的系统复习！现在你已经掌握了：

**第 1 天：基础篇**

- ✅ HTML 和 CSS 基础（语义化、盒模型、Flex、定位）
- ✅ JavaScript 基础（数据类型、作用域、this、闭包、原型链）
- ✅ 事件机制专项（事件流、事件委托、addEventListener）
- ✅ Vue 基础（响应式、ref/reactive、computed/watch、组件通信）
- ✅ 性能优化基础（防抖节流、重排重绘）

**第 2 天：进阶篇**

- ✅ HTML 和 CSS 进阶（BFC、层叠上下文、居中、响应式）
- ✅ JavaScript 进阶（事件循环、Promise、async/await、模块化）
- ✅ HTTP 网络专项（HTTP/HTTPS、缓存、跨域、AJAX）
- ✅ Vue 进阶（生命周期、路由、Vuex/Pinia）
- ✅ 性能优化进阶（图片优化、懒加载、代码分割）

**第 3 天：补充篇**

- ✅ HTML 和 CSS 补充（本地存储、CSS3 动画、移动端适配）
- ✅ JavaScript 补充（深拷贝、数组方法、手写代码）
- ✅ Diff 算法和迭代器专项（虚拟 DOM、Diff 算法、Iterator）
- ✅ Vue 补充（keep-alive、v-model、指令）
- ✅ 性能优化补充（长列表、Vite、性能监控）

### ✅ 学习成果检验

完成三天学习后，你应该能够：

- ✅ 流畅回答 60+道高频面试题
- ✅ 手写防抖、节流、Promise.all、深拷贝等代码
- ✅ 理解前端核心原理和底层机制
- ✅ 掌握 HTTP 网络、跨域、缓存等重要知识
- ✅ 理解 Vue 响应式、生命周期、Diff 算法等核心原理
- ✅ 掌握性能优化的常用手段和工具
- ✅ 具备初级前端工程师的理论基础

---

## 📚 进阶学习资源

如果你已经掌握了三天的基础内容，可以继续学习：

1. **Vue 深入** → [Vue 和 React 事件机制原理对比.md](./Vue和React事件机制原理对比.md)

   - Vue vs React 事件机制对比
   - 虚拟 DOM 和 Diff 算法深入

2. **Vuex 深入** → [Vuex 和 Pinia 面试题详解.md](./Vuex和Pinia面试题详解.md)

   - Vuex 核心概念详解
   - Pinia 最佳实践
   - 状态管理设计模式

3. **HTTP 深入** → [HTTP 经典面试题汇总.md](./HTTP经典面试题汇总.md)
   - HTTP/2、HTTP/3 新特性
   - 网络安全、CSRF、XSS
   - TCP/IP 协议栈

## 📈 复习建议

**考前一周：**

- 每天复习一个模块的内容
- 重点看标记 ⭐⭐⭐⭐⭐ 的高频考点
- 做检验题，查漏补缺

**考前一天：**

- 快速过一遍所有必答题
- 手写代码练习（防抖、节流、深拷贝）
- 看一遍事件循环的典型例题
- 复习 HTTP 缓存流程和跨域方案

**考前准备：**

- 保持充足睡眠
- 准备好简历和作品集
- 模拟面试场景，练习表达

---

**🎉 恭喜你完成三天复习计划！继续加油，祝面试顺利！💪**

---

**📌 最后提示：**

- 所有蓝色链接都可以点击查看详细内容
- 建议将三天计划打印或保存，随时复习
- 面试前快速过一遍所有必答题
- 保持自信，相信自己的准备！
- 记住：面试不仅考察知识，更考察学习能力和思维方式
